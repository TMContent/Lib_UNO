<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>99435f29-517e-48ea-a531-448bad4ecd92</Id>
    <Id_History>99435f29-517e-48ea-a531-448bad4ecd92,fd2dfd83-15f5-469c-85d2-4c359ffb1972,</Id_History>
    <Library_Id>f215ceee-9a08-41d9-b2c1-bbcc058a8f32</Library_Id>
    <Title>Use Secure Intents When Performing IPC</Title>
    <Category>Inter-Process Communication</Category>
    <Phase>Implementation</Phase>
    <Technology>Android</Technology>
    <Type>Guideline</Type>
    <DirectLink>Use Secure Intents When Performing IPC</DirectLink>
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="wikitext">
    <Data><![CDATA[==Applies To==

* Android

==What to Do==

Intents are used to send broadcasts, start and stop services, and start activities and subactivities. Implement proper security mechanisms for intents to ensure that sensitive information is not inadvertently disclosed to other application processes.

==Why==

Intents are used as a method of inter-process communication (IPC) on Android devices. When incorrectly configured, they can leak information to other applications or processes. Some of this occurs by design with Android, so it is imperative to learn proper coding techniques.

==When==

Use secure intents when sending broadcasts, starting and stopping services, and starting activities or subactivities.

==How==

To use secure intents:

# **Determine what you require for your intent.** If it is specific to your activities or services within your package, use an explicit intent. The component named in the intent constructor will be the only class to receive the intent message. You can further secure components that receive intents through custom permissions in the Android manifest file. Doing so requires that any intent calling your component have the same permission specified in its manifest.
# **If you are not sure which receivers can consume your intent, use an implicit intent.** Android makes a determination about which receivers can view an implicit intent based on which actions and intent filters they have, so it is not in your control who will receive them. As a result, it is critical that you do not rely on implicit intents for secure communications.
# **Be careful about sending extra information.** It is possible to put additional information in an intent by using the //putExtra()// method, but exercise caution about what type of information you send. According to testing through CommonsWare, it is possible to view this data for certain tasks by using the //ActivityManager//. Also, a malicious application could use the same package name as the intended recipient, provided, of course, that the recipient’s application is not already installed. Therefore, even with explicit intents, avoid communicating sensitive data such as user accounts and passwords.

==Problem Example==

As the MyApp developer, you need a service that will continually run in the background, waiting for a value to insert into the database. You design the service so that whenever an activity has an error or warning, the service logs it to the database. You believe that the intent filter will provide enough security and set the service entry in the manifest as:

{{{
<service android:name=".ErrorUploadService"  >
  <intent-filter>
    <action android:name="com.sample.coding.security.ERROR" />
  </intent-filter>
</service> 
}}}

The service’s //onStartCommand()// method calls //intent.getStringExtra("CODE")// to retrieve the value to upload. Another package in Android—one that does not belong to the MyApp team—has discovered this service and the intent filter. You add the following to an intent:

{{{
Intent intent = new Intent("com.sample.coding.security.ERROR");
intent.putExtra("CODE", false);
startService(intent);
}}}

With these three lines, the external, unauthorized package is able to start the MyApp service at will and insert anything it wants into the database. This obviously causes problems for MyApp’s data integrity.

==Solution Example==

To avoid this problem, update the manifest with permissions for the service intent. Label the service as:

{{{
<service android:name=".ErrorUploadService"  >
<android:permission="com.sample.CODE" >
  <intent-filter>
    <action android:name="com.sample.ERROR" />
  </intent-filter>
</service> 
}}}

If an external service wants to access MyApp through the //.ErrorUpLoadService//, it will have to add a permission similar to the one below to its Android manifest:

{{{
<uses-permission android:name="com.rps.bwahaha.CODE" />
<permission android:name="com.sample.CODE"
  android:label="@string/permission_label"
  android:description="@string/permission_desc"
  android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
  android:protectionLevel="dangerous" />
}}}

Because the service is not intended for use outside the MyApp application, you may also want to add the //android:exported="false"// tag to avoid any external interprocess communication with the service. If you do this, there will be no way for an external application to access the service.

]]></Data>
  </Content>
</TeamMentor_Article>