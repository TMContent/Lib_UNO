<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>3f437f69-e3af-4ef0-b886-b45c087ddec7</Id>
    <Id_History>27bea6b1-776b-46d4-8e9e-f74df6341be0,</Id_History>
    <Library_Id>d9c2b53f-5b05-4152-be72-e79d72854707</Library_Id>
    <Title>How to Test for Client-side Validation Bypass Vulnerabilities in Scala with Play Framework</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology>Scala with Play Framework</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for Client-side Validation Bypass Vulnerabilities in Scala with Play Framework</DirectLink>
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="html">
    <Data><![CDATA[<h1>
    <p>Applies to</p>
  </h1>Applications &nbsp;written using Scala and Play Framework 2.1.0 that use client-side JavaScripts.<br /><p style="font-family: Arial, Verdana; font-size: 13px;"><b></b></p><h1 style="font-family: Arial, Verdana;">Summary</h1><p style="font-family: Arial, Verdana; font-size: 13px;">Many Web applications validate client input via client-side scripts (sent to the client along with Web pages) which check that input to Web forms is not malicious and is properly formatted. The scripts are designed to check for injection attacks such as SQL injection and cross-site scripting, and to avoid a round trip for simple format checks such as email addresses, phone numbers, and ZIP codes. A client-side validation bypass attack occurs when the attacker modifies or annuls a client-side script in order to successfully submit malicious input and execute an attack on the application.</p><p style="font-family: Arial, Verdana; font-size: 13px;">Follow these steps to test for client-side validation bypass vulnerabilities in Scala with Play Framework:</p><ul style="font-family: Arial, Verdana; font-size: 13px;"><li>Step 1: Understand attack scenarios</li><li>Step 2: Understand the cause: Lack of server-side validation<br /></li><li>Step 3: Start testing and exploring</li><li>Step 4: Execute additional testing</li></ul><h1 style="font-family: Arial, Verdana;">Step 1: Understand attack scenarios</h1><p style="font-family: Arial, Verdana; font-size: 13px;">First, it is necessary to understand how attackers exploit client-side validation bypass vulnerabilities.&nbsp;Two common ways of bypassing client-side scripts are:</p><ul style="font-family: Arial, Verdana; font-size: 13px;"><li>Disabling a client-side script prior to submitting a request</li><li>Modifying validated data after submitting a request, using an HTTP proxy</li></ul><p style="font-family: Arial, Verdana; font-size: 13px;"><b><i></i></b></p><h2 style="font-family: Arial, Verdana;"><font size="3">Scenario 1: Disabling a client-side script prior to submitting a request</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">In this scenario, the attacker disables the client-side script by setting his browser options to disable JavaScript before making the actual request to the application server. By doing this, the attacker may submit any sequence of characters to the application.</p><p style="font-family: Arial, Verdana; font-size: 13px;">In detail:</p><ol style="font-family: Arial, Verdana; font-size: 13px;"><li>Attacker requests a Web page containing input fields, such as a Web form. The application sends a Web page with a client-side input validation script.</li><li>Attacker receives the Web page and annuls the client-side validation by disabling JavaScript in the browser.</li><li>Attacker enters malicious data in the input fields and submits the Web form.</li></ol><p style="font-family: Arial, Verdana; font-size: 13px;">Note, however, that many applications, including AJAX-based applications, rely on JavaScript capabilities, so the attacker might be unable to submit the form with JavaScript disabled. In this&nbsp;&nbsp; case, the attacker executes the following attack.</p><h2 style="font-family: Arial, Verdana;"><font size="3">Scenario 2: Modifying validated data after submitting a request by using an HTTP proxy</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">In this scenario, the attacker doesn’t modify or disable the client-side script. Rather, he proxies the browser through an HTTP packet-intercepting proxy such as Burp proxy or WebScarab. The attacker then enters well-formed input data into the target input fields and submits the request. The attacker then uses the proxy to intercept the request and change the well-formed input data into a malicious string.</p><p style="font-family: Arial, Verdana; font-size: 13px;">In detail:</p><ol style="font-family: Arial, Verdana; font-size: 13px;"><li>Attacker requests a Web page containing input fields, such as a Web form. The application sends a Web page with a client-side input validation script.</li><li>Attacker proxies the browser through HTTP proxy and enables HTTP packet interception.</li><li>Attacker enters well-formed (allowed) data in the input fields and then submits the Web form. Since the input is valid, the Web page makes a request to the application, which is intercepted by HTTP proxy.</li><li>In HTTP proxy, the attacker replaces the well-formed data with malicious data and forwards the packet to the application.</li></ol><h1 style="font-family: Arial, Verdana;">Step 2: Understand the cause: Lack of server-side validation<br /></h1><p style="font-family: Arial, Verdana; font-size: 13px;">Client-side validation bypass vulnerabilities occur when applications rely only on client-side checks for security with no validation on the server. <br /></p><p style="font-family: Arial, Verdana; font-size: 13px;">Client side validation is fine for reducing the number of round trips between the client and server. For instance, the following code checks if an email address is valid before submitting a Web form. When a client clicks on the submit button, there is a client side&nbsp;check for a valid email address before submitting the form:</p><pre style="font-size: 13px;">&nbsp;<br /><br /><br /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><br /><title>Scala and Play Search</title><br />&nbsp; <br /><script><br />function validateForm(emailStr)<br />{<br />	// checks if the e-mail address is valid<br />	var emailPat = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$";<br />	var matchArray = emailStr.match(emailPat);<br />	if (matchArray == null)<br />         {<br />		alert("Incorrect email address format");<br />		return false;<br />	}<br />	document.form1.action = "getProfile";<br />&nbsp;&nbsp; 	document.form1.method = "POST";<br />&nbsp;&nbsp; 	docuemnt.form1.submit();<br />&nbsp;&nbsp; 	return true; <br />}<br /></script><br /></pre><pre style="font-size: 13px;"><br />&nbsp;&nbsp;&nbsp; <br /><form name="form1" action="getProfile" method="POST" /></form></form></form></form></form></form></form><_br3d_22_22_></form><strong>onsubmit="return validateForm(this.username.value);</strong>"><br />&nbsp;<br />Email address: <br /><input name="username" size="20" type="text" /><br /><br />&nbsp;&nbsp; Password: <br /><input name="password" size="20" type="password" /><br /><br /><input value="Submit" type="submit" /><br />&nbsp;<br /><br /><br /><!--_br3d_22_22_       --></pre><p style="font-family: Arial, Verdana; font-size: 13px;" /><p style="font-family: Arial, Verdana; font-size: 13px;">Note that the form invokes a server-side method named&nbsp;<em>getProfile</em>&nbsp;through a validating JavaScript function that alerts the client if the input email address is in an incorrect format. This avoids a round-trip to the server to check for valid email address formats. The problem arises when developers rely on this kind of check to protect against attacks such as SQL injection, cross-site scripting, and command injection. Attackers can trivially bypass client-side checks, such as the one above, in order to attack the application.</p><p style="font-family: Arial, Verdana; font-size: 13px;">To protect against client-side bypass attacks, Scala with Play applications must perform proper validation at the server:</p><p style="font-family: Arial, Verdana; font-size: 13px;" /><pre style="font-size: 13px;">val email = ContactForm.emailid</pre><pre style="font-size: 13px;">val emailPattern = "^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$".r
val issafe =emailPattern.pattern.matcher(email).matches
if (issafe){
...... //Code for Acceptance
}else{
...... //Code for Exception
}</pre><pre style="font-size: 13px;"><br /></pre><p /><h1 style="font-family: Arial, Verdana;">Step 3: Start testing and exploring</h1><p style="font-family: Arial, Verdana; font-size: 13px;">To test for client-side validation bypass vulnerabilities, execute basic test cases from an attacker’s perspective to see if they are successful in&nbsp;your application.</p><h2 style="font-family: Arial, Verdana;"><font size="3">Test by disabling JavaScript in Internet browser</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">To test for client-side validation bypass vulnerabilities by disabling JavaScript:</p><ol style="font-family: Arial, Verdana; font-size: 13px;"><li>Open a browser and navigate to the Web page containing client-side validation script.</li><li>Open browser Options and navigate to security options.</li><li>Disable JavaScript and then click OK.</li><li>Submit ill-intended data in the Web form.</li></ol><p style="font-family: Arial, Verdana; font-size: 13px;">Secure result: The application performs proper server-side validation and rejects the ill-intended data.&nbsp;</p><h2 style="font-family: Arial, Verdana;"><font size="3">Test by intercepting HTTP request using a proxy</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">To test for client-side validation bypass vulnerabilities by modifying a Web page:</p><ol style="font-family: Arial, Verdana; font-size: 13px;"><li>Open a browser and navigate to a Web page containing a client-side validation script.</li><li>Download and execute Burp suite (<a href="http://portswigger.net/suite/">http://portswigger.net/suite/</a>).</li><li>In&nbsp;<em>Proxy->Intercept</em>&nbsp;tab, set proxy to “<em>intercept is on</em>.”</li><li>In browser, set connection options to use Burp proxy.</li><li>Fill in the Web page with allowed values, such as a valid email address.</li><li>Submit the Web page.</li><li>In Burp proxy, modify the intercepted request by replacing the allowed values with malformed ones (see Figures 1 and 2 below).</li><li>Forward request.</li></ol><p style="font-family: Arial, Verdana; font-size: 13px;">Secure result: The application performs proper server-side validation and rejects the ill-intended data.</p><p style="font-family: Arial, Verdana; font-size: 13px;"><strong></strong></p><p style="font-family: Arial, Verdana; font-size: 13px;" /><h1 style="font-family: Arial, Verdana;">Step 4: Take note of special testing scenarios<br /></h1><p style="font-family: Arial, Verdana; font-size: 13px;">The final step in testing for client-side validation vulnerabilities is to understand special testing scenarios:</p><h2 style="font-family: Arial, Verdana;"><font size="3">AJAX applications are at high risk</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">AJAX (Asynchronous JavaScript and XML) applications rely heavily on client-side scripts. When testing for this vulnerability in AJAX applications, note that it is impossible to disable JavaScript, as this will stop the browser from making requests. Therefore, test by intercepting an HTTP request using a proxy.</p><h2 style="font-family: Arial, Verdana;"><font size="3">Consider Additional Frameworks</font></h2><p style="font-family: Arial, Verdana; font-size: 13px;">Web developers sometimes integrate Scala applications with other Internet frameworks such as Flash/Flex. Frameworks such as these might provide their own client-side forms with data validation options, and developers might rely on them to validate their input on the client only. Be sure to test Flash parameters for client-side validation bypass vulnerabilities. Ensure that the application validates at the server.</p><div id="selectedGuidanceItem" class="selectedGuidanceItem ItemContent" style="margin: 0px; padding: 10px; font-family: 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: small; background-color: rgb(255, 255, 255);"><h1 style="margin: 0px; padding: 10px 0px 0px; font-size: 17px; color: rgb(17, 17, 17);">Input and Data Validation Guidelines</h1><ul style="margin: 10px 0px 10px 25px; padding: 0px 0px 0px 30px; color: rgb(17, 17, 17);"><li style="margin: 0px; padding: 0px;"><font color="#333399" style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="af528b9a-af5f-49b8-a314-4578c0b31273" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">Validate Input from All Sources</a></b></font></li><li style="margin: 0px; padding: 0px;"><font color="#333399" style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="b6795407-d01e-44ec-8aed-a440d388902b" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">Validate Input for Length, Range, Format, and Type</a></b></font></li><li style="margin: 0px; padding: 0px;"><font color="#333399" style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="00000000-0000-0000-0000-00000016b3b2" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">Validate All Input Passed to the Database</a></b></font></li><li style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px; color: rgb(51, 51, 153);"><a href="97d61072-14e2-48dd-a1bf-ec149efbcb54" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">Do Not Rely on Client-Side Validation</a></b></li></ul><h1 style="margin: 0px; padding: 10px 0px 0px; font-size: 17px; color: rgb(17, 17, 17);">Input and Data Validation Checklists</h1><ul style="margin: 10px 0px 10px 25px; padding: 0px 0px 0px 30px;"><li style="margin: 0px; padding: 0px;"><font style="margin: 0px; padding: 0px;"><a href="0bf6f129-8641-43f4-a29c-62f58493fb78" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-weight: bold;"><b style="margin: 0px; padding: 0px;">Input from All Sources Is Validated</b></a></font></li><li style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="067e2f72-18f0-4f5a-ba9c-287691cd9ed3" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">Input Is Validated for Length, Range, Format and Type</a></b></li><li style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="2faf9bc6-fb15-4341-bb10-7dbc39e30d6e" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">All Database Input Is Validated</a></b></li><li style="margin: 0px; padding: 0px;"><b style="margin: 0px; padding: 0px;"><a href="c5688313-0255-461c-a978-423596d182db" target="_blank" style="margin: 0px; padding: 0px; color: rgb(0, 0, 0);">The Application Does Not Rely on Client-Side Validation</a></b></li></ul></div><span style="font-family: Arial, Verdana; font-size: 13px;"><br /><br /></span>]]></Data>
  </Content>
</TeamMentor_Article>