<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>1dab3725-6d02-4fc4-a44b-a39445e59b02</Id>
    <Id_History>bf9f81b3-21f3-4b18-b5ac-6eb932ce764e,</Id_History>
    <Library_Id>f215ceee-9a08-41d9-b2c1-bbcc058a8f32</Library_Id>
    <Title>Use LocalBroadcastManager to Prevent Data Leaks</Title>
    <Category>Communication Security</Category>
    <Phase>Implementation</Phase>
    <Technology>Android</Technology>
    <Type>Guideline</Type>
    <DirectLink>Use LocalBroadcastManager to Prevent Data Leaks</DirectLink>
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="wikitext">
    <Data><![CDATA[==Applies To==
Android

==What to Do==
If broadcasts do not need to exit an application's boundary, use a LocalBroadcastManager. Doing so provides an efficient implementation without the security concerns of using interprocess communication (IPC) channels.
  
If broadcasts will exit the application's boundary, prevent data leakage by properly constructing the intents sent for remote BroadcastReceivers and the intents allowed into the application through its own BroadcastReceiver(s).

==Why==
The BroadcastReceiver class provides a mechanism for monitoring or sending information about process events through intents. (Note that these intents are fundamentally different from those used to launch an activity or start a service.) If not properly secured, broadcasts can leak data to unauthorized processes or cause an application to behave erratically.

==When==
Implement these practices if your application uses a BroadcastReceiver or sendBroadcast method.

==How==
To prevent data leaks using LocalBroadcastManager:
# **Decide whether you need LocalBroadcastManager**. If all communications will exist within the application, use a LocalBroadcastManager instead of IPC. 
# **Prevent intent name conflicts**. If IPC is required, ensure that the intent action names do not conflict with other packages. In that case, use your package namespace as a prefix.
# **Use manifest permissions to limit who can receive broadcasts from your application**. Where possible, disable other processes from sending receivers an intent with android:exported="false" in the manifest. You can further limit what a receiver can receive with permissions in the manifest.
# **Send broadcasts correctly**. Before using sendOrderedBroadcast(), consider that Android sends the broadcast to recipients one at a time. Each recipient can pass the broadcast to the next or consume it. If the goal is to provide the broadcast to a specific receiver, use sendBroadcast() with a specific intent.

==Problem Example==
As the MyApp developer, you have set up a BroadcastReceiver to allow one of the background services to communicate when a database routine has been run. In the activity that will display the status of the database routine, you code the BroadcastReceiver class.
{{{
BroadcastReceiver mReceiverStatus = new BroadcastReceiver() {
@Override
public void onReceive(Context context, Intent intent) {
			int statusId = intent.getIntExtra("STATUS", -1);
			updateProgress (statusId);
        		}}
    	};
}}}

In the {{{onCreate()}}} method, you register the receiver with an intent and intent filter:

{{{
IntentFilter filterStatus = new IntentFilter();
	filterStatus.addAction("STATUS");
	registerReceiver (mReceiverStatus, filterStatus, null, null);
}}}


When the application is running, you notice some odd data entering the application. After investigating for days, you realize that you may be receiving data from another broadcast. This reception is corrupting your applicationâ€™s integrity.

==Solution Example==

In this case, you chose a poor name: The string "STATUS" is common for an intent filter. Because the broadcast receiver is registered to receive any system broadcasts with that intent filter, there is a high likelihood it will view other application broadcasts. Instead, choose a less common name with the prefix of your package. For example:

{{{
	filterStatus.addAction("com.myapp.dbMethod.state");
}}}

Next, because the communications are all within MyApp, there is no need for IPC. Using a {{{LocalBroadcastManager}}} makes more sense. You can keep the {{{BroadcastReceiver}}} class but register it in {{{onCreate()}}} as:

{{{
LocalBroadcastManager.getInstance(this).registerReceiver(mReceiverStatus,
      new IntentFilter("com.myapp.dbMethod.state"));
}
}}}


If you later decide that you need to receive inter-process broadcasts, you can include a permission name when registering the receiver:

{{{
registerReceiver(mReceiverStatus, filterStatus, "com.myapp.STATE_MESSAGE", null);
}}}

The sending application will now need to specify this permission in its manifest with something akin to the code below:

{{{
<uses-permission android:name=" com.myapp.STATE_MESSAGE "/>
	<permission android:name=" com.myapp.STATE_MESSAGE "
        		android:label="@string/monitoring_permission_label"
       		 android:description="@string/monitoring_permission_desc"
        		android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
        		android:protectionLevel="dangerous" />
}}}


==Related Items in TeamMentor==

*Provide a link to the **Principle** this guideline outlines implementation for.
*Provide links to related **How-to(s)**. 
*Provide links to related **Code Example(s)**.
*Provide links to the **Checklist Item** that is used to validate implementation of this guideline.
*Provide links to **Vulnerability(ies)** that this guideline will mitigate.
*Provide links to **Attack(s)** that this guideline will prevent.
*Provide links to related **Guideline(s)**.
*Provide links to other related TM Content.\\
\\

==Additional Resources==
If applicable, provide **trusted** links in the form of a bullet list:
*Provide trusted trusted links to additional outside resources.
*Specify relevant references.\\
\\
]]></Data>
  </Content>
</TeamMentor_Article>