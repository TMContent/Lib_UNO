# What to Check For

Ensure that all input parameters from form fields, query strings, cookies, and HTTP headers are validated. Validation routines should check for length, range, format, and type. Validation should check first for known valid and safe data and then for malicious, dangerous data.

# Why

An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities.

# How To Check

To check for this problem, use the following steps: 

1.  **Find all sources of input.** During design time identify all of the potential sources of input parameters to your application. Scour the source code to discover sources of input that may have been missed in the design. Compile a list that you can use in the following steps. The most common sources are:

    *   Form Fields
    *   Query Strings
    *   Cookies
    *   HTTP Headers
    
2.  **Trace data from source to sink.** Trace each of source of input through your application until you find its ultimate destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a database.

3.  **Identify validation routines.** Each input source should have a data validation routine associated with it. Ideally the validation will occur as soon after the input reaches your application as possible. Shared validation routines are better than creating many spread throughout your code base, check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If an input source does not have a validation routine associated with it, flag it for fixing.

4.  **Ensure quality of validation routines.** Validation routines should check for length, range, format, and type. Validation should check first for known valid and safe data and then for malicious, dangerous data. Do not rely on filtering out all malicious data, it is too easy to miss something. Do not rely on client-side validation alone as it can be easily bypassed.

# How To Fix

Check for known good data and constrain input by validating it for type, length, format, and range. For Web form applications that obtain input through server controls, use the ASP.NET validator controls, such as the _RegularExpressionValidator_, _RangeValidator_, and _CustomValidator_, to validate and constrain input. Check all numeric fields for type and range. If you are not using server controls, you can use regular expressions and the _Regex_ class, and you can validate numeric ranges by converting the input value to an integer or double and then performing a range check. Validate your input against the least permissive expression possible that will accept all the input you expect for that field. If you know that the field will have certain internal structure, check for it. If your input has an internal checksum, like a credit card number, check that too.

Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies. Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input. The following example shows how to use the _Regex_ class.

<pre>using System.Text.RegularExpressions ;  
// Instance method:  
Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");  
Response.Write(reg.IsMatch(Request.QueryString["Name"]));  
// Static method:  
if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$"))  
{  
   // Name does not match expression  
}</pre>

If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons, to avoid unnecessary object creation.

Remember that validating input does not remove the need to format output, parameterize queries, or otherwise handle user input carefully.

# Related Items

*   [Validate All Input](/article/3de41277-0cc1-4ebc-8dd7-e96d161aa0ef)

* * *

Adapted from Microsoft patterns & practices guidance.