<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1773438820" Content_Hash="1366522817">
  <Metadata>
    <Id>d02961a8-f8c9-48c7-99be-708ae5259910</Id>
    <Id_History>d02961a8-f8c9-48c7-99be-708ae5259910,b524f8cf-af1f-49e3-b79b-d2d4b6a7ac30,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>Echoed Input Is Encoded</Title>
    <Category>Encoding</Category>
    <Phase>Design</Phase>
    <Technology>ASP.NET 4.0</Technology>
    <Type>Checklist Item</Type>
    <DirectLink>Echoed Input Is Encoded</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <ul>
    <li>ASP.NET 4.0</li>
  </ul>
  <h1>What to Check For</h1>
  <p>Ensure that input is not echoed back to the user without first validating and/or encoding the data. Data which can be modified by a user must be treated as untrusted data.</p>
  <h1>Why</h1>
  <p>Echoing input directly back to the user makes your application susceptible to some code injection attacks, such as Cross-Site Scripting attacks. What constitutes malicious input varies widely depending on the system in question. On the web, it normally means some kind of JavaScript.</p>
  <h1>How To Check</h1>
  <p>Use the following steps to ensure that input which can be modified by a user is properly validated and encoded before being echoed back to the user:</p>
  <ol>
    <li>
      <p>
        <strong>Identify all sources of user input.</strong> At design time and again at the code review stage during development, determine all the possible tainted inputs to the application. Determine the intended characteristics of each input (length, format, etc.) and create validators for them. The following list includes some common input sources:</p>
      <ul>
        <li>Form Fields </li>
        <li>Query strings </li>
        <li>Databases and data access methods </li>
        <li>Cookie collection </li>
        <li>Session and application variables</li>
      </ul>
    </li>
    <li>
      <p>
        <strong>Identify all output that includes user input.</strong> At design time and again at the code review stage during development, trace all inputs to the system though and determine all of the places where they may be output. In each case, identify the context in which the output occurs.</p>
    </li>
    <li>
      <p>
        <strong>Ensure all user-controllable data is properly encoded before being sent as output.</strong> In each location where data is output, it must be encoded according to the context of the output.</p>
      <p>Do not rely on the <em>Server.HtmlEncode</em> function to protect your application against cross-site scripting attacks. Instead use the Microsoft Anti-Cross-Site Scripting Library.<a href="http://www.microsoft.com/downloads/en/details.aspx?FamilyID=f4cd231b-7e06-445b-bec7-343e5884e651"></a></p>
      <p>Do not attempt to use a character block list; when taking into account Unicode characters, etc., along with new emerging attack forms, block lists are guaranteed to be ineffective. </p>
      <p>Ensure that allow list encoding is performed so that all non-alphanumeric characters are encoded instead of certain specific characters like '&lt;', '&gt;, etc. </p>
      <p>Encoding must be selected appropriately based upon how the output is returned to the client- either as HTML content or in a URL. Verify the context in which the output is used and ensure it is properly encoded. </p>
      <p>If you are using the Microsoft Anti-Cross-Site Scripting Library, ensure that the <em>Microsoft.Security.Application.AntiXss.HtmlEncode</em> method is being used to encode HTML tags and their attributes. Similarly, in case your application constructs certain URLs from input data or data from a shared database, ensure that the <em>Microsoft.Security.Application.AntiXss.UrlEncode</em> method is being used to make them safe. Whether you are using <em>HttpUtility</em> encoding methods or the methods&amp;nbsp;from the Microsoft <em>AntiXss</em> library, the context matters. <em>HtmlEncode</em> cannot be used in all situations, for example for un-trusted data that is used to create URLs, <em>UrlEncode</em> should be used.</p>
      <p>Make sure that you encode data at the last possible opportunity before the data is returned to the client. If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems.</p>
      <p>If data is being written out into an HTML context, the following code will ensure that only known safe characters get through and help prevent a large majority of known XSS attacks. It will increase the size of the resulting HTML and does require more processing overhead, but it is definitely safe for use in most scenarios:</p>
      <pre>public static string HtmlEncode(string x){<br />  if (x == null)<br />  {<br />      return x;<br />  }<br />  return Regex.Replace(x, "^[a-zA-Z0-9]+$",<br />   new MatchEvaluator(WebUtility.EncodeMatch));<br />}</pre>
    </li>
  </ol>
  <h1>How To Fix</h1>
  <p>If you write output that includes user input or data from a shared database or a local file that you do not trust, encode it. Encoding the data ensures that it is treated as literal text and not as script. Use the following guidelines to encode user input:</p>
  <ol>
    <li>
      <p>
        <strong>Do not rely on HtmlEncode.</strong>&amp;nbsp;ASP.NET's Server.HtmlEncode function is often used to protect against cross-site scripting attacks. However, this function only encodes &lt;&gt;"&amp; characters. This is not sufficient to protect against all possible attacks.</p>
    </li>
    <li>
      <p>
        <strong>Encode all special characters.</strong> The safest solution is to encode all non-alphanumeric characters. Only this type of whitelist solution will catch all possible XSS attacks, regardless of context.&amp;nbsp; This&amp;nbsp;requires more overhead in terms of processing time and size of the resulting HTML, but it is the safest encoding mechanism for all HTML contexts:</p>
      <pre>public static string HtmlEncode(string x)<br />{<br />   if (x == null)<br />   {<br />   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;return x;<br />   }<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;return Regex.Replace(x, "^[a-zA-Z0-9]+$",<br />    new MatchEvaluator(WebUtility.EncodeMatch));<br />}</pre>
    </li>
    <li>
      <p />
      <strong>Use the Microsoft Anti-XSS Library.</strong> If you are using the Anti-Cross Site Scripting Library, you can use the <em>Microsoft.Security.Application.AntiXss.HtmlEncode</em> method.&amp;nbsp;Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use <em>Microsoft.Security.Application.AntiXss.UrlEncode</em> to make them safe. <p><b>Note: </b>Make sure that you encode data at the last possible opportunity before the data is returned to the client.&amp;nbsp;If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems.</p></li>
  </ol>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
  </Content>
</TeamMentor_Article>