<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1967646018" Content_Hash="1913090310">
  <Metadata>
    <Id>000aa3a4-7f62-4e3b-903a-7d4e703efc6b</Id>
    <Id_History>97be10d4-0360-4690-ae97-75fb7d4b5ce0,</Id_History>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>Dispose Methods Are Synchronized.</Title>
    <Category>Threading</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 3.5</Technology>
    <Type>Checklist Item</Type>
    <DirectLink>Dispose Methods Are Synchronized.</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>What to Check For</h1>
  <p>Check to ensure that the dispose methods are synchronized when&amp;nbsp;developing non-synchronized <b>Dispose</b> implementations in your application.</p>
  <p />
  <h1>How to Fix</h1>
  <p>If you develop non-synchronized <b>Dispose</b> implementations, the <b>Dispose</b> code could be called more than once on separate threads. The following code shows an example of this.</p>
  <div>
    <pre>void Dispose()&amp;#123;<br />  if (null &amp;#33;= theObject)<br />  &amp;#123;<br />    ReleaseResources(theObject);<br />    theObject = null;<br />  &amp;#125;<br />&amp;#125;</pre>
  </div>
  <p>In this example, it is possible for two threads to execute the code before the first thread has set <b>theObject</b> reference to <b>null</b>. Depending on the functionality provided by the <b>ReleaseResources</b> method, security vulnerabilities could occur.</p>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>