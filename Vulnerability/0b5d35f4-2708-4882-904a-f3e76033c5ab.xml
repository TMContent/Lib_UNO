<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1965511995" Content_Hash="1861320446">
  <Metadata>
    <Id>0b5d35f4-2708-4882-904a-f3e76033c5ab</Id>
    <Id_History>7940f2a8-907d-4356-a9ce-cbe909847531,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Account Lockout Vulnerability</Title>
    <Category>Authentication</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>Account Lockout Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
    <ul>
      <li>All applications which perform authentication</li>
    </ul>
  </p>
  <h1>Impact</h1>
  <p>Results in a Denial-of-Service for the users whose accounts have been locked out.</p>
  <h1>Underlying Fault</h1>
  <ul>
    <li>Weak implementation or configuration of the lockout policy. A weak policy could have any of the following characteristics: <ul><li>Invalid login attempt limit too low. </li><li>Low or no timeout between login attempts. </li><li>No incremental timeout between unsuccessful login attempts.</li></ul></li>
    <li>Valid username disclosure <ul><li>This could be a result of an Information Disclosure Vulnerability where an attacker can tell the distinction between a non-existent username and a bad password.</li></ul></li>
  </ul>
  <h1>Description</h1>
  <p>A lockout policy is used during authentication to prevent attackers from attempting a large number of passwords on a given account. However, this security mechanism can be used by an attacker to cause a denial of service condition. If the attacker can exhaust the invalid login attempt limit for a given account, that account may be locked out against the owner's wishes.</p>
  <p>This attack is especially powerful if the attacker can guess a large number of usernames or account numbers for a scripted attack on many users.</p>
  <h1>Countermeasures</h1>
  <ul>
    <li>
      <p>Configure the lockout policy to set the invalid login attempt limit to an acceptable limit, based on the security requirements of the application.</p>
    </li>
    <li>
      <p>Configure the lockout policy to increase the timeout after each failed login attempt. For example: require the user to wait two seconds after the first failed login attempt, four seconds after the second, eight seconds after the third, etc. This will slow a scriptâ€™s usefulness quickly, without hard locking the account and preventing a legitimate user from authenticating.</p>
    </li>
    <li>
      <p />Use CAPTCHA values after a failed login attempt. If a user fails to login, require them to authenticate themselves as not being a script by asking for a captcha response.<p /></li>
    <li>
      <p>Do not give away information which could lead to a distinction between a non-existent username and a bad password. To prevent this from happening, always display the same generic error message such as "Login information does not match or if you have tried to unsuccessfully login more than X times, then your account has been locked" during the following events:</p>
      <ul>
        <li>Invalid Username </li>
        <li>Invalid Password for valid username </li>
        <li>Valid username, valid password but account locked out</li>
      </ul>
    </li>
  </ul>
  <p>It's important that any login timeouts be on a per-account basis. Often, attempts are made to lock out source IPs if a single IP has too many login failures to prevent an attacker from attacking a large number of accounts in parallel. However, this does not take into account the case where a large number of users are legitimately coming from a single source IP. This case is common today with the current proliferation of NAT devices. Instead, taking steps to increase the required effort of the attacker is a better strategy. For example, require the client to hash the password a large number of times before submitting it. The hashed version is stored (safely encrypted) on the server, so the server requires no extra time to verify its correctness. However, the hashing process on the client is computationally expensive enough that an attacker will be unable to brute force multiple accounts on a single machine. Monitoring is also effective here; if an account stays in a locked state for too long and multiple failed login attempts recur to keep it that way, it should be brought to the attention of support personnel who can make a judgement call as to the appropriateness of more aggressive filtering, possibly after contacting the user.</p>
  <ul>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>