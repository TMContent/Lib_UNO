<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1908920621" Content_Hash="-1628684384">
  <Metadata>
    <Id>8f100e0f-3cc4-468d-9fa4-1acdc5d6eee2</Id>
    <Id_History>40bdba19-7454-45e5-95de-7947b722e42c,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Credential Brute Forcing Vulnerability</Title>
    <Category>Authentication</Category>
    <Phase>Design</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>Credential Brute Forcing Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
  </p>
  <ul>
    <li>Any application that uses authentication</li>
  </ul>
  <p />
  <h1>Impact</h1>
  <ul>
    <li>Credential compromise </li>
    <li>Credential disclosure </li>
    <li>Information disclosure</li>
  </ul>
  <h1>Underlying Fault</h1>
  <ul>
    <li>
      <strong>Weak encryption or hashing algorithm:</strong> Encryption and hashing algorithm design is very subtle and complicated, and even for algorithms which pass peer review, security changes over time. New attacks and improvements on existing attacks are found regularly, and available processing power is steadily increasing. </li>
    <li>
      <strong>Poorly designed security protocol:</strong> Security protocol design is just as complicated and error-prone as encryption protocol design. Protocols which appear safe may in fact be trivially broken by attackers. For example, the Wired Equivalent Privacy protocol (WEP), designed for and used in early wireless ethernet implementations, was later found to have serious desgin flaws. These flaws now allow WEP to be cracked in near real-time, despite the use of relatively strong cryptographic algorithms. In addition to the ongoing cost of intrusions, two new protocols, WPA and WPA2, have been required to attempt to fix the problem. </li>
    <li>
      <strong>Weak key or password:</strong> Even the best algorithm in the world cannot protect a user who selects a very weak password or key. Many paswordswill be easily guessed, unless controls against weak passwords are put into place. </li>
    <li>
      <strong>Lack of salt:</strong> If hashed values are stored without being rendered unique first, an attacker who gains access to the values will be able to perform a rainbow table attack. </li>
    <li>
      <strong>Failure to throttle credential checks:</strong> If an attacker can submit passwords to the system as frequently as they want, without the account being locked, an online attack becomes trivial, modulo the strength of the credentials being used. </li>
    <li>
      <strong>Unnecessary disclosure of encrypted data:</strong> While an application's encryption algorithms need to be implemented so that the system is still safe if an attacker does gain access to the data, allowing an attacker access to encrypted or hashed data unnecessarily makes it far easier for them to perform offline attacks.</li>
  </ul>
  <h1>Description</h1>
  <p>Brute forcing credentials requires the attacker to try to log in to the application using every username and password; however, there are a number of tools and techniques the attacker can use to quicken or automate the process. </p>
  <p>Brute force attacks are divided into two categories, online and offline brute force attacks. With online attacks, the attacker is actively submitting each attempted credential to the application under attack. Online attacks are generally very easy to detect, assuming a large number of attempts are needed, and can be largely prevented by throttling the rate at which new authentication requests can be made. Offline attacks are much more difficult to prevent; if an attacker can gain access to some resource, such as a piece of encrypted data, there is little that the system can do to prevent them from attempting to decrypt it. That said, many offline attacks require significantly more computation on the part of the attacker. </p>
  <p>The first line of defense, and the first place attackers start, is the strength of the password or passphrase in question. There has been a large amount of research into the kinds of weak passwords which users tend to choose. Consequently, attackers have access to large lists of potential passwords, sorted in rough probability order. This can make brute force attacks much easier by allowing them to try the most likely entries first before they make an exhaustive search. For systems where the element being attacked is a key, not a passphrase, cryptographically strong randomness is critical to ensuring key strength, as is understanding what, if any, properties about a key can significantly weaken it for the algorithm in question.</p>
  <p>The next avenue of attack involves statistical analysis. Many authentication systems are much weaker than they intially appear to be, especially systems involving cryptography. Depending on the protocol, many things can leak information about the nature of the encrypted traffic, even the timing of keystrokes in interactive protocols. Analysis of these components can dramatically reduce the amount of effort required to brute force the system credentials. A good example of this is the WEP system initially used to secure 802.11 networks; an attacker can break this protocol by only collecting a few thousand encrypted packets and doing a relatively trivial set of computations on them. This has dropped by many orders of magnitude from the initial estimates of its security.</p>
  <p>Finally, rainbow tables can be used against systems that improperly protect passwords with a one-way hashing function.</p>
  <h1>Countermeasures</h1>
  <ul>
    <li>
      <strong>Use strong encryption and hashing algorithms:</strong> Research the current best practice for hashing algorithms, as it does change. Currently, AES or AES256 are good choices for symmetric encryption, 2048 bit RSA is a good choice for public key encryption, and SHA or SHA256 are good choices for a hashing algorithm. The strength of the algorithm required should be matched to the security profile of the application. Under no circumstances should you attempt to design your own algorithm; only standard implementations of well known, tested, and appropriately chosen modern algorithms should be used. </li>
    <li>
      <strong>Use well known security protocols:</strong> Use only known and tested protocols, like SSL, IPSec, and Kerberos when securing authentication data. Do not design your own protocol, as it is likely to have flaws you're not aware of. </li>
    <li>
      <strong>Hash plaintext credentials with salt:</strong> Salting a hash adds a value which is different for each password, thus forcing the attacker to attack each instance directly. If possible, keep the salt from the attacker, as this will greatly increase the amount of work required, even if they have access to the hashed data. A credential can either be hashed with a unique stored value every time it is set, or a combination of known values can be used, like the username, a unique identifier for the system or application, and the time the password was set. While a unique value is somewhat more secure, the primary issue is ensuring that the same credential will have different has values if used by multiple users or by the same user repeatedly or across systems. </li>
    <li>
      <strong>Throttle login attempts:</strong> When protecting against online brute force attacks, do not allow the attacker to repeatedly attempt to log in.</li>
    <li>
      <strong>Do not disclose data uneccessarily:</strong> Ensure that only users who absolutely must have access to it can obtain encrypted or hashed authentication data.</li>
  </ul>
  <ul>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>