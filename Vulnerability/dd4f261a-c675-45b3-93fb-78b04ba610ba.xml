<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1311593400" Content_Hash="985290407">
  <Metadata>
    <Id>dd4f261a-c675-45b3-93fb-78b04ba610ba</Id>
    <Id_History>65060ea7-568c-46c9-af34-653cc81cecc3,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>AJAX Injection Vulnerability</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>AJAX Injection Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
  </p>
  <ul>
    <li>Web Applications that use AJAX</li>
  </ul>
  <p />
  <h1>Impact</h1>
  <ul>
    <li>
      <strong>Confidentiality:</strong> Since the code runs in the same domain as the trusted site any cookies or other confidential site data can be read by the malicious AJAX code.
</li>
    <li>
      <strong>JavaScript code injection:</strong> By using the <i>XMLHttpRequest </i>object attackers can download and install JavaScript code modules to be run on the local browser dynamically and send information from the computer without the victim's knowledge.</li>
  </ul>
  <h1>Underlying Fault</h1>
  <ul>
    <li>Failure to validate user input for script tags when that input can be echoed back into a web page.
</li>
    <li>Failure to encode user supplied input upon display of the data </li>
    <li>Trusting data retrieved from a shared data store.</li>
  </ul>
  <h1>Description</h1>
  <p>AJAX (Asynchronous Javascript and XML) technology allows web pages to dynamically update specific content behind the scenes without the need to refresh the whole page. The ability to continually update the content of an AJAX page is done by calling an XmlHttpRequest
 (XHR) object with JavaScript to send HTTP requests to web servers. These requests typically send data in the form of XML or JSON (JavaScript Object Notation).
</p>
  <p>AJAX injection is a type of 
Cross Site Scripting Attack (XSS) that leverages the XML or JSON format of the input to the client browser. JSON is particularly popular because it is easy to parse JSON objects by simply passing them to the <i>eval()</i> function. Unfortunately, the use of <i>eval()</i>
 makes the application equivalently easy to exploit. Cleverly format strings containing malicious JavaScript may be stored as content on servers with weak validation or sent directly to the client browser using a spoofing or man in the middle attack. This JavaScript
 is then parsed and execute by the client's browser without their knowledge. Ultimately, this attack may be used to steal session cookies, send email on behalf of the victim, or any other impact available to the XSS attack.</p>
  <h1>Example</h1>
  <p>Suppose you use an AJAX based web mail client. Because these are the days of Web 2.0, your mail client displays a list of your favorite contacts and lets you know their status. By default this status is set to "Online" or "Away," but a custom message may
 also be set by each contact that is reflect in your client. In order for this to work, the web page periodically updates this status list by requesting the list of contacts from the server. The server returns this information to the client as the following
 JSON object:</p>
  <p>
    <font face="'Courier New'">{<br />&amp;nbsp; &amp;nbsp;"numberOnline": "3",<br />&amp;nbsp; &amp;nbsp;"nameAndStatus": [<br />&amp;nbsp; &amp;nbsp;"Alice, Online",<br />&amp;nbsp; &amp;nbsp;"Bob, Online",<br />&amp;nbsp; &amp;nbsp;"Mallory, Away" ]<br />}</font>
  </p>
  <p>The following code shows the client JavaScript code which is called periodically to request the above object and update the DOM.</p>
  <p>
    <font face="'Courier New'">var contactStatusList;<br />var http_request = new XMLHttpRequest();<br />http_request.open("GET", url, true);<br />http_request.onreadystatechange = function (){<br />&amp;nbsp; &amp;nbsp;if (http_request.readyState == 4){<br /></font>
    <span style="font-family: 'Courier New'; ">&amp;nbsp; &amp;nbsp; &amp;nbsp; if (http_request.status == 200)</span>
    <span style="font-family: 'Courier New'; ">{<br /></span>
    <span style="font-family: 'Courier New'; ">&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;contactStatusList = eval("(" + http_request.responseText + ")");<br /></span>
    <span style="font-family: 'Courier New'; ">&amp;nbsp; &amp;nbsp; &amp;nbsp; }<br />&amp;nbsp; &amp;nbsp;http_request = null;<br />&amp;nbsp; &amp;nbsp;}<br />};<br /></span>
    <span style="font-family: 'Courier New'; ">http_request.send(null);</span>
  </p>
  <p>Now suppose that Mallory's status is set to a custom value. This may have been changed by Mallory herself or by a third party attacker. Either way, because the server providing the data to the mail client has poor validation, this status value is changed
 to include cleverly formatted malicious JavaScript. Suppose that instead of "Away" the value is changed to the following:</p>
  <p>
    <font face="'Courier New'">Away"});alert("Gotcha!");//</font>
  </p>
  <p>The first thing to notice is that the JSON object, which represents a the contact status list, is valid JavaScript. Because of this the <i>eval()</i> can be used to evaluate it. The above code completes the status object, inserts additional JavaScript, and comments
 out the rest of the line. When the code is passed as to the <i>eval() </i>function the additional JavaScript is run. Note that <i>alert("Gotcha!")</i> can be replaced with any malicious JavaScript and it will be run in the client's browser. Because the above code is an
 example, an alert message window will be displayed. In general, however, JavaScript could be downloaded and executed without the user's knowledge.</p>
  <h1>Countermeasures</h1>
  <p>
    <ul>
      <li>
        <strong>Constrain input:</strong> Use vigorous white-list style checking on any user input that may be reflected to a user's browser.</li>
      <li>
        <strong>HTML encode all user input on display:</strong> Use white-list style HTML encoding libraries to ensure all possibly malicious characters are encoded before being echoed back to the user, regardless of whether they're loaded as part of the original
 page load or through later <i>XMLHttpRequests</i>.</li>
    </ul>
  </p>
  <ul>
  </ul>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information on AJAX including common vulnerabilities that are associated with the technology, see&amp;nbsp;<a href="http://www.securityfocus.com/infocus/1868">http://www.securityfocus.com/infocus/1868</a></li>
  </ul>
  <ul>
    <li>For information on AJAX attacks and JavaScript Hijacking, see <a href="http://www.net-security.org/dl/articles/JavaScript_Hijacking.pdf">http://www.net-security.org/dl/articles/JavaScript_Hijacking.pdf</a></li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>