<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="319984566" Content_Hash="1985416068">
  <Metadata>
    <Id>a1d33f16-303b-42a5-a520-30b46b094df0</Id>
    <Id_History>d0a19518-2024-4dc0-9c51-eb42897d7ce2,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Integer Underflow Vulnerability</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>Integer Underflow Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
  </p>
  <ul>
    <li>Applications written in any language that does not perform automatic bounds checking</li>
  </ul>
  <p />
  <h1>Impact</h1>
  <ul>
    <li>Denial of Service: Most often the integer underflow will cause the application to crash, after a memory address dereference. </li>
    <li>Data Corruption: If the result is used in a file read or write operation the application may read or write from the wrong place in disk or memory, resulting in corruption. </li>
    <li>Remote Code Execution: In some cases remote code may be executed if the calculated result is used for memory management or indexing into a buffer. </li>
  </ul>
  <h1>Underlying Fault</h1>
  <ul>
    <li>Improper arithmetic </li>
    <li>Failure to validate integer input </li>
    <li>Integer calculations or assignments used to determine the size of a buffer </li>
    <li>Insufficient bounds checking and failure to consider sign </li>
    <li>Program logic that makes assumptions about the value of integers </li>
  </ul>
  <h1>Description</h1>
  <p>An integer underflow occurs when an integer is decremented under the limit that the data type can hold. The most common result of an integer underflow is that instead of the resulting value becoming smaller, the data structure "wraps" and becomes as large as the data type can hold.</p>
  <h1>Example</h1>
  <p>The following code segment shows a simple method, whose job is to strip the the last character and the null terminator from a string and return the result in a new character array.</p>
  <p>
    <font face="'Courier New'">char* stripString(char* sentence){<br />&amp;nbsp;if (!sentence) return 0;<br />&amp;nbsp;//need one less, since we're stripping last character<br />&amp;nbsp;unsigned int newLength = strlen(sentence) - 1;<br />&amp;nbsp;char* newBuffer = (char*) malloc (newLength);<br />&amp;nbsp;if (newBuffer != NULL){<br />&amp;nbsp;strncpy (newBuffer, sentence, newLength);<br />&amp;nbsp;}<br />&amp;nbsp;return newBuffer;<br />}</font>
  </p>
  <p>What happens when the string sentence is of zero-length? The <i>strlen()</i> call will return 0. Subtracting 1 from 0 when the data type is an unsigned integer will cause the value to wrap around to 4GB. So, in this code we would then attempt to allocate a 4 gigabyte buffer in the next line.</p>
  <p>With a little care the problem can be avoided. Consider the following fixed version of the code:</p>
  <p>
    <font face="'Courier New'">char* stripString(char* sentence){<br />&amp;nbsp;char* newBuffer = NULL;<br />&amp;nbsp;unsigned int strLength = 0;<br />&amp;nbsp;if (!sentence) return 0;<br />&amp;nbsp;strLength = strlen(sentence);<br />&amp;nbsp;if (strLength &gt; 0){<br />&amp;nbsp; &amp;nbsp;unsigned int newLength = strLength - 1;<br />&amp;nbsp; &amp;nbsp;newBuffer = (char*) malloc (newLength);<br />&amp;nbsp; &amp;nbsp;if (newBuffer != NULL){&amp;nbsp;strncpy (newBuffer, sentence, newLength);&amp;nbsp;}<br />&amp;nbsp;}<br />&amp;nbsp;return newBuffer;<br />}</font>
  </p>
  <h1>Countermeasures</h1>
  <ul>
    <li>
      <strong>Arithmetic checking: </strong>Always ensure that when subtracting two numbers the result is smaller than either operands. Take extra care when performing arithmetic operations with values near the maximum or minimum of the data type. </li>
    <li>
      <strong>Use a language or framework that does integer checking: </strong>Frameworks like .net and java can be set to automatically check for integer overflows and underflows. (e.g. <i>CheckForOverflowUnderflow </i>in C# and <i>RemoveIntegerChecks</i> in VB.NET.) </li>
    <li>
      <strong>Validate input:</strong> Always check the untrusted input for upper and lower limits and sign </li>
    <li>
      <strong>Verify Logic:</strong> Ensure that all integer logic will operate appropriately for the accepted limits, in all cases.</li>
  </ul>
  <ul>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>