<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-2108255891" Content_Hash="1935294931">
  <Metadata>
    <Id>286f3ffc-8fb1-482b-9cd1-4d11479b6132</Id>
    <Id_History>9b7f3ca2-5a7a-4435-8c22-ea34c12100ce,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Request Smuggling Vulnerability</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>Request Smuggling Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
    <ul>
      <li>Vulnerable web servers and proxies</li>
    </ul>
  </p>
  <h1>Impact</h1>
  <ul>
    <li>
      <strong>Cache Poisoning</strong>: An attacker may be able to ‘rewire’ a web server cache so that one page is served when another is requested. </li>
    <li>
      <strong>Malicious Requests</strong>: An attacker may be able to smuggle a malicious request through a packet inspector, web proxy server or firewall because of discrepancies in security rules between it and the web server </li>
    <li>
      <strong>Credential Hijacking</strong>: An attacker may be able to insert a request into the HTTP flow thereby manipulating the web server’s request/response sequencing which can allow the attacker to hijack a third party’s credentials.</li>
  </ul>
  <h1>Underlying Fault</h1>
  <ul>
    <li>Web Server, packet inspector, firewall, or web proxy server misconfiguration.</li>
  </ul>
  <h1>Description</h1>
  <p>HTTP Request Smuggling is a technique to take advantage of discrepancies in parsing when one or more HTTP devices are between the user and the web server. An attacker may be able to 'smuggle' malicious requests through a packet inspector, firewall or web proxy server. This technique may leave the web server vulnerable to various attacks such as web cache poisoning or allow the attacker to request protected files on the web server.</p>
  <h1>Example</h1>
  <p>This example describes the classic Request Smuggling attack in which an attacker can poison one page with the contents of another. In this example, the attacker combines one POST request and two GET requests into a single malformed HTTP request. The HTTP request has two <i>Content-Length</i> headers with conflicting values. Some servers, such as IIS and Apache simply reject such a request, but others attempt to ‘fix’ the error. Fortunately for the attacker, certain web servers and web proxies choose to pay attention to different sections of the malformed request. In this case let "<i>somewhere.com</i>" be the DNS name of the web server behind the proxy, and suppose that “<i>/poison.html</i>” is a static and cacheable HTML page on the web server.</p>
  <p>
    <font face="'Courier New'">1 POST http://somewhere.com/example.html HTTP/1.1\r\n<br />2 Host: somewhere.com\r\n<br />3 Connection: Keep-Alive\r\n<br />4 Content-Type: application/x-www-form-urlencoded\r\n<br />5 Content-Length: 0\r\n<br />6 Content-Length: 53\r\n<br />7 \r\n<br />8 GET /poison.html HTTP/1.1\r\n<br />9 Host: somewhere.com\r\n<br />10 Bla: <br />11 GET http://somewhere.com/index.html HTTP/1.1\r\n<br />12 Host: somewhere.com\r\n<br />13 Connection: Keep-Alive\r\n<br />14 \r\n</font>
  </p>
  <p>Note that line 10 is the only line that does not end in CRLF ("<i>\r\n</i>") and instead there is a space ("<i>Bla: </i>"). This request is sent to a web server via a proxy server. </p>
  <p>First this message is parsed by the proxy. When the proxy server parses the message it finds the POST request (lines 1-7) followed by the two conflicting <i>Content-Length</i>'s (lines 5 and 6). The proxy ignores the first header and believes the body is 53 bytes long (which is exactly the number of bytes used by lines 8-10 including CRLFs). The proxy then sees lines 11-14 and interprets them as a second request. </p>
  <p>Secondly the message is parsed by the web server. Although the web server receives the same message, when it sees the first <i>Content-Length</i> in line 5 it thinks that the body of the POST request is 0 bytes in length. Therefore it finds the second request in line 8 and interprets line 11 as the value of "<i>Bla: </i>" in line 10 because of the missing CRLF. </p>
  <p>In summary we have the following:</p>
  <p>
  </p>
  <p>
    <table>
      <tbody>
        <tr>
          <td>
          </td>
          <td>First request</td>
          <td>Second request</td>
        </tr>
        <tr>
          <td>Proxy</td>
          <td>POST, lines 1-10</td>
          <td>GET, lines 11-14</td>
        </tr>
        <tr>
          <td>Web Server</td>
          <td>POST, lines 1-7</td>
          <td>GET, lines 8-14</td>
        </tr>
      </tbody>
    </table>
  </p>
  <p />
  <p>At this point the web server responds to the GET in line 8 by sending the content of /poison.html to the proxy. The proxy, expecting a response to the GET request in line 11, mistakenly matches the reply from the webserver with contents from <i>/poison.html</i> to the page <i>/index.html</i>. Therefore, the contents of <i>/poison.html </i>are cached under the name <i>/index.html</i> on the proxy. Now any user who requests <i>http://somewhere.com/index.html </i>through the proxy will receive the contents of <i>http://somewhere.com/poison.html </i>instead.</p>
  <p>There are several options available to mitigate this attack but all of them have their downside. If possible, use a well tested web server such as Apache or IIS. Otherwise, you can turn off server-side page caching but this can lead to significant performance problems such as increased server load and latency. A final option is to use SSL communication for everything (HTTPS instead of HTTP), but this too has an associated performance overhead. </p>
  <h1>Countermeasures</h1>
  <ul>
    <li>Deploy a non-vulnerable web server - Web servers with a very strict HTTP parsing procedure may not be vulnerable to this attack. </li>
    <li>Change all pages to non-cacheable - This will force the proxy to retrieve the pages from the web server every time. Although from a security perspective this is better, the reality is that caching significantly improves the servers performance and reduces latency. This makes other countermeasures a better long term fix. </li>
    <li>Rewrite all HTTP requests - Install a module on a firewall or proxy server to rewrite each HTTP request on the fly to a known valid request type. </li>
    <li>Update your web server - Contact the web server vendor and check if there has been a patch released for a this type of vulnerability.</li>
  </ul>
  <ul>
  </ul>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information on HTTP Request Smuggling, see the <a href="http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">HTTP Request Smuggling Whitepaper</a>. </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>