<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1197955781" Content_Hash="-1712374677">
  <Metadata>
    <Id>7d0c4967-6af5-4930-b07b-ef5b1f9508fc</Id>
    <Id_History>20a03d9f-a6e3-444f-8bb6-a23730656195,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Response Splitting Vulnerability</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Vulnerability</Type>
    <DirectLink>Response Splitting Vulnerability</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To</h1>
  <p>
  </p>
  <ul>
    <li>Any web application</li>
  </ul>
  <p />
  <h1>Impact</h1>
  <ul>
    <li>
      <strong>Elevation of Privilege</strong>: The attacker can execute script in the context of your web application's domain. </li>
    <li>
      <strong>Access control</strong>: The attacker can steal authentication cookies or at the very least execute additional HTTP requests in the context of the currently logged in user. </li>
    <li>
      <strong>Defacement</strong>: The attacker can author pages with arbitrary content</li>
  </ul>
  <h1>Underlying Fault</h1>
  <ul>
    <li>HTTP Response headers populated with untrusted and unencoded input. The most common scenarios where this occurs are: <ul><li>HTTP Redirects (see example) </li><li>HTTP Cookie values supplied by the user. For instance, if your application allows the user to supply a name and then sets a cookie value using that name. It is important to note that cookies are set with the <i>Set-Cookie </i>HTTP Response header.</li></ul></li>
  </ul>
  <h1>Description</h1>
  <p>HTTP Response Splitting occurs when an attacker is able to inject arbitrary data into the headers of an HTTP response. In the presence of this vulnerability, the attacker can essentially force an HTTP response that contains HTML of the attacker's choosing. This is accomplished by simply terminating the header section of the response with the 0x0d 0x0a byte sequence and continuing with the malicious HTML. The resulting byte stream appears to the browser as two separate HTTP respsonses. The first contains the malicious HTML and is interpreted by the browser as being the legitimate response. The second contains the actual HTML that would have been returned by the server and is typically ignored.</p>
  <p>By allowing the attacker essentially complete control over an HTTP response that is rendered in the context of your domain, you open the door for a Phishing Attack or a Cross Site Scripting Attack.</p>
  <h1>Example</h1>
  <p>To demonstrate the response splitting attack consider the following situation. Suppose there is a web server located at the domain example.com that has two pages. The first page located at<i> /redirect.php</i> is used to redirect users to the second page at <i>/hello/world.html. </i></p>
  <p>Here is a simple <i>redirect.php</i></p>
  <p>
    <font face="'Courier New'">&lt;?php header ("Location: " . $_GET['site']); ?&gt;</font>
  </p>
  <p>Here is a simple <i>/hello/world.html</i></p>
  <p>
    <font face="'Courier New'">&lt;html&gt;hello world!&lt;/html&gt;</font>
  </p>
  <p>This link will redirect a user to the <i>hello/world.html</i> page:</p>
  <p>
    <font face="'Courier New'">http://example.com/redirect.php?site=hello/world.html</font>
  </p>
  <p>The following shows the headers that are sent between the client and the web server when this happens. First the client requests the page.</p>
  <p>
    <font face="'Courier New'">GET http://example.com:80/redirect.php?page=hello/world.html HTTP/1.1<br />Accept: */*Accept-Language: en-us<br />UA-CPU: x86<br />Accept-Encoding: gzip, deflate<br />User-Agent: Mozilla/4.0<br />Host: somewhere.com<br />Proxy-Connection: Keep-Alive</font>
  </p>
  <p>Then the server responds with a message telling the client that the page has moved and where to find it.</p>
  <p>
    <font face="'Courier New'">HTTP/1.1 302 Found<br />Server: Apache/1.3.33 (Unix) PHP/4.4.2X-Powered-By: PHP/4.4.2<br />Location: hello/world.html<br />X-Transfer-Encoding: chunked<br />Content-Type: text/htmlContent-length: 0</font>
  </p>
  <p>Hence the client application sends a request for the new page.</p>
  <p>
    <font face="'Courier New'">GET http://example.com:80/hello/world.html HTTP/1.1<br />Accept: */*<br />Accept-Language: en-us<br />UA-CPU: x86<br />Accept-Encoding: gzip, deflate<br />User-Agent: Mozilla/4.0<br />Host: 192.168.1.103<br />Proxy-Connection: Keep-Alive</font>
  </p>
  <p>Finally, the server responds with the page.</p>
  <p>
    <font face="'Courier New'">HTTP/1.1 200 OK<br />Server: Apache/1.3.33 (Unix) PHP/4.4.2<br />Accept-Ranges: bytes<br />Content-length: 28<br />Content-Type: text/html<br />&lt;html&gt;hello world!&lt;/html&gt;</font>
  </p>
  <p>There are a few things to note at this point. Each line in the above headers end with the carriage return line feed (CRLF) sequence <i>\r\n</i>. The next thing to note is that the URL-encoded CRLF sequence <i>%0d%0a</i> is equivalent to <i>\r\n</i> and can be used to embed <i>Header </i>information into a URL. The next part of this example demonstrates how this can be used to deliver an attacker controlled page to a users browser.</p>
  <p>Consider what happens when the following is injected into a URL:</p>
  <p>
    <font face="'Courier New'">%0d%0aContent-Type: text/html%0d%0aHTTP/1.1 200 OK%0d%0a Content-Type: text/html%0d%0a%0d%0a%3Chtml%3E Insert attacker payload here! %3C/html%3E</font>
  </p>
  <p>That is, the user is given the following link:</p>
  <p>
    <font face="'Courier New'">http://example.com/redirect.php?site=%0d%0aContent-Type: text/html%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type: text/html%0d%0a%0d%0a%3Chtml%3E Insert attacker payload here! %3C/html%3E</font>
  </p>
  <p>Now we take a look at what happens to the headers during the during the dialog when a client requests the above URL.</p>
  <p>
    <font face="'Courier New'">GET http://example.com/redirect.php?site=%0d%0aContent-Type: text/html%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type: text/html%0d%0a%0d%0a%3Chtml%3E Insert XSS payload here!%3C/html%3E HTTP/1.1<br />Accept: */*<br />Accept-Language: en-us<br />UA-CPU: x86<br />Accept-Encoding: gzip, deflate<br />User-Agent: Mozilla/4.0<br />Host: somewhere.com<br />Proxy-Connection: Keep-Alive<br />Pragma: no-cache</font>
  </p>
  <p>Basically two headers are being sent with a single request. Let's look at the above header in a more readable form:</p>
  <p>
    <font face="'Courier New'">GET http://example.com/redirect.php?site=Content-Type: text/html<br />HTTP/1.1 200 OK<br />Content-Type: text/html<br />&amp;nbsp;&lt;html&gt; Insert attacker payload here! &lt;/html&gt;<br />&amp;nbsp;HTTP/1.1<br />Accept: */*<br />Accept-Language: en-us<br />UA-CPU: x86<br />Accept-Encoding: gzip, deflate<br />User-Agent: Mozilla/4.0<br />Host: 192.168.1.103<br />Proxy-Connection: Keep-Alive<br />Pragma: no-cache</font>
  </p>
  <p>When the server receives this header it sends the following two responses which include the attackers payload.</p>
  <p>
    <font face="'Courier New'">HTTP/1.1 302 Found<br />Server: Apache/1.3.33 (Unix) PHP/4.4.2<br />Location:<br />Content-Type: text/html<br />HTTP/1.1 200 OK<br />Content-Type: text/html<br />&lt;html&gt; Insert attacker payload here! &lt;/html&gt;<br />Keep-Alive: timeout=15, max=100<br />Connection: Keep-Alive<br />Transfer-Encoding: chunked<br />Content-Type: text/html</font>
  </p>
  <h1>Countermeasures</h1>
  <p>Perform context sensitive scrubbing and encoding of untrusted input before it is used in an HTTP response header.</p>
  <ul>
    <li>Remove or encode user input before using it in an HTTP response header. </li>
    <li>In particular RFC 2616 states that CRs and LFs are not allowed in HTTP response headers, especially in the "<i>Location</i>" and "<i>Set-Cookie</i>" fields. Also remove sequences of CRs, LFs, SPs, and HTs and do not accept any input where LF is not followed by SP or HT.</li>
  </ul>
  <p>As with any blacklist strategy, this is a good start but will not catch everything. Web proxies, such as Sun Java System Web Proxy Server, cause problems with this approach because they often accept CR only as a valid end of line marker and hence can be exploited by using only CR.</p>
  <ul>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>