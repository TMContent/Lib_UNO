<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="569289126" Content_Hash="-1603495160">
  <Metadata>
    <Id>3bb80504-908f-488c-b535-3a3623d15954</Id>
    <Id_History>c72332f4-eabe-4879-ae4e-3b4f1999e9b6,</Id_History>
    <Library_Id>26bd1a04-beed-4a66-917d-b6ab0a7d634c</Library_Id>
    <Title>Consider Authorization Granularity</Title>
    <Category>Authorization</Category>
    <Phase>Design</Phase>
    <Technology> Any</Technology>
    <Type>Principle</Type>
    <DirectLink>Consider Authorization Granularity</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Definition</h1>
  <p>There are three common authorization models, each with varying degrees of granularity and scalability:</p>
  <ol>
    <li>
      <p>
        <b>The most granular approach relies on impersonation.</b> The impersonation model providing per end user authorization granularity. Resource access occurs using the security context of the caller. Windows ACLs on the secured resources (typically files or tables, or both) determine whether the caller is allowed to access the resource. If your application provides access primarily to user specific resources, this approach may be valid. It has the added advantage that operating system level auditing can be performed across the tiers of your application, because the original caller's security context flows at the operating system level and is used for resource access. However, the approach suffers from poor application scalability because effective connection pooling for database access is not possible. As a result, this approach is most frequently found in limited scale intranet-based applications.</p>
    </li>
    <li>
      <p>
        <b>The least granular but most scalable approach uses the application's process identity for resource access.</b> This model is referred to as the trusted subsystem or sometimes as the trusted server model. This approach supports database connection pooling but it means that the permissions granted to the application's identity in the database are common, irrespective of the identity of the original caller. The primary authorization is performed in the application's logical middle tier using roles, which group together users who share the same privileges in the application. Access to classes and methods is restricted based on the role membership of the caller. To support the retrieval of per user data, a common approach is to include an identity column in the database tables and use query parameters to restrict the retrieved data. For example, you may pass the original caller's identity to the database at the application (not operating system) level through stored procedure parameters, and write queries similar to the following:</p>
      <p>
        <font face="'Courier New'">SELECT field1, field2, field3<br />FROM Table1<br />WHERE {some search criteria}<br />AND UserName = @originalCallerUserName</font>
      </p>
    </li>
    <li>
      <p>
        <b>The third option is to use a limited set of identities for resource access based on the role membership of the caller.</b> The hybrid model uses multiple trusted service identities for downstream resource access. This is really a hybrid of the two models described earlier. Callers are mapped to roles in the application's logical middle tier, and access to classes and methods is restricted based on role membership. Downstream resource access is performed using a restricted set of identities determined by the current caller's role membership. The advantage of this approach is that permissions can be assigned to separate logins in the database, and connection pooling is still effective with multiple pools of connections. The downside is that creating multiple thread access tokens used to establish different security contexts for downstream resource access using Windows authentication is a privileged operation that requires privileged process accounts. This is counter to the principle of least privilege.</p>
    </li>
  </ol>]]></Data>
  </Content>
</TeamMentor_Article>