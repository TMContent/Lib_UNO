<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="503869411" Content_Hash="563435612">
  <Metadata>
    <Id>fb3c9e22-79a1-4e92-b976-a05b2d6de0cb</Id>
    <Id_History>919a3f10-0f8f-4c64-8dd9-82e390b6136b,</Id_History>
    <Library_Id>c037d0d2-0617-44f3-b846-21dc3d02c4f8</Library_Id>
    <Title>Consider How Your Application Will Flow Caller Identity Across Multiple Application Tiers</Title>
    <Category>Auditing and Logging</Category>
    <Phase>Design</Phase>
    <Technology> Any</Technology>
    <Type>Principle</Type>
    <DirectLink>Consider How Your Application Will Flow Caller Identity Across Multiple Application Tiers</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Description</h1>
  <p>You have two basic choices. You can flow the caller's identity at the operating system level using the Kerberos protocol delegation. This allows you to use operating system level auditing. The drawback with this approach is that it affects scalability because it means there can be no effective database connection pooling at the middle tier. Alternatively, you can flow the caller's identity at the application level and use trusted identities to access back-end resources. With this approach, you have to trust the middle tier and there is a potential repudiation risk. You should generate audit trails in the middle tier that can be correlated with back-end audit trails. For this, you must make sure that the server clocks are synchronized.</p>]]></Data>
  </Content>
</TeamMentor_Article>