<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1197519463" Content_Hash="-1468317685">
  <Metadata>
    <Id>3cd10f0e-151d-491e-99ff-07e6542ce497</Id>
    <Id_History>f4ebffed-4dbd-404c-abb1-c4719adc3a6d,</Id_History>
    <Library_Id>51eb81c3-1d23-4146-ba83-8a6bb9233c11</Library_Id>
    <Title>Check at the Gate</Title>
    <Category>Authorization</Category>
    <Phase>Design</Phase>
    <Technology> Any</Technology>
    <Type>Principle</Type>
    <DirectLink>Check at the Gate</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>CPP</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Description</h1>
  <p>You don't always need to flow a user's security context to the back end for authorization checks. Often, in a distributed system, this is not the best choice. Checking the client at the gate refers to authorizing the user at the first point of authentication (for example, within the Web application on the Web server), and determining which resources and operations (potentially provided by downstream services) the user should be allowed to access. </p>
  <p>If you design solid authentication and authorization strategies at the gate, you can circumvent the need to delegate the original caller's security context all the way through to your application's data tier.</p>]]></Data>
  </Content>
</TeamMentor_Article>