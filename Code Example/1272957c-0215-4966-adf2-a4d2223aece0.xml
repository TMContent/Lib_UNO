<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-60577338" Content_Hash="-508328895">
  <Metadata>
    <Id>1272957c-0215-4966-adf2-a4d2223aece0</Id>
    <Id_History>1fa805e9-5706-4f72-ba40-0edb5927096f,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Encrypting And Signing a Cookie for Use by an External Web Application</Title>
    <Category>Cookies</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>Code Example</Type>
    <DirectLink>Encrypting And Signing a Cookie for Use by an External Web Application</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, George Gal, Prashant Bansode</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 2.0 </li>
    <li>C#</li>
  </ul>
  <h1>Summary</h1>
  <p>The purpose of this code snippet is to illustrate how to securely distribute session data to an external trusted web application when there exists no common server-side session state. It includes topics such as generating an HMAC, inclusion of timestamp and the encryption of session data.</p>
  <h1>Objectives</h1>
  <ul>
    <li>Provide confidentiality of application cookies while in transit even over insecure communication channels, ensuring that they are not exposed to unauthorized users. </li>
    <li>Provide controls to mitigate session replay </li>
    <li>Provide controls to protect against information disclosure </li>
    <li>Provide controls which validate message integrity </li>
    <li>Protect against users' ability to tamper with cookie parameters which may impact the business logic, authentication or authorization context or overall data integrity through HMAC message signing </li>
    <li>Ensure the secure storage of a shared secret encryption key and HMAC signing key through use of the Data Protection API (DPAPI)</li>
  </ul>
  <h1>Scenarios</h1>
  <ul>
    <li>Web application needs to distribute some details within the session state to another application (e.g. Single sign-on, distributed web server architecture) </li>
    <li>Web applications are deployed within an infrastructure where it isn't feasible to share session state through a common server-side data store. </li>
    <li>A shared symmetric key and HMAC signing key are pre-established either out of band or via some other secure communication channel. </li>
    <li>Developers wish to avoid users from tampering with cookie parameters which may impact the business logic, authentication or authorization context or overall data integrity </li>
    <li>Securely distributing session state to an external application </li>
    <li>Providing confidentiality through cookie encryption </li>
    <li>Providing message integrity through HMAC code embedded in crypto blob </li>
    <li>Mitigate session replay through use of a session timeout mechanism </li>
    <li>A user must retrieve data distributed across multiple web servers, each which serve a different purpose, e.g. customer portal, reporting server, etc.</li>
  </ul>
  <h1>Solution Example </h1>
  <p>
    <strong>DPAPI Utility Class for retrieval and storage of keys</strong>
  </p>
  <pre>public class DPAPIUtil{<br />          private string registryKeyName = "ACMEWebApplication";<br />    private string registryEncValueName = "symmetrickey";<br />    private string registryHMACValueName = "hmackey";<br />    string fullRegistryKeyPath = "";<br />    public DPAPIUtil()<br />    {<br />           fullRegistryKeyPath = "HKEY_CURRENT_USER\\" + registryKeyName;<br />    }<br />    public void StoreHMACKey(byte[] val)<br />    {<br />        // Encrypt the HMAC signing key using the DPAPI ProtectedData class.<br />        // <br />        // We're using the CurrentUser scope instead of the MachineKey scope<br />        // so that other, potentially malicious applications cannot access<br />        // this key in the registry and decrypt.<br />        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />            DataProtectionScope.CurrentUser);<br />        // Create a security context for a new key that we will use to store our encrypted connection string.<br />        // The security context will restrict access to only our user.<br />        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />        RegistrySecurity security = new RegistrySecurity();<br />        RegistryAccessRule rule = new RegistryAccessRule(user,<br />                        RegistryRights.FullControl,<br />                        InheritanceFlags.ContainerInherit,<br />                        PropagationFlags.None,<br />                        AccessControlType.Allow);<br />        security.AddAccessRule(rule);<br />        // Actually create the new registry key and apply the security context we just came up with.<br />        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br />        // Write the encrypted string into the registry<br />        Registry.SetValue(fullRegistryKeyPath, registryHMACValueName, encryptedValBytes);<br />    }<br />        public void StoreSymmKey(byte[] val)<br />        {<br />                 // Encrypt the shared secret key using the DPAPI ProtectedData class.<br />                 //<br />                 // We're using the CurrentUser scope instead of the MachineKey scope    <br />                 // so that other, potentially malicious applications cannot access      <br />                 // this key in the registry and decrypt.<br />	        byte[] encryptedValBytes = ProtectedData.Protect(val, null,<br />	        DataProtectionScope.CurrentUser);<br />	        // Create a security context for a new key that we will use to store our shared secret key.<br />	        // The security context will restrict access to only our user.<br />	        string user = Environment.UserDomainName + "\\" + Environment.UserName;<br />	        RegistrySecurity security = new RegistrySecurity();<br />	        RegistryAccessRule rule = new RegistryAccessRule(user,<br />	                        RegistryRights.FullControl,<br />	                        InheritanceFlags.ContainerInherit,<br />	                        PropagationFlags.None,<br />	                        AccessControlType.Allow);<br />	        security.AddAccessRule(rule);<br />	        // Actually create the new registry key and apply the security context we just came up with.<br />	        Registry.CurrentUser.CreateSubKey(registryKeyName,<br />                        RegistryKeyPermissionCheck.ReadWriteSubTree,<br />                        security);<br />        		// Write the encrypted string into the registry<br />       		Registry.SetValue(fullRegistryKeyPath, registryEncValueName, encryptedValBytes);<br />   	}<br />    	public byte[] RetrieveHMACKey()<br />    	{<br />        		// Read the encrypted hmac signing key value from the registry<br />	         byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryHMACValueName, null) as byte[];<br />	        // Decrypt the encrypted bytes using DPAPI and return<br />       		 byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes, null,<br />	            DataProtectionScope.CurrentUser);<br />        return decryptedValBytes;<br />    }<br />    public byte[] RetrieveSymmKey()<br />    {<br />        // Read the encrypted symmetric key value from the registry<br />         byte[] encryptedValBytes = Registry.GetValue(fullRegistryKeyPath, registryEncValueName, null) as byte[];<br />        // Decrypt the encrypted bytes using DPAPI and return<br />        byte[] decryptedValBytes = ProtectedData.Unprotect(encryptedValBytes,null,<br />                DataProtectionScope.CurrentUser);<br />        return decryptedValBytes;<br />     }<br />}</pre>
  <p>
    <strong>Setting the encrypted and signed key in our cookie</strong>
  </p>
  <p>Establish the cookie value:</p>
  <pre>// Fetch some details to be passed to the remote web application<br />// e.g.:<br /> //<br />// string uid = UserInfo.GetUID(user);<br />string user = HttpContext.Current.User.Identity.Name;<br />bool adminRole = HttpContext.Current.User.IsInRole("admin");<br />// We create a concatenated cookie value containing all of the details/<br />/ that we would like to pass to the remote application.<br />// We also include a DateTime string, to help mitigate the risk of session replay<br />//cookieval = user + "|" + uid + "|" + adminRole.ToString() + "|" +<br />         DateTime.Now.ToBinary().ToString();<br />// Considerations to help protect against replay:<br />//<br />   //  - Minimize the interval during which cookies are accepted from the remote site<br />//  - Consider implementing a sequence ID, in which used sessions are marked accordingly<br />//    in the database<br />//  - Leverage a secure session transport (SSL)<br />//  - Use restrictive cookie settings (Path, HttpOnly, Secure mode, restrict the domain<br />//          + Consider implementing a sub domain to be used by applications in which<br />//            cookie sharing is necessary (e.g. .ourapps.microsoft.com)</pre>
  <p>Encrypt, sign and set cookie value:</p>
  <pre>// Instantiate our DPAPI helper functions<br />DPAPIUtil dputil = new DPAPIUtil();<br />// Retrieve the symmetric encryption key we wish to use<br />byte[] enckey = dputil.RetrieveSymmKey();<br />// Create the Crypto provider<br />Rijndael rij = Rijndael.Create();<br />// Load the DPAPI protected keyrij.Key = enckey;<br />// By default we have a random IV from when we made the call to Rijndael.<br />Create()<br />// We'll just prepend the IV to the encrypted value so the remote app can use our<br />// random IV. Alternatively it is possible to generate a new Random Initialization<br />// Vector manually by calling:<br />//   rij.GenerateIV();<br />MemoryStream ms = new MemoryStream();<br />CryptoStream ecs = new CryptoStream(ms, rij.CreateEncryptor(), CryptoStreamMode.Write);<br />// Create the HMAC for our plaintext value<br />// Now we need to validate the HMAC to ensure the message wasn't altered<br />// We use a distinctly seperate HMAC key to ensure that if the encryption key<br />// is compromised message integrity may still be guaranteed and protects us against<br />// parameter tampering.HMACSHA256 hmac = new HMACSHA256();<br />// Retrieve the HMAC key from the encrypted registry value using our DPAPI helperhmac.<br />Key = dputil.RetrieveHMACKey();<br />// Compute the HMAC on our plaintext cookie string<br />byte[] hmacValue = hmac.ComputeHash(UnicodeEncoding.ASCII.GetBytes(cookieval));<br />// Write the cookie contents to our cryptostreamecs.Write(UnicodeEncoding.ASCII.<br />GetBytes(cookieval), 0, cookieval.Length);<br />// Write the HMAC to our cryptostreamecs.Write(hmacValue, 0, hmacValue.Length);<br />ecs.Close();<br />// Create a byte array to store our encrypted value plus IV<br />byte[] encryptedValueWithIV = new byte[rij.IV.Length + ms.ToArray().Length];<br />// Prepend the IV to our encrypted value. The initialization vector need not be kept<br />// secret, in fact randomizing this value for each encryption<br />Array.Copy(rij.IV, encryptedValueWithIV, rij.IV.Length);<br />Array.Copy(ms.ToArray(), 0, encryptedValueWithIV, rij.IV.Length, ms.ToArray().Length);<br />string encryptedCookie = Convert.ToBase64String(encryptedValueWithIV);<br />HttpCookie chocolateChip = new HttpCookie("CookieJar", encryptedCookie);<br />// Ensure that proper secure cookie modes are set:<br />//<br />// Make cookies unavailable to client side scriptschocolateChip.<br />HttpOnly = true;<br />// Set the cookie transport mechanism to SSL only<br />chocolateChip.Secure = true;<br />// Ideally choose a more restrictive domain under which cookies are set<br />chocolateChip.Domain = ".ourapp.microsoft.com";<br />// Place some restrictions on which web paths can access our cookies<br />chocolateChip.Path = "/CookieExample/";<br />// Finally set the cookieResponse.Cookies.Add(chocolateChip);</pre>
  <h1>Problem Example</h1>
  <p>The following example demonstrates a poorly designed cookie sharing mechanism between two web applications where encryption and key signing are not used:</p>
  <p>Set the cookie value:</p>
  <pre>cookieval = user + "|" + uid + "|" + adminRole.ToString();<br />HttpCookie chocolateChip = new HttpCookie("CookieJar", cookieval);<br />// Ensure that proper secure cookie modes are set:<br />//<br />// Make cookies unavailable to client side scripts<br />chocolateChip.HttpOnly = true;<br />// Set the cookie transport mechanism to SSL only<br />chocolateChip.Secure = true;<br />// Ideally choose a more restrictive domain under which cookies are set<br />chocolateChip.Domain = ".ourapp.microsoft.com";<br />// Place some restrictions on which web paths can access our cookies<br />chocolateChip.Path = "/CookieExample/";<br />// Finally set the cookieResponse.Cookies.Add(chocolateChip);</pre>
  <p>Issues found in this example:</p>
  <ul>
    <li>Sensitive information is exposed within the cookie, potentially containing data which should never be exposed to a user </li>
    <li>Cookies are vulnerable to tampering by the user (and intermediaries in the event of a man-in-the-middle scenario) </li>
    <li>Cookies are vulnerable to replay </li>
    <li>If cookies are altered in transit there is no way to detect such a situation </li>
    <li>Any web application in the .ourapp.microsoft.com domain can access the cookie.</li>
  </ul>
  <p>Careful consideration should be given to other common coding mistakes not shown in the code above:</p>
  <ul>
    <li>Encryption using weak encryption keys (typically &lt;128, but dependent on encryption algorithms) </li>
    <li>Use of unproven or homegrown encryption algorithms </li>
    <li>Use of improper encryption types (e.g. stream cipher instead of block cipher) </li>
    <li>Use of improper encryption modes (lack of chaining blocks) <ul><li>Leads to easier cookie tampering even with encryption (replace or reorder blocks) </li><li>Leads to information disclosure of common values transmitted</li></ul></li>
    <li>Failure to choose random initialization vector (IV) <ul><li>Leads to information disclosure of common values transmitted</li></ul></li>
    <li>Failure to include HMAC <ul><li>Encrypted values may still be altered and go undetected</li></ul></li>
    <li>HMAC keys and encryption keys are equal <ul><li>Compromise of one key leads to total system compromise</li></ul></li>
    <li>Failure to include timestamp or session id <ul><li>Encrypted value may be replayed</li></ul></li>
  </ul>
  <h1>Test Case</h1>
  <p>The following classes must be included in any project making use of the sample code provided above:</p>
  <pre>using System;<br />using System.Collections.Generic;<br />using System.Security.Cryptography;<br />using System.Security.AccessControl;<br />using System.Text;<br />using Microsoft.Win32;</pre>
  <p>Browsing to the web application containing the solution code will establish an encrypted and signed cookie value.</p>
  <p>The following cookie value is set by the server with secure cookie options:</p>
  <pre>Set-Cookie: CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCjaK5a<br />upWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88cx35Jt<br />9sQIQmjAgCmecj6VhHwKfbrZ; domain=.ourapp.microsoft.com; path=/CookieExample/; secure; HttpOnly</pre>
  <p>Observe cookie values which contain the following properties:</p>
  <ul>
    <li>Change with each encryption operation (due to random IV, and appended timestamp value) </li>
    <li>Base64 decoding the "CookieJar" value yields and encrypted array of bytes</li>
  </ul>
  <h1>Expected Result</h1>
  <p>HTTP Response header:</p>
  <p>Set-Cookie: CookieJar=g2rzx1QZ94lAOyUxLGscUbQg1/yyG8Gy4NTCjaK5aupWwSXoAdyuNBer0sFZQiK9dx4kZnY0h8hd9xqEe6d8hMvGoJiGhlOh88cx35Jt9sQIQmjAgCmecj6VhHwKfbrZ; domain=.ourapp.microsoft.com; path=/CookieExample/; secure; HttpOnly</p>
  <h1>More Information</h1>
  <p>This implementation makes use of the DPAPI user key as opposed to the machine key. This means that the AES shared secret and HMAC signing key will only be accessible from programs that run within the same user context and will not be accessible by other applications running under different service accounts. </p>
  <p>This adds additional protection against a rogue application (such as a virus or trojan) compromising connection string data but could pose problems where sharing between mutliple applications running under different accounts is required. We recommend this approach whenever other programs will not need to access the same key material for encryption operations.</p>
  <p>Encryption of the message alone is not sufficient to protect against message tampering, as such we've included the use of an HMAC (or message integrity check, which relies on a shared secret key). The HMAC is generated by using a seperate shared secret and relies on a strong one-way hashing algorithm to generate a unique hash for the given message.</p>
  <p>Even with cookie encryption and signing, a user who intercepts these cookies may replay them to the server unless there is a value contained within the message designating the sequence number of the message.</p>
  <p>The symmetric shared key and HMAC signing key must be securely stored in order to maintain the confidentiality of data encrypted using these keys. In this example, we make use of the DPAPI in order to transparently stored the shared key pair encrypted with in the registry. </p>
  <p>The details of AES and HMAC message signing are beyond the scope of this article. However the following topics are discussed in the articles in Additional Resources:</p>
  <ul>
    <li>Encrypt a string via a block cipher (using AES) </li>
    <li>Generate a Message Authentication Code (HMAC)</li>
  </ul>
  <h1>Additional Resources</h1>
  <ul>
    <li>HMAC definition: <a href="http://en.wikipedia.org/wiki/HMAC">http://en.wikipedia.org/wiki/HMAC</a></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>