<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>00000000-0000-0000-0000-0000008149ca</Id>
    <Id_History>00000000-0000-0000-0000-0000008149ca,9a3d1ab0-10e9-477f-8262-3ed6ea5a97d0,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>Validate All Input</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology>Android</Technology>
    <Type>Guideline</Type>
    <DirectLink>Validate All Input</DirectLink>
    <Tag />
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="markdown">
    <Data><![CDATA[## What to Do ##

Validate all user input using whitelist/positive input validation. Whitelist input validation allows only input that is explicitly defined as valid, as opposed to blacklist input validation, which filters out known bad input.


## Why ##

Properly implemented input validation mitigates many types of injection vulnerabilities.


## How ##

To validate all user input using whitelist input validation:

1. **Identify all entry points for user input.** Make a list of all possible sources of user input in your application.

2. **Identify all types of input accepted by the application.** For each source of user input on the list, define valid characters, length, format, and range (for numerical values).

3. **Define an input validation subsystem.** Define a set of validator functions that should be used to validate each type of input handled by the application. 

4. **Validate characters.** Restrict the acceptable range of characters in text input using regular expressions.

5. **Validate length.** Check that the length of the user input is valid.

6. **Validate format.** If the input type has a specific pattern, such as a date or a phone number, use regular expressions to make sure user input matches the input type specified by the application. 

7. **Validate range.** Restrict the acceptable range of numerical input by comparing the input to the maximum and minimum acceptable values.

8. **(Optional) Reject and respond to known bad input.** This step does not add much actual security, but it provides some defense in depth. The input validation subsystem may check for known attack strings and respond to these likely attacks by alerting the user. The application may respond to invalid input by rejecting invalid input, logging invalid input, and/or taking evasive action.

9. **(Context-sensitive) Encode input.** If the input is going to be displayed back through a web browser, consider encoding it to prevent Cross-Site Scripting attacks.


## Additional Resources ##

* For more information on input validation, see [https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)]]></Data>
  </Content>
</TeamMentor_Article>