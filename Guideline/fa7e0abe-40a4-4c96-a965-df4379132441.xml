<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="161402070" Content_Hash="-864052134">
  <Metadata>
    <Id>fa7e0abe-40a4-4c96-a965-df4379132441</Id>
    <Id_History>8ce6a31c-076b-4c6a-840c-79c08250c994,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Do Not Store Secrets in Inappropriate Places</Title>
    <Category>Sensitive Data</Category>
    <Phase>Design</Phase>
    <Technology>Web Application</Technology>
    <Type>Guideline</Type>
    <DirectLink>Do Not Store Secrets in Inappropriate Places</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>
      <div>Web Application</div>
    </li>
  </ul>
  <h1>What to Do</h1>
  <p>Are there secrets or critical intellectual property embedded in the code? Review the design to make sure that it is absolutely necessary to store the secret. Ensure that the code eliminate secrets from memory.</p>
  <h1>Why</h1>
  <p>If the secrets are stored in code which is on the server, an attacker may be able to download it. Secrets are visible in binary assemblies. Managed code is easy to decompile. It is possible to recover code from the final executable that is very similar to the original code. Any sensitive intellectual property or hard coded secrets can be stolen with ease. An obfuscator can make this type of theft more difficult, but cannot entirely prevent it. Another common problem is to use hidden form fields thinking this information will not be visible to the user. </p>
  <h1>When</h1>This is important guideline and should be followed all the time.&amp;nbsp; <h1>How</h1><p>Do not hard code secrets in code. Even if the source code is not exposed on the Web server, it is possible to extract string constants from compiled executable files. A configuration vulnerability may allow an attacker to retrieve the executable.</p><p>Avoid storing secrets such as database connection strings, passwords, and keys in plaintext. Use encryption and store encrypted strings.</p><p>Avoid the LSA because your application requires administration privileges to access it. This violates the core security principle of running with least privilege. Also, the LSA can store secrets in only a restricted number of slots. A better approach is to use DPAPI, available on Microsoft WindowsÂ®&amp;nbsp;2000 and later operating systems.</p><p>To store secrets such as database connection strings or service account credentials, use DPAPI. The main advantage to using DPAPI is that the platform system manages the encryption/decryption key and it is not an issue for the application. The key is either tied to a Windows user account or to a specific computer, depending on flags passed to the DPAPI functions.</p><p>DPAPI is best suited for encrypting information that can be manually recreated when the master keys are lost, for example, because a damaged server requires an operating system re-install. Data that cannot be recovered because you do not know the plaintext value, for example, customer credit card details, require an alternate approach that uses traditional symmetric key-based cryptography such as the use of AES.</p><br /><hr /><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>