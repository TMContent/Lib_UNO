<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1157502061" Content_Hash="969949998">
  <Metadata>
    <Id>9557bf26-cc8e-4bcc-8588-3e07d127b4fc</Id>
    <Id_History>9557bf26-cc8e-4bcc-8588-3e07d127b4fc,899fbc8f-9ec2-40ea-8032-054eac5ecf31,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>Use Structured Exception Handling</Title>
    <Category>Error and Exception Management</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>Guideline</Type>
    <DirectLink>Use Structured Exception Handling</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>What to Do</h1>
  <p>Use structured exception handling to catch exception conditions. Do not rely on function return codes to perform error handling.</p>
  <h1>Why</h1>
  <p>The classic approach for error handling was to use the codes that functions return in order to evaluate the success or failure of certain operations. However, with a nontrivial function call hierarchy, this approach clutters the code significantly. Every function must check the return code of every function call it makes and take care of errors. In most cases, the function will merely pass any errors back up to its caller. Complex ASP.NET applications may have several hundred internal functions and a call hierarchy many levels deep, so this approach is difficult to maintain. Using structured exception handling simplifies and de-clutters the application code, which improves robustness and avoids leaving the application in an inconsistent state. It provides the application more information regarding the encountered error and minimizes the risk of information disclosure. </p>
  <h1>When</h1>
  <p>Use structured exceptions whenever erroneous or exceptional conditions can be raised in a given program. It is reasonable to expect that if a function is capable of raising an exception, it eventually will. All exceptions must be handled&amp;#33;</p>
  <h1>How</h1>
  <p>Exception handlers should be as specific and relevant as possible. When multiple exceptions are anticipated, the try/catch block should have multiple catch clauses to satisfy each type of exception. Consider the following strategies when constructing your application's exception handlers:</p>
  <ul>
    <li>
      <p>
        <strong>Location of handlers.</strong> The location of your exception handlers is very important if your code is to recover properly without damaging other parts of your application. Placing your handler closer to the exception source allows your application to have better information of the current operation and properly recover the appropriate resources.</p>
      <li>
        <p>
          <strong>Purpose of handlers.</strong> Carefully choose the purpose of your exception handlers. Although developers commonly use exception handlers to wrap up after their code has failed, exception handlers provide a mechanism for recovering allocated resources and safely disposing them. Keep track of the associated resources and handle them accordingly when an exception is thrown. For instance, if your code throws a SQLException, verify that your application's database components are back into a safe state. If your code handles sensitive data, ensure that all instances of sensitive data inside your block of code have been safely disposed of.</p>
        <li>
          <p>
            <strong>Exception data.</strong> Because it is a common practice to log exceptions to help troubleshoot a problem, make sure that your exceptions do not contain sensitive data that could compromise your application's users or assets when logged. Consult <a href="/article/e46483a2-7f7e-4753-aaeb-e330ed9aef02">Do Not Log Sensitive Information</a> for additional information.</p>
          <li>
            <p>
              <strong>Type of handlers.</strong> Always catch the type of exceptions that best fit your application's efforts to recover into its normal state of operation upon encountering an error. If a block in your application is expected to throw multiple types of exceptions, make sure that each exception type is handled accordingly. For example, if a SQLException and SecurityException are expected, then there should be an exception handler for each type of exception: </p>
            <pre>try<br />&amp;#123;<br />    // Execute SQL statement<br />&amp;#125;<br />catch (SqlException sqlEx)<br />&amp;#123;<br />    // Add appropriate exception handling<br />    // E.g.: Check database connectivity and restore lost connections<br />     // Log the event<br />&amp;#125;<br />catch (SecurityException secEx)<br />&amp;#123;<br />    // Add appropriate exception handling<br />    // E.g.: Notify the user of insufficient privileges <br />    // Log the event<br />&amp;#125;</pre>
            <p>
              <strong>Note:</strong> The example above assumes that there is a global exception handling mechanism placed at the root of the code execution. See <a href="/article/33a894ce-2061-4741-be92-1d063c9cf057">Use a Global Exception Handler for Unhandled Exceptions</a> guideline for more details. </p>
          </li>
        </li>
      </li>
    </li>
  </ul>
  <h1>Problem Example</h1>
  <p>The following code shows a component that queries the application's backend database. Because the developers have assigned a single exception of type System.Exception to the entire try/catch block, the application cannot respond adequately when an exception is thrown.</p>
  <pre>try<br />&amp;#123;<br />    ...<br />    command = new SqlCommand(query, connection);<br />    ...<br />    result = command.ExecuteReader();<br />&amp;#125;<br />catch (Exception e)<br />&amp;#123;<br />    // Add appropriate exception handling<br />    // E.g.: Notify the user that the request cannot be completed<br />    // Log the event<br />&amp;#125;</pre>
  <h1>Solution Example</h1>
  <p>The following code shows a component that queries the application's backend database. The developers have assigned a catch block to each of the appropriate types of exceptions; therefore allowing the application to handle all thrown exceptions accordingly.</p>
  <pre>try<br />&amp;#123;<br />    ...     command = new SqlCommand(query, connection);<br />     ...     result = command.ExecuteReader();<br />&amp;#125;<br />catch (SqlException se)<br />&amp;#123;    // Add appropriate exception handling<br />     // E.g.: Check database connectivity and restore lost connections<br />     // Log the event<br />&amp;#125;<br />catch (Exception e)<br />&amp;#123;    // Add appropriate exception handling<br />     //E.g.: Notify the user that the request cannot be completed<br />     // Log the event<br />&amp;#125;</pre>
  <h1>Additional Resources</h1>
  <ul>
    <li>To learn more about the System.Exception class and the exception hierarchy in ASP.NET, see the documentation for <a href="http://msdn2.microsoft.com/en-us/library/system.exception(vs.80).aspx">Exception Class</a> in MSDN. </li>
  </ul>
  <h1>Related Items</h1>
  <ul>
    <li>
      <a href="/article/33a894ce-2061-4741-be92-1d063c9cf057">Guideline: Use a Global Exception Handler for Unhandled Exceptions</a>
      <li>
        <a href="/article/5b6c71b0-cb89-4435-b30e-2fd76347078e">Guideline: Do Not Propagate Exceptions While Impersonating</a>
        <li>
          <a href="/article/74be8616-ad22-4d1d-a7fc-8ff3d145fc61">Guideline: Do Not Disclose Exception Details to the Client</a>
          <li>
            <a href="/article/dc172f55-185d-4c34-996a-1e368662f3f7">Attack: Exception Information Disclosure Attack</a>
            <li>
              <a href="/article/bc10306c-f37c-4780-a096-847070ae67da">Checklist Item: Structured Exception Handling is Used</a>
            </li>
          </li>
        </li>
      </li>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>