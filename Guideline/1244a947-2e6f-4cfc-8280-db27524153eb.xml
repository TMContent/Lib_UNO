<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1726101241" Content_Hash="-2095392702">
  <Metadata>
    <Id>1244a947-2e6f-4cfc-8280-db27524153eb</Id>
    <Id_History>a1772b90-a0ec-4d98-b9a3-aa2b87f56c86,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Encrypt Sensitive Data in the Database</Title>
    <Category>Sensitive Data</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Encrypt Sensitive Data in the Database</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Andy Wigley, Kishore Gopalan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 2.0 </li>
  </ul>
  <h1>What to Do</h1>
  <p>Encrypt any&amp;nbsp;sensitive data that you store in a database. </p>
  <h1>Why</h1>
  <p>Encrypted data in SQL Server is a final line of defense.&amp;nbsp; Even if an attacker successfully gains access to a database, she must still decrypt the data.&amp;nbsp; Although key management and encryption overhead add to the cost and complexity of an application, at-rest data encryption can greatly increase application security.&amp;nbsp; Furthermore, it is or will be required for some classes of personally identifiable information, such as credit card records, and can reduce corporate liability even when not required. </p>
  <h1>When</h1>
  <p>You should consider the level of protection required, and use encryption only when protecting a field is worth the cost incurred.&amp;nbsp; Good candidates for encryption include credit cards numbers, passwords and similar authentication tokens which cannot be stored as salted hashes, medical records, government ID numbers, and other highly sensitive and/or personally identifiable information. </p>
  <h1>How</h1>
  <h2>1. Set Up the Database Master Key</h2>
  <p>The Service Master Key, a symmetric key that directly or indirectly encrypts all keys on the server, is created automatically when you install SQL Server.&amp;nbsp; If it is compromised, an attacker can eventually crack every key in every database.&amp;nbsp; For that reason, it's protected by the Data Protection API (DPAPI) in Windows.&amp;nbsp; Within the scope of a database, the database master key is the root encryption object for all keys, certificates, and data in the database, and you must create a database master key (with a user-supplied password) before using it: </p>
  <pre>CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'WeZ#6hv*XHq#akAEaqcr7%CUP3aQ'</pre>
  <p>The resulting key is encrypted with triple DES and stored twice.&amp;nbsp; One storage location is in the <b>sys.symmetric_keys</b> database table, encrypted by the supplied password, and the second is the <b>sys.databases</b> table in the master database, encrypted using the Service Master Key.&amp;nbsp; Note that moving databases with keys set between SQL server installations takes extra work, as the Service Master Keys will be different. </p>
  <h2>2. Create Sub-keys for Application Use</h2>
  <p>Once the database master key exists, you can use it to create any of three types of keys, depending on the encryption you need:</p>
  <ul>
    <li>Asymmetric keys are used for public key cryptography with a public and private key pair. </li>
    <li>Symmetric keys are used for shared secrets where the same key both encrypts and decrypts data. </li>
    <li>Certificates are essentially wrappers for a public key. </li>
  </ul>
  <p>You can have SQL Server create a certificate for its own use or import a certificate created by any trusted certificate authority, such as Microsoft Certificate Server or VeriSign.&amp;nbsp; Options include setting a password to use to encrypt the private key or letting SQL Server use the database master key, as well as setting the creation and expiration dates. </p>
  <h2>3. Encrypt Data in the Database</h2>
  <p>Once the certificate exists, you can encrypt data using one of the new T-SQL functions that supports encryption, <b>EncryptByCert</b>.&amp;nbsp; Imagine that you have a table called Customer defined like this:&amp;nbsp;&amp;nbsp;</p>
  <pre>CREATE TABLE Customer (CustId int,     <br />			name nvarchar(30),     <br />			City varchar(20),     <br />			CreditCardType varbinary(300),    <br />			CreditCardNumber varbinary(300),     <br />			Notes varbinary(4000)<br />		    )GO</pre>
  <p>Encrypted data is binary, so the table uses varbinary fields to hold it.&amp;nbsp; Because the encrypted data includes the digital certificate, the field lengths must be rather large, even to hold simple strings like "Visa" and a credit card number.&amp;nbsp; Here is how you can insert a row of data into this table: </p>
  <pre>INSERT INTO Customer VALUES (1,<br />			 'Don Kiely', <br />			 'Fairbanks',    <br />			 EncryptByCert(Cert_ID('User1Certificate'), 'Visa'),    <br />			 EncryptByCert(Cert_ID('User1Certificate'), '1234-5678-8765-4321'),    <br />                             EncryptByCert(Cert_ID('User1Certificate'),         <br />			'This customer is a real flake. Don''t trust him!'))</pre>
  <p>
    <b>EncryptByCert</b> takes two parameters, the certificate ID, which you can obtain with the <b>Cert_ID</b> function, the name you gave the certificate, and the data to be encrypted. </p>
  <h2>4. Decrypt Data from the Database</h2>
  <p>To decrypt the data as part of a SELECT statement, use DecryptByCert as shown here: </p>
  <pre>SELECT CustID, Name, City,<br />	CONVERT(VARCHAR, DecryptByCert(Cert_ID('User1Certificate'),CreditCardType)) AS CardType,    <br />		CONVERT(VARCHAR, DecryptByCert(Cert_ID('User1Certificate'), )) AS CardNumber,    <br />			CONVERT(VARCHAR, DecryptByCert(Cert_ID('User1Certificate'),Notes)) AS NotesFROM Customer</pre>
  <p>There's a lot more that can be done with encryption in the database;&amp;nbsp;these are just the basics. </p>
  <h1>Problem Example</h1>
  <p>An e-commerce site uses the following definition for their customer table in the database:&amp;nbsp; </p>
  <pre>CREATE TABLE Customer (CustId int,     <br />			name nvarchar(30),     <br />			City varchar(20),     <br />			CreditCardType varchar(10),    <br />			CreditCardNumber varchar(19),    <br />			Notes varchar(4000)<br />		    )GO</pre>
  <p>And this query to insert new customers:</p>
  <pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks', 'Visa',     <br />				'1234-5678-8765-4321', <br />				'This customer is a real flake. Don''t trust him!')</pre>
  <p />When the site suffers a security breach via a SQL injection, their entire customer database, including all the credit card numbers, is lost to the attacker.&lt;/&gt; <h1>Solution Example</h1><p>An e-commerce site has configured their database server with a database master key and created a user certificate, and uses the following definition for their customer table in the database:</p><pre>CREATE TABLE Customer (CustId int,     <br />			name nvarchar(30),     <br />			City varchar(20),     <br />			CreditCardType varbinary(300),    <br />			CreditCardNumber varbinary(300),     <br />			Notes varbinary(4000)<br />		     )GO</pre><p>And this query to insert new customers:</p><pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks',    <br />				EncryptByCert(Cert_ID('User1Certificate'), 'Visa'),    <br />				EncryptByCert(Cert_ID('User1Certificate'), '1234-5678-8765-4321'),    <br />				EncryptByCert(Cert_ID('User1Certificate'),         <br />			'This customer is a real flake. Don''t trust him!'))</pre><p>When the site suffers a security breach via&amp;nbsp;a SQL injection, They lose only the names and addresses of their customers to the attacker; the credit card details and notes are encrypted and unreadable to the attacker.</p><p /><hr /><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>