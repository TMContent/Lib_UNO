<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-273756848" Content_Hash="-363900580">
  <Metadata>
    <Id>6c6f0d93-0d5b-4aa4-97b0-9e69535b3345</Id>
    <Id_History>6c6f0d93-0d5b-4aa4-97b0-9e69535b3345,69eafcf3-821e-42de-b2fa-7530ee3aa691,</Id_History>
    <Library_Id>51eb81c3-1d23-4146-ba83-8a6bb9233c11</Library_Id>
    <Title>Protect Against Integer Overflows</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology>C++</Technology>
    <Type>Guideline</Type>
    <DirectLink>Protect Against Integer Overflows</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>What to Do</h1>
  <p>Be careful with numeric calculations, such that the calculation never exceeds the maximum or minimum value for the data type of any variables used in the calculation.</p>
  <h1>Why</h1>
  <p>If a calculation causes a data value to be larger or smaller than its data type allows, the value will wrap and become much larger or smaller than expected. Make sure that any location where a user can give input that results in a calculation does not cause an underflow or overflow condition. </p>
  <h1>When</h1>
  <p>Any location in code in which input from a user, network communication, database, 3rd party component or other source of external input may impact a numeric calcuation.</p>
  <h1>How</h1>
  <p>When performing numerical calculations ensure that the value of the calculation may not ever exceed the maximum or minimum value for the data type of any variable used in the calculation. If the calculation may exceed the maximum or minumum you can change the data type to one with&amp;nbsp;a larger maximum or you can change operator precedence or other details of the calculation to make sure the maximum is not exceeded.</p>
  <p>It is also possible for an integer overflow to occur if you are casting from a larger data type to a smaller data type. In this case check to ensure the variable value is within the range of the target data type before performing the cast.</p>
  <h1>Problem Example</h1>
  <p>The application should not contain code similar to the following example. </p>
  <pre>int&amp;#91;&amp;#93; filter(uint len, int&amp;#91;&amp;#93; numbers)<br />&amp;#123;<br />&amp;nbsp;uint newLen =&amp;nbsp; len &amp;#42; 3/4;<br />&amp;nbsp;int&amp;#91;&amp;#93; buf = new int&amp;#91;newLen&amp;#93;;<br />&amp;nbsp;int j = 0;<br />&amp;nbsp;for(int i = 0; i &lt; len; i&amp;#43;&amp;#43;)<br />&amp;nbsp;&amp;#123;<br />&amp;nbsp;&amp;nbsp; if (i &amp;#37; 4 &amp;#33;= 0)<br />&amp;nbsp;&amp;nbsp; buf&amp;#91;j&amp;#43;&amp;#43;&amp;#93; = numbers&amp;#91;i&amp;#93;;<br />&amp;nbsp;&amp;#125;<br />&amp;nbsp;return buf;<br />&amp;#125;</pre>
  <p>The problem in this example is that, in calculating the value for <b>len</b>, the code first computes <b>len</b> &amp;#42; 3 and then divides by 4. When <b>len</b> is large enough (about 1.4 billion), <b>len</b> &amp;#42; 3 overflows and <b>newLen</b> is assigned a value that is too small. The result is out of range array access in the <b>buf</b> array. </p>
  <h1>Solution Example</h1>
  <p>In this example the operator precedence is changed so that len is multiplied by (3/4) instead of 3 and then divided by 4.</p>
  <pre>int&amp;#91;&amp;#93; filter(uint len, int&amp;#91;&amp;#93; numbers)<br />&amp;#123;<br />&amp;nbsp;uint newLen =&amp;nbsp; len &amp;#42; (3/4);<br />&amp;nbsp;int&amp;#91;&amp;#93; buf = new int&amp;#91;newLen&amp;#93;;<br />&amp;nbsp;int j = 0;<br />&amp;nbsp;for(int i = 0; i &lt; len; i&amp;#43;&amp;#43;)<br />&amp;nbsp;&amp;#123;<br />&amp;nbsp;&amp;nbsp; if (i &amp;#37; 4 &amp;#33;= 0)<br />&amp;nbsp;&amp;nbsp; buf&amp;#91;j&amp;#43;&amp;#43;&amp;#93; = numbers&amp;#91;i&amp;#93;;<br />&amp;nbsp;&amp;#125;<br />&amp;nbsp;return buf;<br />&amp;#125;</pre>]]></Data>
  </Content>
</TeamMentor_Article>