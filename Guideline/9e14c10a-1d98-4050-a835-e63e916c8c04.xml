<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-2000793775" Content_Hash="696476245">
  <Metadata>
    <Id>9e14c10a-1d98-4050-a835-e63e916c8c04</Id>
    <Id_History>c2556694-4e7b-41ad-993c-7e699529c1c5,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Do Not Depend on Strong Name Identity Permissions in Full Trust Scenarios</Title>
    <Category>Strong Naming and Signing </Category>
    <Phase>Design</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Do Not Depend on Strong Name Identity Permissions in Full Trust Scenarios</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Srinath Vasireddy, Ashish Babbar, Rico Mariani, and Alex Mackman</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>What to Do</h1>
  <p>If you protect your code with a link demand for a <b>StrongNameIdentityPermission</b> to restrict the code that can call your code, be aware that this only works for partial trust callers. The link demand will always succeed for full trust callers, regardless of the strong name of the calling code.</p>
  <p>The only protection against fully trusted code is to put it in a separate process and run that process with a restricted token so that its limits are enforced by the operating system.</p>
  <h1>Why</h1>
  <p>In .NET Framework 2.0, any fully trusted assembly will satisfy any demand, including a link demand for an identity permission that the assembly does not satisfy. In .NET Framework 1.0, this did not happen automatically. However, a fully trusted assembly could simply call <b>Assembly.Load</b>, supplying as evidence the strong name it wants to satisfy, or, alternatively, it could turn code access security off.</p>
  <h1>When</h1>
  <p>This guideline should always be followed whenever designing the access control to your code.</p>
  <h1>How</h1>
  <p>This applies whether code marks its interfaces as internal or private, or places link demands for <b>StrongNameIdentityPermission</b> on them.</p>
  <p>The following code sample shows a method decorated with a link demand for a specific <b>StrongNameIdentityPermission</b>.</p>
  <pre>public sealed class Utility<br />{<br />&amp;nbsp; // Although SomeOperation() is a public method, the following <br />&amp;nbsp; // permission demand means that it can only be called by partial trust <br />&amp;nbsp; // assemblies with the specified public key OR by any fully trusted code. <br />&amp;nbsp; [StrongNameIdentityPermission(SecurityAction.LinkDemand, <br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; PublicKey="00240000048...97e85d098615")]<br />&amp;nbsp; public static void SomeOperation() {}<br />}</pre>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>