<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="2015159731" Content_Hash="1723915584">
  <Metadata>
    <Id>e1bb71ed-d6a7-4fbb-b89a-6531596ed1a9</Id>
    <Id_History>9f732be5-ee0b-406f-b19d-19084a9370e6,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Use Absolute File Paths Where You Can</Title>
    <Category>File I/O</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Use Absolute File Paths Where You Can</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Srinath Vasireddy, Ashish Babbar, Rico Mariani, and Alex Mackman</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>What to Do</h1>
  <p>Try to use absolute file paths where you can. Do not trust an environment variable to construct a file path. </p>
  <h1>Why</h1>
  <p>You cannot guarantee the value of the environment variable. Also accepting file names or paths from users can result in attackers coercing your application into accessing arbitrary files and resources.</p>
  <h1>When</h1>
  <p>You should always try and avoid accepting file paths, instead strive to use absolute paths where possible.</p>
  <h1>How</h1>
  <p>If your application has to accept input file names, file paths, or URL paths, you need to validate that the path is in the correct format and that it points to a valid location within the context of your application. Failure to do this can result in attackers persuading your application into accessing arbitrary files and resources. </p>
  <h2>Validating File Paths</h2>
  <p>To prevent a malicious user manipulating your code's file operations, avoid writing code that accepts user-supplied file or path input. For example: </p>
  <ul>
    <li>If you must accept file names as input, use the full name of the file by using <b>System.IO.Path.GetFileName</b>. 
</li>
    <li>If you must accept file paths as input, use the full file path by using <b>System.IO.Path.GetFullPath</b>.</li>
  </ul>
  <h2>Using MapPath to Prevent Cross Application Mapping</h2>
  <p>If you use <b>MapPath</b> to map a supplied virtual path to a physical path on the server, use the overload of <b>Request.MapPath</b> that accepts a <b>bool</b> parameter so that you can prevent cross-application mapping. The following code example shows this technique.</p>
  <pre>try<br />{<br />&amp;nbsp; string mappedPath = Request.MapPath( inputPath.Text, <br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Request.ApplicationPath, false);<br />}<br />catch (HttpException)<br />{<br />&amp;nbsp; // Cross-application mapping attempted<br />}  </pre>
  <p>The final <b>false</b> parameter prevents cross-application mapping. This means that a user cannot successfully supply a path that contains <b>".."</b> to traverse outside of your application's virtual directory hierarchy. Any attempt to do this results in an exception of type <b>HttpException</b>.</p>
  <p>If you use server controls, you can use the <b>Control.MapPathSecure</b> method to retrieve the physical path to which the virtual path is mapped. <b>Control.MapPathSecure</b> uses code access security and throws an <b>HttpException</b> if the server control does not have permissions to read the resulting mapped file. For more information, see <b>Control.MapPathSecure</b> in the .NET Framework SDK documentation.</p>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>