<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-249129136" Content_Hash="-1477699680">
  <Metadata>
    <Id>9b2c7c12-9395-4a7e-8f0a-e23d4563ccfd</Id>
    <Id_History>23c21386-b64a-4872-8727-714977ba84a4,</Id_History>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>Clear Sensitive Data from Memory When No Longer Used</Title>
    <Category>Sensitive Data</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 3.5</Technology>
    <Type>Guideline</Type>
    <DirectLink>Clear Sensitive Data from Memory When No Longer Used</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>What to Do</h1>
  <p>Sensitive data, such as encryption keys or private information, should be maintained in memory for the minimum amount of time required. As soon as the data is no longer is needed, it should be purged from memory. All traces of it must be eradicated, so it does not end up leaking to the swap file.</p>
  <h1>Why</h1>
  <p>Sensitive data residing in memory for more time than is strictly necessary is at high risk to be swapped out to disk. This could leave fragments of data available well after the application has terminated. Such data may be gathered by inspecting the contents of the disk, temporary files or the swap file.</p>
  <h1>When</h1>
  <p>If your application handles sensitive data.</p>
  <h1>How</h1>
  <p>Sensitive data can be cleared by overwriting the memory where the sensitive data was stored. Deallocating the memory is not sufficient since the .NET garbage collector gives no guarantee as to when the deallocated memory will be collected or reused. Be aware that any time you assign a sensitive data to a new buffer, or pass it as a parameter, the sensitive data is being copied and is now in memory in a new location. When clearing memory, ensure you clear every instance.</p>
  <p>Keep in mind the following considerations when handling passwords: </p>
  <ol>
    <li>
      <p>
        <strong>Identify sensitive information. </strong>Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords, and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p>
      <ul>
        <li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. <li>Information that a user provides that they would not want shared with other users of the application. <li>Information that comes from an external trusted source that is not designed to be shared with users.</li></li></li>
      </ul>
      <li>
        <p>
          <strong>Identify all sensitive data use. </strong>Locate all code segments, both functions and data members, that handle sensitive data. These can be functions and data structures scattered throughout your application. If possible, centralize all code that handles sensitive data.</p>
        <li>
          <p>
            <strong>Store sensitive data in mutable objects.</strong> Mutable objects allow the data in them to be overwritten. This is especially useful in .NET as objects are required to be deallocated through the garbage collector. Therefore, there is no certainty when the sensitive data will be deallocated from the current process space. Examples of mutable objects include character arrays (i.e. char&amp;#91;&amp;#93;). .NET strings, however, are not mutable objects; therefore, once allocated, their current memory space cannot be modified. When storing sensitive data into an array, make sure that you use arrays of primitive data types such as byte, char, and int, but not arrays of the wrapper classes that .NET provides for primitive types such as Byte, Char or Int32. If you are forced to use .NET strings, (for instance, when calling a function which takes a .NET string), try to construct the string just before use and assign a new value to it as soon as you are done to encourage speedy garbage collection; this is sub-optimal and may lead to security issues, but until the .NET APIs allow for the exclusive use of mutable objects or SecureStrings, it may be unavoidable.</p>
          <li>
            <p>
              <strong>Clear all sensitive data instances.</strong> Make sure that all memory locations where sensitive data has been stored are cleared or overwritten after their use. Losing a pointer to a sensitive data instance can result in not cleaning that particular memory and allowing the sensitive data to leak.</p>
          </li>
        </li>
      </li>
    </li>
  </ol>
  <h1>Problem Example</h1>
  <p>The following code makes a use of a password. Although the pointer to the string is removed and garbage collection is called, .NET does not guarantee the data will be erased.</p>
  <pre>string pass = GetPassword();<br />...<br />pass = null;<br />GC.Collect();</pre>
  <h1>Solution Example</h1>
  <p>The following code makes use of a password. After the password is used, the memory is explicitly cleared. Since strings are immutable objects, the code uses character arrays to store passwords. This makes it possible to overwrite the data after its use. </p>
  <pre>char&amp;#91;&amp;#93; pass = GetPassword();<br />...<br />ClearPassword(pass);<br />pass = null;<br />...<br />void ClearPassword(char&amp;#91;&amp;#93; pass)<br />&amp;#123;<br />      for(int i=0; i&lt;pass.Length; i&amp;#43;&amp;#43;)<br />      &amp;#123;<br />            pass&amp;#91;i&amp;#93; = ' ';<br />      &amp;#125;<br />&amp;#125;</pre>
  <h1>Additional Resources</h1>
  <ul>
    <li>To learn more about the .NET garbage collector, visit: Documentation for <a href="http://msdn2.microsoft.com/en-us/library/system.gc(vs.80).aspx">GC Class</a> in MSDN. <li>To learn more about .NET data types, visit: <a href="http://msdn.microsoft.com/en-us/magazine/cc301569.aspx">.NET Type Fundamentals</a>.</li></li>
  </ul>
  <h1>Related Items</h1>
  <ul>
    <li>
      <a href="/article/88ae773e-d30d-4d76-89ef-41b40f0eb0aa">Attack: Sniff Memory for Secrets Attack</a>
      <li>
        <a href="/article/48ebd4c2-b51d-47b6-8c4c-f7bc37edfb1f">Checklist Item: Sensitive Data is Cleared from Memory when No Longer Used </a>
      </li>
    </li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
  </Content>
</TeamMentor_Article>