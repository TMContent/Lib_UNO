<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-2090057714" Content_Hash="297763212">
  <Metadata>
    <Id>6826369c-982e-40ca-b58b-fe55248537da</Id>
    <Id_History>e17a2db3-a5fe-4bdb-bd55-7fef4964d541,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>If You Need to Store Sensitive Data, Encrypt It</Title>
    <Category>Sensitive Data</Category>
    <Phase>Implementation</Phase>
    <Technology>ADO.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>If You Need to Store Sensitive Data, Encrypt It</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Chaitanya Bijwe</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ADO.NET 2.0</li>
  </ul>
  <h1>What to Do</h1>
  <p>Avoid storing sensitive data in the database, if possible. If you must store sensitive data, protect the data by using encryption. Use a strong symmetric encryption algorithm such as AES to encrypt the sensitive data before storing it in the database. Use DPAPI to encrypt the symmetric encryption key, and secure the encrypted key in a protected location such as the Windows registry in a key that has an ACL that restricts access to your application's process account.</p>
  <p>
    <strong>Note</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;SQL Server 2005 includes support for data encryption directly in the database.</p>
  <h1>Why</h1>
  <p>Encrypted data in SQL Server is a final line of defense.&amp;nbsp; Even if an attacker successfully gains access to a database, she must still decrypt the data.&amp;nbsp; Although key management and encryption overhead add to the cost and complexity of an application, at-rest data encryption can greatly increase application security.&amp;nbsp; Furthermore, it is or will be required for some classes of personally identifiable information, such as credit card records, and can reduce corporate liability even when not required. </p>
  <h1>When</h1>
  <p>You should consider the level of protection required, and use encryption only when protecting a field is worth the cost incurred.&amp;nbsp; Good candidates for encryption include credit cards numbers, passwords and similar authentication tokens which cannot be stored as salted hashes, medical records, government ID numbers, and other highly sensitive and/or personally identifiable information. </p>
  <h1>How</h1>
  <h2>1. Set Up the Database Master Key</h2>
  <p>The Service Master Key, a symmetric key that directly or indirectly encrypts all keys on the server, is created automatically when you install SQL Server.&amp;nbsp; If it is compromised, an attacker can eventually crack every key in every database.&amp;nbsp; For that reason, it's protected by the Data Protection API (DPAPI) in Windows.&amp;nbsp; Within the scope of a database, the database master key is the root encryption object for all keys, certificates, and data in the database, and you must create a database master key (with a user-supplied password) before using it: </p>
  <pre>CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'WeZ#6hv*XHq#akAEaqcr7%CUP3aQ'</pre>
  <p>The resulting key is encrypted with triple DES and stored twice.&amp;nbsp; One storage location is in the <b>sys.symmetric_keys</b> database table, encrypted by the supplied password, and the second is the <b>sys.databases</b> table in the master database, encrypted using the Service Master Key.&amp;nbsp; Note that moving databases with keys set between SQL server installations takes extra work, as the Service Master Keys will be different. </p>
  <h2>2. Create Sub-keys for Application Use</h2>
  <p>Once the database master key exists, you can use it to create any of three types of keys, depending on the encryption you need: Asymmetric keys are used for public key cryptography with a public and private key pair. </p>
  <ul>
    <li>Symmetric keys are used for shared secrets where the same key both encrypts and decrypts data. </li>
    <li>Certificates are essentially wrappers for a public key. </li>
  </ul>
  <p>You can have SQL Server create a certificate for its own use or import a certificate created by any trusted certificate authority, such as Microsoft Certificate Server or VeriSign.&amp;nbsp; Options include setting a password to use to encrypt the private key or letting SQL Server use the database master key, as well as setting the creation and expiration dates. </p>
  <h2>3. Encrypt Data in the Database</h2>
  <p>Once the certificate exists, you can encrypt data using one of the new T-SQL functions that supports encryption, <b>EncryptByCert</b>.&amp;nbsp; Imagine that you have a table called Customer defined like this: </p>
  <pre>CREATE TABLE Customer (<br />    CustId int,<br />     name nvarchar(30),<br />     City varchar(20),<br />     CreditCardType varbinary(300),<br />    CreditCardNumber varbinary(300),<br />     Notes varbinary(4000))GO<br /></pre>
  <p>Encrypted data is binary, so the table uses varbinary fields to hold it.&amp;nbsp; Because the encrypted data includes the digital certificate, the field lengths must be rather large, even to hold simple strings like "Visa" and a credit card number.&amp;nbsp; Here is how you can insert a row of data into this table: </p>
  <pre>INSERT INTO Customer VALUES (1, 'Don Kiely', 'Fairbanks',<br />    EncryptByCert(Cert_ID('User1Certificate'), 'Visa'),<br />    EncryptByCert(Cert_ID('User1Certificate'), '1234-5678-8765-4321'),<br />    EncryptByCert(Cert_ID('User1Certificate'),<br />         'This customer is a real flake. Don''t trust him!'))</pre>
  <p>
    <b>EncryptByCert</b> takes two parameters, the certificate ID, which you can obtain with the <b>Cert_ID</b> function, the name you gave the certificate, and the data to be encrypted. </p>
  <h2>4. Decrypt Data from the Database</h2>
  <p>To decrypt the data as part of a SELECT statement, use DecryptByCert as shown here: </p>
  <pre>SELECT CustID, Name, City,<br />    CONVERT(VARCHAR,<br />         DecryptByCert(Cert_ID('User1Certificate'),<br />            CreditCardType)) AS CardType,<br />    CONVERT(VARCHAR,<br />         DecryptByCert(Cert_ID('User1Certificate'),<br />            CreditCardNumber)) AS CardNumber,<br />    CONVERT(VARCHAR,<br />         DecryptByCert(Cert_ID('User1Certificate'),Notes)) AS NotesFROM Customer</pre>
  <p>There's a lot more that can be done with encryption in the database;&amp;nbsp;these are just the basics. </p>
  <h1>&amp;nbsp;</h1>
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>