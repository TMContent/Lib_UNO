<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-160668491" Content_Hash="1562867219">
  <Metadata>
    <Id>35737c28-2751-4f82-94c1-e1a323377b1a</Id>
    <Id_History>f87e4ab3-f2d0-4d29-ae35-8f8ddc0adc6e,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Do Not Trust Input</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Do Not Trust Input</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Srinath Vasireddy, Ashish Babbar, Rico Mariani, and Alex Mackman</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>What to Do</h1>
  <p>Do not trust any input to your application. Validate and constrain input by checking it for type, length, format, and range.</p>
  <h1>Why</h1>
  <p>An attacker who passes malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities.</p>
  <h1>When</h1>
  <p>All input should always be validated, regardless of source.&amp;nbsp; Unless data is actually static within the scope of the local code base, it could be modified by a malicious userâ€”even data in a database which is supposed to be static.</p>
  <h1>How</h1>
  <p>Check for known good data and constrain input by validating it for type, length, format, and range. Check all numeric fields for type and range. You can use regular expressions and the <b>Regex</b> class, and you can validate numeric ranges by converting the input value to an integer or double, and then performing a range check.</p>
  <p>The following example shows how to use the Regex class. </p>
  <pre>using System.Text.RegularExpressions ;<br />&amp;nbsp;<br />// Instance method:<br />Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");<br />Response.Write(reg.IsMatch(Request.QueryString["Name"]));</pre>
  <pre>// Static method:<br />if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$")) <br />{<br />&amp;nbsp;&amp;nbsp; // Name does not match expression<br />}</pre>
  <p>If you cannot cache your regular expression for frequent use, you should use the static <strong>IsMatch</strong> method where possible for performance reasons, to avoid unnecessary object creation. </p>
  <p>In general, validate your input against the least permissive expression possible that will accept all the input you expect for that field.&amp;nbsp; If you know that the field will have certain internal structure, check for it.&amp;nbsp; If there is a range of standard formats which your users may enter data in, but these formats are easily converted to a single internal format, do so.&amp;nbsp; </p>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>