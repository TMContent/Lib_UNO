<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="2091552956" Content_Hash="-155727029">
  <Metadata>
    <Id>0d04cb3a-36d9-452a-85eb-28f60f88faf7</Id>
    <Id_History>ee3067c5-e374-4062-acab-343da3879bc4,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Perform a Security Deployment Review for ASP.NET 2.0</Title>
    <Category>Deployment Considerations</Category>
    <Phase>Deployment</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Andy Wigley, Kishore Gopalan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 2.0</li>
  </ul>
  <h1>Summary </h1>
  <p>This How To shows you how to perform a security deployment review for an ASP.NET 2.0 application to identify potential security vulnerabilities introduced by inappropriate configuration settings. The majority of the review process involves making sure that correct configuration settings are applied to the machine-level Web.config file and your application-specific Web.config file.</p>
  <h1>Objectives</h1>
  <ul>
    <li>Learn what's new in ASP.NET 2.0 security configuration. 
<li>Review ASP.NET 2.0 configuration settings to improve security. 
<li>Learn about the new special directories in ASP.NET 2.0, and their security implications. 
<li>Learn how to lock down your machine-level settings. 
<li>Learn how to configure &lt;machineKey&gt; for a Web farm scenario. 
<li>Learn how to encrypt a connection string in a Web farm scenario. 
<li>Learn how to use obfuscation with ASP.NET 2.0. </li></li></li></li></li></li></li>
  </ul>
  <h1>Overview</h1>
  <p>The overall security of an ASP.NET application depends on the security configuration of the infrastructure on which the application is deployed. Correct configuration of the Web server and the Internet Information Service (IIS) servers that host your ASP.NET application is very important. If the underlying infrastructure is weak, your ASP.NET application could be exposed to vulnerabilities that attackers can exploit. This How To shows you what you need to review to make sure that you have a strong deployment policy that helps to prevent such vulnerabilities. </p>
  <p>The deployment review covered in this chapter inspects the configuration of ASP.NET and IIS. There are many .NET Framework configuration settings maintained in Web.config configuration files; however, this How To considers only those settings that affect the security of your ASP.NET Web application. </p>
  <a name="Web.Config_vs._Machine.Config">
  </a>
  <h2>Web.Config vs. Machine.Config </h2>
  <p>While ASP.NET configuration at a machine level is available in both the Machine.config and Web.config files in ASP.NET 2.0, you can focus on reviewing and modifying the Web.config file alone. This is because settings in the machine-level Web.config file override settings in the Machine.config file. Settings in application-level Web.config files override the settings in the machine-level Web.config file. </p>
  <p>Note During your review, if there is a setting that is missing from the Web.config file, be sure to review the configuration file hierarchy before assuming that the default value is in force. For example, if you are looking at an application-level Web.config file, you must look at the machine-level Web.config file. If the setting is missing from that file as well, you should then examine the Machine.config file. </p>
  <h2>What's New in 2.0</h2>
  <p>The .NET Framework version 2.0 and ASP.NET version 2.0 introduce many new security features. The most notable enhancements for ASP.NET Web applications are the following: </p>
  <ul>
    <li>
      <b>Configuration file changes</b>. Machine-wide configuration settings for all Web applications on a server are now maintained in a machine-level Web.config file instead of Machine.config. The machine-level Web.config file is located in the %Windir%\Microsoft.NET\Framework\{version}\CONFIG directory. 
<li><b>Configuration file encryption</b>. ASP.NET version 2.0 introduces protected configuration to enable you to encrypt sections of your configuration files by using either DPAPI or RSA encryption. This is particularly useful for encrypting connection strings and account credentials. 
<li><b>Machine key enhancements</b>. The &lt;machineKey&gt; element now supports a decryption attribute that specifies the symmetric encryption algorithm used to encrypt and decrypt forms authentication tickets. ASP.NET version 2.0 provides support for AES symmetric encryption, which is used by default, in addition to DES and 3DES. 
<li><b>Health monitoring</b>. ASP.NET version 2.0 introduces health monitoring. It supports many standard events that you can use to monitor the health of your application. Examples of security-related events that are automatically generated include logon failures and successes when using ASP.NET membership, attempts to tamper with or reuse forms authentication tickets, and infrastructure events such as disk access failures. You can also create custom events to instrument your application for other security and non-security related notable events. 
<li><b>Forms authentication and membership</b>. You can now use forms authentication with membership and the membership API. Membership supports a provider model, and includes the SqlMembershipProvider for storing membership data in SQL Server databases and ActiveDirectoryMembershipProvider for storing user data in Microsoft Active Directory® director service and Active Directory Application Mode (ADAM) stores. You no longer have to create your own custom databases and write your own custom authentication code. 
<li>Role manager. Role manager provides secure role storage and an API for managing and checking role membership. Role manager supports a provider model. The supplied providers include SqlRoleProvider for SQL Server role stores; WindowsTokenRoleProvider, used with Windows authentication, which uses Windows groups as roles; and AuthorizationStoreRoleProvider, which uses the Microsoft Windows Server™ 2003 Authorization Manager for managing roles in Active Directory or Active Directory Application Mode (ADAM) stores. 
<li><b>Deployment without source code</b>. You can now pre-compile an ASP.NET 2.0 Web site and deploy just the compiled assemblies on your production server. You do not need to deploy code files or mark up source files, such as .aspx, .ascx, or .asmx files. Configuration files and static files such as HTML files or image files are deployed as normal. This approach avoids any risk of theft of your intellectual property, and it can also result in improved performance. 
<li><b>Strong name signing of ASP.NET applications</b>. If you pre-compile an ASP.NET application, you have the option of signing the resulting assembly. By signing assemblies with a strong name, you make the assembly tamper proof. 
<li><b>New special subdirectories</b>. In ASP.NET 1.1, the only special directory in your application's virtual root directory was Bin. In ASP.NET 2.0, a number of new special directories are used. These include the following: </li></li></li></li></li></li></li></li></li>
  </ul>
  <p>/App_Code /App_GlobalResources /App_LocalResouces /App_WebReferences /App_Data /App_Browsers /App_Themes </p>
  <ul>
    <li>
      <b>Personalization</b>. ASP.NET 2.0 introduces personalization and a Profile object that you can use to store and retrieve per-user settings for users of your site. Personalization use strong typing and personalization data can be read and written on demand. Personalization uses a provider model. The SqlProfileProvider is used to store personalization data in a SQL Server database. </li>
  </ul>
  <h2>Snapshot</h2>
  <p>Table 1 provides an overview of the security-related configuration settings from the Web.config file. Use this table as a checklist to ensure appropriate configuration. </p>
  <p>
    <table>&gt;<b>Table 1: ASP.NET 2.0 Security Configuration Settings</b><tbody><tr><th>Setting </th><th>Comments </th></tr><tr><td><b>&lt;trace&gt;</b></td><td>Make sure that trace information and detailed error information is not returned to the client: <b>&lt;trace enabled="false"&gt;</b>. </td></tr><tr><td><b>&lt;customErrors&gt;</b></td><td>Make sure that error details are not returned to the client, and that the user is redirected to a generic error page: <b>&lt;customErrors mode="On" defaultRedirect="CustomErrorPage.htm" /&gt;</b>. 
<p>Make sure that a generic error page writes errors to the event log. </p></td></tr><tr><td><b>&lt;httpRuntime&gt;</b></td><td>Make sure that <b>maxRequestLength</b> is set appropriately to deter users from uploading very large files; the maximum allowed value is 4096 KB: <b>&lt;httpRuntime maxRequestLength="file Size in KB"/ &gt;</b>. </td></tr><tr><td><b>&lt;compilation&gt;</b></td><td>Check that you do not compile debug binaries. Make sure the debug attribute is set to false: <b>&lt;compilation debug="false"/&gt;</b>. </td></tr><tr><td><b>&lt;forms&gt;</b></td><td>Make sure that forms authentication cookies are protected: <b>&lt;forms protection="All" … /&gt;</b>. 
<p>Make sure that authentication cookie life time is reduced when SSL is not used. </p><p>Make sure that the authentication cookie is protected over the network. </p><p>Make sure that <b>slidingExpiration</b> is set to false when SSL is not used and when you are concerned about cross-site scripting attacks and cookie hijacking. </p><p>Make sure that unique authentication cookie names and paths are specified: <b>&lt;forms name=".AppSpecific" loginUrl="login.aspx" protection="All" timeout="5" path="/Application" requireSSL="true" slidingExpiration = "true" &gt;</b>. </p></td></tr><tr><td><b>&lt;membership&gt;</b></td><td>Make sure that the correct provider is configured as default provider. 
<p>Make sure that membership providers are configured to use hashed passwords. </p><p>Make sure that the SQL connection string for <b>SqlMembershipProvider is encrypted</b>. </p><p>Make sure that the <b>applicationName</b> attribute is configured uniquely for each application in <b>SqlMembershipProvider</b>. </p></td></tr><tr><td><b>&lt;identity&gt;</b></td><td>Make sure that credentials for the impersonation identity are protected: <b>&lt;identity impersonate="true" userName="plugthisin" password="plugthisin"/&gt;</b>. </td></tr><tr><td><b>&lt;authorization&gt;</b></td><td>Make sure that only the authenticated users are authorized. </td></tr><tr><td><b>&lt;roleManager&gt;</b></td><td>Make sure that the roles cookie is protected. 
<p>Make sure that the connection string for role manager is encrypted when the connection string contains credentials. </p></td></tr><tr><td><b>&lt;sessionState&gt;</b></td><td>Make sure that the state connection string is protected: <b>stateConnectionString="tcpip=127.0.0.1:42424"</b>. 
<p>Make sure that the SQL connection string uses integrated security or uses encrypted values: <b>sqlConnectionString="data source=127.0.0.1;Integrated Security=SSPI"</b>. </p></td></tr><tr><td><b>&lt;machineKey&gt;</b></td><td>Make sure that <b>ViewState</b> and forms authentication are protected: <b>&lt;machineKey validationKey="AutoGenerate,IsolateApps" decryptionKey="AutoGenerate,IsolateApps" validation="AES" decryption="Auto" /&gt;</b>. 
<p>If the code uses multiple applications on the same server, make sure that the <b>validationKey</b> and <b>decryptionKey</b> values are <b>"AutoGenerate,IsolateApps"</b>. </p><p>If the application makes use of a Web farm, make sure that <b>validationKey</b> and <b>decryptionKey</b> are manually generated and copied to each server in the Web farm. </p></td></tr><tr><td><b>&lt;trust&gt;</b></td><td>Set the <b>trustLevel</b> so that only the required permission is given to the application and nothing more. If necessary, create a custom trust level. </td></tr><tr><td><b>&lt;httpHandlers&gt;</b></td><td>Make sure that all unused <b>httpHandlers</b> are mapped to the forbidden handler. </td></tr><tr><td><b>&lt;healthMonitoring&gt;</b></td><td>If the code uses <b>SqlWebEventProvider</b>, make sure that the connection string section is encrypted. 
<p>Limit the amount of details being logged. </p></td></tr></tbody></table>
  </p>
  <h1>Summary of Steps</h1>
  <p>The deployment security review activity includes the following steps: </p>
  <ul>
    <li>Step 1. Verify that &lt;trace&gt; is disabled. 
<li>Step 2. Verify that &lt;customErrors&gt; mode is set to On. 
<li>Step 3. Review &lt;httpRuntime&gt; settings to limit the size of the request. 
<li>Step 4. Verify that the &lt;compilation&gt; setting prevents debug compilations. 
<li>Step 5. Review &lt;forms&gt; authentication settings. 
<li>Step 6. Review &lt;membership&gt; settings when using forms authentication. 
<li>Step 7. Review &lt;identity&gt; and impersonation settings. 
<li>Step 8. Review &lt;authorization&gt; settings. 
<li>Step 9. Review &lt;roleManager&gt; settings. 
<li>Step 10. Review &lt;sessionState&gt; settings. 
<li>Step 11. Review &lt;machineKey&gt; settings. 
<li>Step 12. Review &lt;trust&gt; levels. 
<li>Step 13. Prevent download of unused file types. 
<li>Step 14. Verify that credentials are encrypted in &lt;processModel&gt; settings. 
<li>Step 15. Review &lt;healthMonitoring&gt; settings. </li></li></li></li></li></li></li></li></li></li></li></li></li></li></li>
  </ul>
  <h1>Step 1. Verify that &lt;trace&gt; Is Disabled </h1>
  <p>You should disable tracing on production servers to make sure that an attacker cannot gain information from the trace about your application. Trace information can help an attacker probe and compromise your application. </p>
  <p>Is tracing disabled? </p>
  <p>Verify that tracing is disabled as shown in the following example (tracing is disabled by default). </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;trace enabled="false"/&gt;<br />&lt;/system.web&gt;... </pre>
  <h1>Step 2. Verify that &lt;customErrors&gt; mode is Set to On </h1>
  <p>Does the code send exception information in error messages? </p>
  <p>Verify that the mode attribute for the &lt;customErrors&gt; element is set to On or RemoteOnly. By default, ASP.NET displays user friendly error messages to a remote host and exception error messages on the local host. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;customErrors mode="On" defaultRedirect="CustomErrorPage.htm"/&gt;<br />&lt;/system.web&gt;... </pre>
  <p>If mode is set to Off, an attacker can obtain information about your application from the detailed exception information that is displayed in the error. This information could be used to construct an attack on your application. </p>
  <h1>Step 3. Review &lt;httpRuntime&gt; Settings to Limit the Size of the Request </h1>
  <p>Is the request size limited? </p>
  <p>Verify the value of the maxRequestLength attribute on the &lt;httpRuntime&gt; element, which is shown in the following code example. You can use this value to prevent users from uploading very large files. The default value is 4096 KB. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> ...<br /> &lt;httpRuntime maxRequestLength="2000" ... /&gt;<br /> ...<br />&lt;/system.web&gt;<br />... </pre>
  <p>Your application could be vulnerable to denial of service attacks if you do not limit the size of requests. This is especially significant for applications that support uploading files. </p>
  <h1>Step 4. Verify that the &lt;compilation&gt; Setting Prevents Debug Compilations </h1>
  <p>Are you running a release version of your binaries? </p>
  <p>Check that you do not compile debug binaries. Make sure the debug attribute is set to false on the &lt;compilation&gt; element, as shown in the following example. </p>
  <pre>...<br />&lt;system.web&gt;<br /> ...<br /> &lt;compilation debug="false"/&gt;<br /> ...<br />&lt;/system.web&gt;<br />... </pre>
  <p>Preventing debug compilation is important for several reasons. Creating debug binaries is slower than producing release binaries. Debug binaries also contain symbolic information that can help malicious users attempt to debug the application. In addition, developers often include conditional test code that is only designed for debug compilations and is not intended for production use. </p>
  <h1>Step 5. Review &lt;forms&gt; Authentication Settings </h1>
  <p>If your application uses forms authentication, there are a number of security issues that you need to take care of. The configuration example below shows the default values set by ASP.NET 2.0. After you review the example, review your Web.config file by using the steps outlined that follow. </p>
  <p>The default forms authentication values are: </p>
  <p>
    <br />
  </p>
  <pre>&lt;authentication mode="Forms"&gt;<br />&lt;forms<br />    loginUrl="login.aspx"<br />        protection="All"<br />             requireSSL="false"<br />           timeout="30"<br />                 name=".ASPXAUTH"<br />             path="/"<br />                     slidingExpiration="true" /&gt;<br />&lt;/authentication&gt; </pre>
  <p>Use the following questions to review forms authentication settings: </p>
  <p>Are cookies encrypted and checked for integrity? Check that the protection attribute of the &lt;forms&gt; element is set to All or is not specified, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>&lt;forms protection="All" ... /&gt; </pre>
  <p>This is important to ensure that cookie contents are not read and not tampered with. Cookies can be stolen, even over a Secure Sockets Layer (SSL) channel using cross-site scripting attacks. </p>
  <p>Is the life time of the authentication cookie limited? If your site uses SSL to protect authentication cookies and you have set requreSSL=true, the default cookie life time of 30 minutes is recommended. However, if you cannot use SSL to protect forms authentication cookies, consider reducing the cookie life time, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;authentication mode="Forms"&gt;<br />   &lt;forms timeout="10" ... /&gt;<br /> &lt;/authentication&gt;&lt;/system.web&gt;... </pre>
  <p>By reducing the cookie life time, you reduce the time that an attacker who captures an authentication cookie has to gain spoofed access to your application. </p>
  <p>Are multiple applications deployed on the same server? If you have multiple applications deployed on the same server, check that the name and path attributes of the &lt;forms&gt; element for each application uses distinct cookie names and paths, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>&lt;forms name="ApplicationSpecific" path="/Application" ... /&gt; </pre>
  <p>If multiple applications share the same cookie names and paths, it is possible that an authentication cookie generated by one application can be used to access another application. </p>
  <p>Does the configuration include credentials? Make sure that the &lt;credentials&gt; element after the &lt;forms&gt; element is either not specified or is empty, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;authentication mode="Forms"&gt;<br />   &lt;forms&gt;<br />     &lt;credentials/&gt;<br />   &lt;/forms&gt;<br /> &lt;/authentication&gt;<br />&lt;/system.web&gt;... </pre>
  <p>The &lt;credentials&gt; element is intended to be used in development and testing environments, and not in production. Production systems should store user credentials in a directory or database. </p>
  <p>How does the application store credentials? </p>
  <p>If your application uses forms authentication, make sure you use a SQL Server, Active Directory, or ADAM credential store. </p>
  <p>Does the configuration use sliding expiration? </p>
  <p>Make sure that the slidingExpiration attribute is set to false if you do not use SSL to protect forms authentication cookies and you are concerned about cookie hijacking. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;authentication mode="Forms"&gt;<br />   &lt;forms slidingExpiration="false"/&gt;<br /> &lt;/authentication&gt;<br />&lt;/system.web&gt;... </pre>
  <p>This setting ensures that an absolute expiration period exists after which the authentication ticket will no longer be valid. When slidingExpiration="true", the expiration period is reset after each Web request. By setting this attribute to false, you limit the time during which an attacker can steal an authentication cookie and use it to access your application. </p>
  <p>Does your application store passwords in clear text? If you are using the SqlMembershipProvider, then passwords are stored as hashes by default. To verify that this has not been changed to a setting that is less secure than the default, check that the PasswordFormat attribute on the &lt;add&gt; sub-element within the &lt;membership&gt; element is not set to Clear. Instead it should be set to Hashed or Encrypted. </p>
  <p>
    <br />
  </p>
  <pre>&lt;add PasswordFormat="Hashed" .../&gt; </pre>
  <p>If you are using Active Directory membership, then the passwords are stored as hashes and you do not have to review further. </p>
  <p>If you are using a custom authentication mechanism, make sure that clear-text passwords are not stored in the database. Instead, store password hashes with an added random salt value. </p>
  <p>Does your application use strong passwords? Your application should enforce the use of strong passwords. Strong password policies include password length and complexity restrictions, such as the following: </p>
  <p>Passwords cannot contain all or part of the user's account name. Passwords must be at least 6 characters in length. Passwords must contain characters from three of the following four categories: English uppercase characters (A through Z) English lowercase characters (a through z) Base 10 digits (0 through 9) Non-alphanumeric characters (for example.,&nbsp;!, $, #, %) A good way to enforce strong password use is to use a regular expression in the forms logon page. If you are using a membership provider, you can enforce password complexity rules with Web.config file settings. You can use the following attributes: </p>
  <p>passwordStrengthRegularExpression. The default is "". minRequiredPasswordLength. The default is 7. minRequiredNonalphanumericCharacters. The default is 1. The following example shows how to configure the SQL Server membership provider that supplies a custom regular expression to constrain the passwords used by the membership provider. </p>
  <p>
    <br />
  </p>
  <pre>&lt;membership defaultProvider="MySqlMembershipProvider"&gt;<br /> &lt;providers&gt;<br />   &lt;add name="MySqlMembershipProvider"<br />         connectionStringName="MyLocalSQLServer"<br />         applicationName="MyAppName"<br />        passwordStrengthRegularExpression=<br />                   "^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$"<br />         type="System.Web.Security.SqlMembershipProvider, <br />	System.Web, Version=2.0.0.0, Culture=neutral, <br />	PublicKeyToken=b03f5f7f11d50a3a"/&gt;<br /> &lt;/providers&gt;<br />&lt;/membership&gt; </pre>
  <p>For more information, see "How To: Protect Forms Authentication in ASP.NET 2.0." </p>
  <p>Does your application use SSL with forms authentication? If you use SSL, check that the requireSSL attribute is set to true to ensure that the forms authentication cookie is only transmitted over HTTPS connections (using SSL). The following example shows the requireSSL attribute with proper settings. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;authentication mode="Forms"&gt;<br />   &lt;forms loginUrl="Secure\Login.aspx" requireSSL="true" ... /&gt;<br /> &lt;/authentication&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>This setting prevents forms authentication cookies from being captured, viewed, or tampered with while crossing the network. It also helps mitigate the risks posed by cookie replay attacks. </p>
  <p>
    <b>Note</b> This setting assumes that your Web application is configured to use SSL for those pages that require authenticated access. </p>
  <h1>Step 6. Review &lt;membership&gt; Settings When Using Forms Authentication </h1>
  <p>ASP.NET 2.0 applications that use forms authentication should use the membership providers and APIs to store and manage user credentials. This reduces the amount of application code that needs to be developed, helps to ensure secure user management and user authentication, and supports a provider model that makes it possible to update the underlying store without changing code. </p>
  <p>To review which provider your application uses, examine the defaultProvider attribute of the &lt;membership&gt; element in your application's Web.config file. If the application's Web.config file does not contain a &lt;membership&gt; element and you know the application uses membership, then it is using the default provider specified in the machine-level Web.config file. </p>
  <p>Review your membership configuration by using the following questions: </p>
  <p>Are Active Directory connection credentials encrypted if specified? If the application uses the ActiveDirectoryMembershipProvider and stores user information in Active Directory, connection credentials can be specified by using the connectionUsername and connectionPassword attributes on the &lt;add&gt; element beneath the membership &lt;providers&gt; element. These credentials are for an account with permissions to access the user container in Active Directory. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br />...<br /> &lt;membership defaultProvider="MembershipADProvider"&gt;<br />   &lt;providers&gt;<br />     &lt;add<br />       name="MembershipADProvider"<br />       connectionUsername="&lt;domainName&gt;\administrator"<br />       connectionPassword="password"/ ... &gt;<br />  &lt;/providers&gt;<br />&lt;/membership&gt;<br />...<br />&lt;/system.web&gt;<br />... </pre>
  <p>
    <b>Note</b> If the connectionUsername and connectionPassword attributes are not specified, the ASP.NET application's application pool identity is used to access Active Directory. In this situation, you must ensure that the account used to run the application pool has access to the User container in Active Directory. If credentials are specified, ensure that they are encrypted. For more information about how to encrypt these credentials by using the Aspnet_regiis utility, see "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA." </p>
  <p>
    <b>Note</b> Web farm deployments should use RSA encryption. Are the ActiveDirectoryMembershipProvider credentials secured over the wire? Make sure that the credentials your application uses to connect to Active Directory are protected when they are sent from the Web server to the domain controller. Check that the connectionProtection attribute is set to Secure, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;membership&gt;<br />   &lt;providers&gt;<br />     &lt;add connectionProtection="Secure" ... /&gt;<br />   &lt;/providers&gt;<br /> &lt;/membership&gt;<br />&lt;/system.web&gt;<br /> ... </pre>
  <p>
    <b>Note</b> connectionProtection="Secure" is the default setting. Are passwords stored as hashes? Verify that passwords are stored in hash format. To do this, set the passwordFormat attribute to hashed, as shown in the following example. This is the default setting for both SqlMembershipProvider and ActiveDirectoryMembershipProvider. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;membership&gt;<br />   &lt;providers&gt;<br />     &lt;add passwordFormat="hashed" …/&gt;<br />   &lt;/providers&gt;<br />  &lt;/membership&gt;<br />&lt;/system.web&gt; ... </pre>
  <p>Use a secure password format to protect credentials if your user store is stolen from the server. PasswordFormat can have one of three settings: </p>
  <p>Clear. Provides no protection. Hashed. Makes it impossible to steal the original credentials, but does allow the opportunity for a dictionary attack against the hash. This is the default. Encrypted. Protects against dictionary attacks, but at the expense of additional processing when authenticating. Does your application enforce strong passwords? Ensure that the membership provider is configured to enforce strong passwords. Check the settings of the following attributes: minRequiredPasswordLength, minRequiredNonAlphaNumericCharacters and passwordStrengthRegularExpression. </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;membership&gt;<br />   &lt;providers&gt;<br />     &lt;add minRequiredPasswordLenghth="7",<br />           minRequiredNonAlphanumericCharacters="1",<br />          ...<br /> /&gt;<br />    &lt;/providers&gt;<br /> &lt;/membership&gt;<br />&lt;/system.web&gt; </pre>
  <p>... </p>
  <p>
    <b>Note</b> The password strength policy defined by the default SqlMembershipProvider and ActiveDirectoryMembershipProvider configuration is to enforce a minimum password length of 7 characters with at least 1 non-alphanumeric character. Note In ActiveDirectoryMembershipProvider the password strength is determined by the provider configuration and the Active Directory store; the strongest of the two password policies is used. Are connection strings in the Web.config file encrypted? Verify that the connection strings used to connect to the membership store are encrypted. For more information, see "How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Sections in ASP.NET 2.0 Using RSA." </p>
  <p>Does your configuration use a unique applicationName for SqlMembershipProvider? If you are hosting multiple applications and do not want to allow cross application authentication, then verify that you have configured the applicationName attribute with a unique value for each application, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> ...<br /> &lt;membership&gt;<br />   &lt;providers&gt;<br />     &lt;add applicationName="UniqueName" ... /&gt;<br />   &lt;/providers&gt;<br /> &lt;/membership&gt;<br />...<br />&lt;/system.web&gt;<br />... </pre>
  <h1>Step 7. Review &lt;identity&gt; and Impersonation Settings </h1>
  <p>The &lt;identity&gt; element maintains impersonation settings for your application. If the impersonate attribute for the &lt;identity&gt; element is set to true, your application impersonates the authenticated caller (or the anonymous Internet user account configured in IIS) and all resource access is performed using the impersonated identity. When impersonate is set to false (the default setting), all resource access uses the application's process identity. For the Microsoft Windows Server™ 2003 operating system, this is the identity used to run the application's application pool, which by default is the NT Authority\Network Service account. </p>
  <p>Use the following questions to review &lt;identity&gt; and impersonation settings: </p>
  <p>Does your configuration include credentials on the &lt;identity&gt; element? If credentials are specified, make sure they are encrypted with the Aspnet_regiis utility. The configuration should be similar to the following </p>
  <p>
    <br />
  </p>
  <pre>&lt;identity configProtectionProvider="DataProtectionConfigurationProvider"&gt;<br />      &lt;EncryptedData&gt;<br />         &lt;CipherData&gt;<br />         &lt;CipherValue&gt;AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAA7u6qyggiVEWZH1w2do<br />	uWtAQAAAACAAAAAAADZgAAqAAAABAAAACN/yNj4qnBeU46Mh36dLsPAAAAAASAA<br />	ACgAAAAEAAAAF3wxPtL4ASVWtdEijF3qKWQAAAApI9StqOjTP2nUvuSknB9lM9S<br />	R7FP87 KyKEo8Ois06Y2D2JQ4Uoxjw4nvzBdKIPH4zg7G3jvqipUBSu7chNKf8p<br />	eB+SVLNP5HS/X+U/g8I3YHr1ZIwujL8fth/RT9ZJ OuHnN5KNnFQa2mIf2s4x9v<br />	aiHGE9C/oR0M8BaJI+LPQZ2WiKUMDL1+QlshvwinZ6ZbFAAAAKt8BPqp8BfOuGo<br />	BybD1QuHtjNJG&lt;/CipherValue&gt; </pre>
  <pre>         &lt;/CipherData&gt;<br />      &lt;/EncryptedData&gt;<br />   &lt;/identity&gt; </pre>
  <p>For more information about using Aspnet_regiis.exe, see How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI and How To: Encrypt Configuration Sections in ASP.NET 2.0 Using RSA. </p>
  <p>
    <b>Note</b> Web farm deployments should use RSA encryption. <b>Note</b> If you have included credentials in the &lt;identity&gt; element and your application runs on Windows 2003 Server with IIS 6.0, then consider using custom application pools configured to run under a specific domain identity. </p>
  <h1>&lt;H&gt;Step 8. Review &lt;authorization&gt; Settings &lt;/H&gt;</h1>
  <p>The &lt;authorization&gt; element controls ASP.NET URL authorization and the ability of Web clients to gain access to specific folders, pages, and resources. </p>
  <p>Are you denying anonymous access to protected pages? Verify that only authenticated users are allowed to access protected pages by checking that the users attribute is set to "?", as shown in the following example </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;authorization&gt;<br />   &lt;deny users="?"/&gt;<br /> &lt;/authorization&gt;<br />&lt;/system.web&gt;... </pre>
  <p>Anonymous users should be denied access to protected pages. The preceding configuration ensures that only authenticated users can access the pages. </p>
  <h1>Step 9. Review &lt;roleManager&gt; Settings </h1>
  <p>ASP.NET version 2.0 provides role authorization APIs and a set of role manager providers to manage the role store. ASP.NET 2.0 applications should use role manager, rather than custom implementations, to reduce the amount of code that needs to be written and to help ensure secure implementation. </p>
  <p>If your application uses role manager, the enabled attribute of the &lt;roleManager&gt; attribute must be set to true and the defaultProvider attribute specifies which provider is used, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> ...<br /> &lt;roleManager enabled="true", defaultProvider="RoleProviderName" ... /&gt;<br /> ...<br />&lt;/system.web&gt;<br />...  </pre>
  <p>
    <b>Note</b> By default, role manager is disabled. When enabled, the default configuration uses a SqlRoleProvider that points to a SQL Server express instance. This configuration creates the role store database in a SQL Server express database in the \app_data directory after your application's virtual root directory. Use the following questions to review the role manager settings. </p>
  <p>Is the role manager connection string encrypted? Ensure that connection strings that point to your application's role store are encrypted. For more information about using the Aspnet_regiis utility to encrypt configuration sections, see "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA. </p>
  <p>Does your configuration use a unique applicationName for SqlRoleProvider? Unless you want a single role store to be shared by multiple applications, make sure that your application uses a unique applicationName setting. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager&gt;<br />   &lt;providers&gt;<br />     &lt;add applicationName="MyApplication" ... /&gt;<br />   &lt;/providers&gt;<br /> &lt;/roleManager&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>Is the roles cookie encrypted and checked for integrity? Check that the cookieProtection attribute is set to "All" for full protection, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager cookieProtection="All" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>
    <b>Note</b> cookieProtection="All" is the default setting. Full protection ensures that role cookies are encrypted, signed, and integrity checked. This makes certain that the contents of the cookie cannot be viewed or modified without detection. </p>
  <p>Does the configuration ensure SSL to secure the roles cookie? Check that the cookieRequireSSL attribute is set to true so that the roles cookie can only be transmitted over HTTPS connections (using SSL). </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager cookieRequireSSL="true" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>This setting prevents role cookies from being captured, viewed, and tampered with while crossing the network. </p>
  <p>
    <b>Note</b> This setting assumes that your Web application is configured to use SSL for those pages that require authenticated access. Is the roles cookie life time limited? If your site uses SSL to protect role cookies and you have set cookieRequireSSL=true, the default cookie life time of 30 minutes is recommended. However, if you cannot use SSL to protect role cookies, review the cookieTimeout attribute and consider reducing cookie life time. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager cookieTimeout="10" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>By reducing the cookie life time, you reduce the time during which an attacker who captures a role cookie can use it to gain unauthorized access to your application. </p>
  <p>Does the configuration use cookieSlidingExpiration? If you do not use SSL to protect role cookies and you are concerned about cookie hijacking, make sure that the cookieSlidingExpiration attribute is set to false, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager cookieSlidingExpiration="false" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>This setting ensures that an absolute expiration period exists after which the role cookie will no longer be valid. When cookieSlidingExpiration="true", the expiration period is reset after each Web request. By setting this attribute to false, you limit the time that an attacker can capture and modify the cookie and use it to perform unauthorized operations. </p>
  <p>Does the configuration set the createPersistentCookie attribute to false? Make sure that the roles cookie is not persisted on the client's computer by verifying that the createPersistentCookie attribute is set to false, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;roleManager createPersistentCookie="false"/&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>
    <b>Note createPersistentCookie="false" is the default setting.</b>
  </p>
  <h1>Step 10. Review &lt;sessionState&gt; Settings </h1>
  <p>The &lt;sessionState&gt; element configures user session state management for your application. </p>
  <p>Does your application use the SQL Server state store or the out-of-process session state service? If the application uses an out-of-process state server or SQL Server, the &lt;sessionState&gt; section contains sensitive connection string information. To protect this information, make sure that the &lt;sessionState&gt; section is encrypted. </p>
  <p>For more information about using the Aspnet_regiis utility to encrypt configuration sections, see "How To: Encrypt Configuration Settings in ASP.NET 2,0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA." </p>
  <h1>Step 11. Review &lt;machineKey&gt; Settings</h1>
  <p>The machineKey element specifies encryption algorithms and validation keys used to protect forms authentication cookies and page-level view state. Review your Web.config file by using the questions outlined below. </p>
  <p>Are the decryption and validation keys separate for each application? If you are running multiple applications on a single server and you do not want to permit an authentication ticket created by one application to provide access to another application, make sure that decryption and validation keys are unique for each application. The default setting shown here uses AutoGenerate,IsolateApps which ensures separate keys. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;machineKey validationKey="AutoGenerate,IsolateApps"<br />              decryptionKey="AutoGenerate,IsolateApps" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>By using separate keys for each application, you prevent cross application authentication and you make certain that one application's view state cannot be used by a different application. </p>
  <p>Does each server in your Web farm use the same decryption and validation keys? If you are running a single application in a Web farm, make sure that the same decryption and validation keys are used on each server. To do so, you must generate them manually and deploy them on each server in the farm. You can deploy the machineKey settings in your application's Web.config file or in the machine-level Web.config file. The following example shows manually generated keys. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;machineKey validationKey="ABCD234XYZwry/12256h7yf"<br />              decryptionKey="FGH34XYZwry/dfg902256h7zx" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>This allows requests coming to any physical server to use the same authentication cookie or view state. </p>
  <p>Is the validation attribute set to SHA1 or AES? To provide tamper-proof view state, check that validation="SHA1". When SHA1 is selected for the validation attribute, the algorithm used is HMACSHA1. If your application requires encrypted view state, check that validation="AES". If you use AES for encryption, the default SHA1 algorithm is used to provide tamper-proofing. </p>
  <p>For tamper proofing alone, use the following configuration: </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;machineKey validation="SHA1" ... /&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>SHA1 is recommended over MD5 because it produces a larger hash than MD5 and is considered cryptographically stronger. </p>
  <p>
    <b>Note</b> validation="SHA1" is the default setting. For encryption and tamper-proofing, use the following configuration: </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;machineKey validation="AES" ... /&gt;<br />&lt;/system.web&gt;<br />...   </pre>
  <p>Use of the validation attribute is overloaded. For more information about the &lt;machineKey&gt; element, see "How To: Configure MachineKey in ASP.NET 2.0." </p>
  <h1>Step 12. Review &lt;trust&gt; Levels </h1>
  <p>The &lt;trust&gt; element defines the trust level that your application runs under. The trust level determines the set of code access security permissions that your application is granted. This determines which operations it can perform and which types of resources it can access. </p>
  <p>Does your configuration lock the trust level? In a hosting environment, where you want to ensure a consistent and restricted trust level across all applications on your server, verify that the trust level configuration setting is locked in the machine-wide Web.config file by using a &lt;location&gt; element and by setting allowOverride to false as shown here. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;location allowOverride ="false"&gt;<br /> &lt;system.web&gt;<br />   &lt;trust level="Medium"/&gt;<br /> &lt;/system.web&gt;<br />&lt;/location&gt;<br />... </pre>
  <p>By locking the trust level, you prevent individual applications from overriding this setting with their own Web.config file configurations. </p>
  <p>Does your application use an appropriate trust level? An application with fewer permissions represents less risk in the event of a successful attack. In a hosting environment or in an environment where the applications cannot be trusted, the application should be given only the required permissions and nothing more. Start with medium trust and add permissions only as necessary. </p>
  <p>In an environment where you are willing to give the applications more trust (such as inside a corporate intranet), you could start with full trust and remove permissions that are not necessary. </p>
  <p>For more information about creating custom trust levels see, "How To: Use Code Access Security in ASP.NET 2.0." For more information about running applications at medium trust, see "How To: Use Medium Trust in ASP.NET 2.0." </p>
  <h1>Step 13. Prevent Download of Unused File Types</h1>
  <p>You should lock unused file types as early as possible to prevent their download. You can prevent download in IIS by mapping dynamic file types to the HttpForbiddenHandler class in your Web.config file. </p>
  <p>Does your configuration remove the MIME type mapping for unused file types in IIS? Check that the configuration has removed the MIME type mapping in IIS for any static file types that it does not require. </p>
  <p>Does your configuration lock down unused dynamic content in Web.config? For dynamic content types normally served by IIS—such as .asmx files—check that the file type has been mapped to the HttpForbiddenHandler class, as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;httpHandlers&gt;<br />   &lt;add verb="*" path="*.asmx" type="System.Web.HttpForbiddenHandler" ... /&gt;<br />&lt;/system.web&gt;<br />...</pre>
  <h1>Step 14. Verify that Credentials are Encrypted in &lt;processModel&gt; Settings </h1>
  <p>If credentials are set on the &lt;processModel&gt; element in the userName and password attributes, check that they are encrypted. The following example shows the &lt;processModel&gt; element with a custom account both before and after running Aspnet_setreg.exe to secure the credentials: </p>
  <p>
    <br />
  </p>
  <pre>&lt;processModel userName="CustomAccount" password="Str0ngPassword" ... /&gt;<br />		&lt;processModeluserName="registry:HKLM\SOFTWARE\YourApp\<br />		process\ASPNET_SETREG,userName"password="registry:HKLM\<br />		SOFTWARE\YourApp\process\ASPNET_SETREG,password" ... /&gt; </pre>
  <p>
    <b>Note</b> By default, IIS 6.0 runs applications inside application pools and the identity configured in the IIS Metabase determines the process identity. You only use the &lt;processModel&gt; element to store account credentials if your application runs on IIS 5 or if IIS 6 is configured for IIS 5.0 compatibility mode. To encrypt credentials on the &lt;processModel&gt; element, you use the Aspnet_setreg.exe tool. For more information about using the Aspnet_setreg tool to encrypt data in these configuration sections, see Microsoft Knowledge Base article 329290, "How to use the ASP.NET utility to encrypt credentials and session state connection strings." </p>
  <h1>Step 15. Review &lt;healthMonitoring&gt; Settings </h1>
  <p>ASP.NET 2.0 provides health monitoring. ASP.NET is instrumented for many standard events that you can use to monitor the health of your application. Examples of security related events that are automatically generated include logon failures and successes when using the ASP.NET membership system, attempts to tamper with or reuse forms authentication tickets, and infrastructure events such as disk access failures. </p>
  <p>Monitoring the health of your application is an important security task to enable the detection and prevention of attacks. Use the following questions to review health monitoring settings </p>
  <p>If your application uses SqlWebEventProvider, does it encrypt connection strings? If your application uses SqlWebEventProvider, make sure that the &lt;connectionStrings&gt; section that holds the provider database connection string is encrypted. For more information about using the Aspnet_regiis utility to encrypt configuration sections, see "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA. </p>
  <p>Are you vulnerable to a denial of service attack via excessive logging? If you are using SqlWebEventProvider, check that the maxEventsDetailsLength attribute is appropriately configured as shown here: </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;healthMonitoring&gt;<br />   ...<br />  &lt;providers&gt;<br />    &lt;add maxEventDetailsLength="5000" ... /&gt;<br />  &lt;/providers&gt;<br />   ...<br /> &lt;/healthMonitoring&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>If you are using SimpleMailWebEventProvider or TemplateMailWebEventProvider, the event size and length is governed by maxEventLengthForSimpleMessage and maxSizeForSimpleMessage attributes as shown in the following example. </p>
  <p>
    <br />
  </p>
  <pre>...<br />&lt;system.web&gt;<br /> &lt;healthMonitoring&gt;<br />   &lt;providers&gt;<br />      &lt;add maxEventLengthForSimpleMessage="5000",<br />           maxSizeForSimpleMessage="1024" .../&gt;<br />   &lt;/providers&gt;<br />   ...<br /> &lt;/healthMonitoring&gt;<br />&lt;/system.web&gt;<br />... </pre>
  <p>The default values for maxEventLengthForSimpleMessage and maxSizeForSimpleMessage are 5000 characters and 1024 KB, respectively. </p>
  <p>Configuration Per-Application or Per-Machine Some configuration changes only need to be completed once per machine, and others must be completed for each application individually. </p>
  <p>For each application, complete the following steps: </p>
  <ul>
    <li>Step 4. Verify that the &lt;compilation&gt; setting prevents debug compilations. 
<li>Step 5. Review &lt;forms&gt; authentication settings. 
<li>Step 6. Review &lt;membership&gt; settings when using forms authentication. 
<li>Step 7. Review &lt;identity&gt; and impersonation settings. 
<li>Step 8. Review &lt;authorization&gt; settings. 
<li>Step 9. Review &lt;roleManager&gt; settings. 
<li>Step 10. Review &lt;sessionState&gt; settings. 
<li>Step 11. Review &lt;machineKey&gt; settings. 
<li>Step 12. Review &lt;trust&gt; levels. 
<li>Step 13. Prevent download of unused file types. </li></li></li></li></li></li></li></li></li></li>
  </ul>
  <p>The following steps are typically checked once per machine, although the configuration settings they refer to can be overridden per application if necessary. </p>
  <ul>
    <li>Step 1. Verify that &lt;trace&gt; is disabled. 
<li>Step 2. Verify that &lt;customErrors&gt; mode is set to On. 
<li>Step 3. Review &lt;httpRuntime&gt; settings to limit the size of the request. 
<li>Step 11. Review &lt;machineKey&gt; settings. 
<li>Step 14. Verify that credentials are encrypted in &lt;processModel&gt; settings. 
<li>Step 15. Review &lt;healthMonitoring&gt; settings. </li></li></li></li></li></li>
  </ul>
  <p>Lock Per-Machine Settings You should lock per-machine settings so they cannot be overridden by an individual application. Once you have configured per-machine settings in your server's machine-level Web.config file in the %Windir%\Microsoft.NET\Framework\{version}\CONFIG directory you can lock down the settings by placing the &lt;system.web&gt; element inside a &lt;location&gt; element with allowOverride set to false. </p>
  <pre>...<br />&lt;location allowOverride="false"&gt;<br /> &lt;system.web&gt;<br />   &lt;authentication mode="Windows"/&gt;<br /> &lt;/system.web&gt;<br />&lt;/location&gt;</pre>
  <p>... </p>
  <p>Hosting Multiple Applications If you are hosting multiple ASP.NET applications on your server, there are some additional steps you should take. </p>
  <p>Use separate application pools for isolation. If you are using IIS 6.0, you should use application pools to isolate applications from each other. This limits the potential damage that can occur if an attack is successful on one of the applications on your server. Configure per-application trust levels. If you do not trust the deployed applications, you should also configure trust levels per application to further restrict the capabilities of each application. </p>
  <h1>Bin and Special Directories </h1>
  <p>In ASP.NET 1.1, the only special directory in your application's virtual root directory was Bin. With ASP.NET 2.0, the Bin directory does not necessarily hold code-behind assemblies. With the new dynamic compilation model, by default there are no code-behind assemblies. However, if you use pre-compilation then the precompiled assemblies end up in Bin directory. </p>
  <p>In addition to Bin, ASP.NET uses several special directories under the application root to maintain resources. The special directories are described in Table 2. </p>
  <p>Table 2 Special Directories Used by ASP.NET version 2.0 </p>
  <p>Directory Purpose /Bin (for backwards compatibility with ASP.NET 1.1). Contains application assemblies. Might contain: *.dll,*.pdb. /App_Code Contains application code automatically compiled by the runtime. May contain: *.cs, *.vb, *.js, *.cxx, *.wdsl, *.xsd, *.resource etc. /App_GlobalResources Contains resource files for the application. May contain: *.resx /App_LocalResouces Contains local resource files for the pages in the parent directory. May contain: *.resx /App_WebReferences Contains Web references for the application. /App_Data Contains data files for the application. This is where the MDB/SSE database can be stored (created by framework), along with application-specific data files (created by user). May contain: *.mdb, *.ldb, sse files. </p>
  <p>/App_Browsers Contains browser definition files. May contain: .browser /App_Themes Contains theme, skin, and servable image and css files. This directory is servable by ASP.NET. Http requests to this directory will succeed because this directory contains servable files, such as images and css style sheets. However, they are still subject to the HTTP handler mapping of the specific resource being requested-the theme files for example are mapped to HttpForbiddenHandler by default and are thus protected from download. </p>
  <p>
    <br />
  </p>
  <p>Content in these directories (apart from /App_Themes) is protected by ASP.NET 2.0. An ISAPI filter called ASPNET_FILTER.DLL performs directory filtering. This ensures that every request to a resource in a protected directory is blocked, regardless of whether or not the resource mapped in IIS to ASP.NET. </p>
  <h1>Additional Considerations</h1>
  <p>If the ASPNET_FILTER.dll component is removed or uninstalled or if filtering is disabled, the content in protected directories will become available. To address this potential issue, consider the following measures in IIS in order to further protect these directories. </p>
  <p>Removing Web Permissions. Use the IIS snap-in and ensure that the bin and other special directories (other than /App_Themes) do not have Read, Write, or Directory browsing permissions. Also ensure Execute permissions are set to None. Removing All Authentication Settings. Use the IIS snap-in to remove authentication settings from the special directories (other than /App_Themes). This results in all access being denied. </p>
  <h1>
    <span>IIS 6 Considerations </span>
  </h1>
  <p>Review the following IIS 6.0 configuration: </p>
  <p>Process account. Identify which application pool your application is running in and identify which identity the application pool uses to run. By default, application pools run using the Network Service account. This account has limited privileges but does have network credentials so you can use it to authenticate against network resources such as remote databases or file shares. Make sure that your application does not run using highly privileged accounts, such as the System account or administrator accounts. Application pools for application isolation. If you host multiple applications on he same server, use separate application pools to isolate the applications from each other. This limits the potential damage if an attack is successful on one of the applications on your server. </p>
  <h1>
    <span>Partial Trust Scenarios </span>
  </h1>
  <p>The two main scenarios for using code access security to constrain what an ASP.NET Web application can do are the following: </p>
  <ul>
    <li>
      <b>Hosting scenarios</b>. Internet service providers (ISPs) that need to host multiple applications from many different companies can use the Medium trust level to help make sure that applications cannot read each other's data or interfere with one another in any way. Medium trust also places restrictions on the types of shared system resources that the applications can access. Running at Medium trust with ASP.NET version 2.0 is easier than with ASP.NET version 1.1 because with ASP.NET 2.0, you have access to Microsoft SQL Server databases. Medium trust still provides a constrained environment for isolating applications from one another and from shared server resources. Medium trust applications have no registry access, no event log access, and no ability to use reflection. Web access is limited to the network address that you define in the &lt;trust /&gt; element, and file system access is limited to the application's virtual directory hierarchy. 
<li><b>Intranet departmental applications</b>. If your application does not use unmanaged code, you can consider using code access security to limit the capabilities of the application and to isolate multiple applications from one another on a shared server. To choose an appropriate trust level, examine each trust level, beginning with high trust. Look inside the high trust policy file, web_HighTrust.config. If your application requires fewer code access security permissions than those provided by the high trust level, move on to consider medium trust. Repeat the process, moving from medium trust to low trust to minimal trust, and keep evaluating the partial trust levels until you reach an exact match to your application's requirements or until your application's required permissions slightly exceed a partial trust level. </li></li>
  </ul>
  <p>If none of the pre-defined trust levels matches your applications precise permission requirements, you can create a custom policy file. For more information, see "How To: Use Code Access Security in ASP.NET 2.0." </p>
  <h1>
    <span>Encrypting Configuration Files </span>
  </h1>
  <p>ASP.NET 2.0 allows you to encrypt configuration file sections by using the protected configuration feature. The following sections of the configuration file should be encrypted if they exist to protect credentials and connection strings: </p>
  <p>&lt;connectionStrings&gt;. Encrypt the configuration section. ActiveDirectoryMembershipProvider. Encrypt the configuration section if it contains credentials. &lt;sessionState&gt;. Encrypt the configuration section if credentials are specified. &lt;identity&gt;. Encrypt the configuration section if credentials are specified. &lt;processModel&gt;. Encrypt the configuration section if credentials are specified. ASP.NET 2.0 protected configuration supports DPAPI and RSA encryption. For more information about how to encrypt sections within your Web.config file by using the Aspnet_regiis utility, see "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA". </p>
  <p>Note Web farm deployments should use RSA encryption. </p>
  <h1>
    <span>Web Farm Scenarios </span>
  </h1>
  <p>If you are deploying an application on multiple servers in a Web farm, be aware of the following additional considerations: </p>
  <p>If you are running a single application in a Web farm, and if you are using either ViewState or forms authentication, make sure that the same decryption and validation keys are used on each server. For more information, see "Step 11. Review &lt;machineKey&gt; Settings." If you are encrypting sections of your configuration file, use RSA rather than DPAPI encryption due to the ease with which RSA keys can be exported. For more information about how to encrypt sections within your Web.config file by using the Aspnet_regiis utility, see "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using DPAPI" and "How To: Encrypt Configuration Settings in ASP.NET 2.0 Using RSA" </p>
  <h1>
    <span>Obfuscation </span>
  </h1>
  <p>Standard security mechanisms prevent the download of your application's source code files, including .aspx, .ascx, or .asmx files, and any code-behind modules. However, a risk remains that an attacker could be able to circumvent security safeguards and view the source content. You can mitigate this risk by pre-compiling your Web site and then running an obfuscator on the compiled assemblies. You then deploy only the compiled, obfuscated assemblies, along with the normal configuration files and other static content such as HTML files and image files. </p>
  <p>To pre-compile the Web site, use the Aspnet_compiler.exe utility supplied with the .NET Framework version 2.0 SDK, or the Publish Web site tool in Microsoft Visual Studio® .NET 2005 development system </p>
  <p>To use the Aspnet_compiler.exe utility </p>
  <p>Open a Visual Studio .NET command prompt. Type the following command to pre-compile the Web site aspnet_compiler -p "C:\inetpub\wwwroot\myWebsite" -v / C:\Deployment </p>
  <p>The -p argument specifies the root folder of the source Web site. The -v parameter tells the compiler to resolve application root references. Copy the compiled assembly and all static content to the target directory: You can then obfuscate the assemblies and deploy the resulting directory structure at C:\Deployment to the target Web server. </p>
  <p>Note Pre-compiling alone offers very little protection because assemblies can be decompiled into source that very closely resembles the original source. Obfuscation offers additional (although not perfect) protection because it mangles symbols and rearranges code blocks. With enough time an attacker can defeat any obfuscation. However, it makes the attack more expensive. </p>]]></Data>
  </Content>
</TeamMentor_Article>