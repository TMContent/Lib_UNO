<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-887892873" Content_Hash="-210723897">
  <Metadata>
    <Id>25f3813f-3cf9-4f85-9e3d-aa4903b6a0df</Id>
    <Id_History>611a13c0-be4d-4032-b44e-694711d679cf,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Use Naming Conventions (Safe, Native, Unsafe) to Identify Unmanaged APIs</Title>
    <Category>Unmanaged Code</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Use Naming Conventions (Safe, Native, Unsafe) to Identify Unmanaged APIs</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Srinath Vasireddy, Ashish Babbar, Rico Mariani, and Alex Mackman</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>What to Do</h1>
  <p>Apply naming conventions so that you can be reminded of native code risks when you develop, review, or revise code. Categorize your unmanaged code by using a prefix to encapsulate the types of unmanaged APIs.</p>
  <h1>Why</h1>
  <p>Unmanaged code represents a significant risk if used improperly from managed code.</p>
  <h1>When</h1>
  <p>If you are calling into unmanaged code and have access to the source</p>
  <h1>How</h1>
  <p>Use the following naming convention. </p>
  <ul>
    <li>
      <b>Safe</b>. This identifies code that poses no possible security threat. It is harmless for any code, malicious or otherwise, to call. An example is code that returns the current processor tick count. Safe classes can be annotated with <b>SuppressUnmanagedCodeSecurityAttribute</b>, which turns off the code access security permission demand for full trust. <pre> [SuppressUnmanagedCodeSecurity]<br />class SafeNativeMethods {<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [DllImport("user32")]<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; internal static extern void MessageBox(string text);<br />}  </pre></li>
    <li>
      <b>Native</b>. This is potentially dangerous unmanaged code, but code that is protected with a full stack walking demand for the unmanaged code permission. These are implicitly made by the interop layer, unless they have been suppressed with <b>SupressUnmanagedCodeSecurityAttribute</b>. <pre>class NativeMethods {<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [DllImport("user32")]<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; internal static extern void FormatDrive(string driveLetter);<br />}  </pre></li>
    <li>
      <b>Unsafe</b>. This is potentially dangerous unmanaged code that has the security demand for the unmanaged code permission declaratively suppressed. These methods are potentially dangerous. Any caller of these methods must do a full security review to make sure that the usage is safe and protected because no stack walk is performed. <pre> [SuppressUnmanagedCodeSecurity]<br />class UnsafeNativeMethods {<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [DllImport("user32")]<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; internal static extern void CreateFile(string fileName);<br />}</pre></li>
  </ul>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>