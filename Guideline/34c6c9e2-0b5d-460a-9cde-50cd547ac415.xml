<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1181763181" Content_Hash="-1055803217">
  <Metadata>
    <Id>34c6c9e2-0b5d-460a-9cde-50cd547ac415</Id>
    <Id_History>a0f3f957-13a4-45bf-9801-e7498b81118c,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Do Not Propagate Exceptions While Impersonating</Title>
    <Category>Impersonation and Delegation</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Do Not Propagate Exceptions While Impersonating</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Andy Wigley, Kishore Gopalan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 2.0 </li>
  </ul>
  <h1>What to Do</h1>
  <p>Whenever possible, avoid programmatic impersonation.&amp;nbsp; If impersonation must be used, do not propagate or allow exceptions to propagate while impersonating another user.</p>
  <h1>Why</h1>
  <p>If exceptions occur while impersonating, it is possible for malicious code higher in the call stack to run using the impersonated identity.&amp;nbsp; This can present security issues, particularly if you impersonate a highly privileged account. </p>
  <h1>When</h1>
  <p>Any code that uses impersonation must prevent exceptions from propagating outside of the impersonating code. </p>
  <h1>How</h1>
  <p>If you must use programmatic impersonation, use structured exception handling and put the impersonation code inside try blocks.&amp;nbsp; Use a <strong>catch</strong> block to handle exceptions and use a <strong>finally</strong> block to ensure that the impersonation is reverted as shown here. </p>
  <pre>using System.Security.Principal;<br />...<br />WindowsIdentity winIdentity = new WindowsIdentity(username@domainName);<br />WindowsImpersonationContext ctx = winIdentity.Impersonate();<br />try{<br />  // Do work<br />}<br />catch(Exception ex){<br />  // Stop impersonating<br />  ctx.Undo();<br />}<br />finally{<br />  // Stop impersonating<br />  ctx.Undo();<br />}</pre>
  <p>By using a <b>finally</b> block, you ensure that the impersonation token is removed from the current thread whether an exception is generated or not.&amp;nbsp; Also be aware that if your code fails to catch exceptions, a malicious user could use exception filters to execute code that runs under the impersonated security context.&amp;nbsp; This is particularly serious if your code impersonates a privileged account.&amp;nbsp; If your code does not catch the exception, exception filters higher in the call stack are executed before code in your finally block is executed.&amp;nbsp; Furthermore, before using this code, ensure that only CLR-compliant exceptions (those derived from the <b>Exception</b> class) will be generated by the impersonation code.&amp;nbsp; If this is not the case, the <b>catch</b> clause will not catch the exception, and an exception filter could still gain access to the impersonation context.&amp;nbsp; If this is the case, add a second <b>catch</b> clause which does not specify the type of the exception at all; you will not have access to the exception details for logging, but you will prevent an elevation of privilege attack. </p>
  <p>
    <b>Note:</b> &amp;nbsp; &amp;nbsp; Exception filters are supported by Microsoft Intermediate Language (MSIL) and Visual Basic .NET. </p>
  <h1>Problem Example</h1>
  <p>A web site uses impersonation to connect to a billing database as a specific, highly privileged user.&amp;nbsp; The system has a modular design, and the impersonation module runs at a higher trust level than the surrounding code.&amp;nbsp; Exceptions propagate up from the impersonation module, however, and when an attacker finds a code injection flaw in higher level ASP code, they're able to induce an exception in the impersonation module and steal the impersonation token.&amp;nbsp; Token in hand, they can call directly into the protected database and cause considerable damage.&amp;nbsp; </p>
  <p />
  <h1>Solution Example</h1>
  <p>A web site uses impersonation to connect to a billing database as a specific, highly privileged user.&amp;nbsp; The system has a modular design, and the impersonation module runs at a higher trust level than the surrounding code.&amp;nbsp; Exceptions do not propagate up from the impersonation module, instead, they're caught by a catch block which stops the impersonation before rethrowing the exception if it can't be handled locally.&amp;nbsp; The catch block does not have a specifier, so that even if a non-standard exception (one not derived from the framework's Exception class)&amp;nbsp;is thrown, it will still be triggered.&amp;nbsp; A finally block is also present to ensure that the critical section can't exit without losing the impersonation token.&amp;nbsp; When an attacker finds a code injection flaw in higher level ASP code, they're able to induce an exception in the impersonation module, but the impersonation token is safe.&amp;nbsp; Without the token, they have no access to the database, and are contained.&amp;nbsp; </p>
  <p />
  <p />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>