<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1357477657" Content_Hash="-2085120570">
  <Metadata>
    <Id>9fb4b95e-dfe0-42fc-9e28-93beaec82d7c</Id>
    <Id_History>84bf5798-5868-4937-ad0f-ad64d5b6a7e9,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>Only Use Impersonation When Original Caller&amp;#39;s Security Context Is Required Downstream</Title>
    <Category>Windows Authentication</Category>
    <Phase>Implementation</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>Guideline</Type>
    <DirectLink>Only Use Impersonation When Original Caller&amp;#39;s Security Context Is Required Downstream</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Andy Wigley, Kishore Gopalan</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET 2.0 </li>
  </ul>
  <h1>What to Do</h1>
  <p>Only use impersonation if the original caller's security context is required for auditing or authorization in downstream tiers. </p>
  <h1>Why</h1>
  <p>If programmatic impersonation is not done properly, it can introduce security vulnerabilities.&amp;nbsp; It is difficult to get it correct, particularly in multithreaded applications.&amp;nbsp; When possible, use alternative approaches, such as a custom domain process identity for resource access.&amp;nbsp; You should avoid programmatic impersonation where possible for the following reasons: </p>
  <ul>
    <li>
      <p>It is easy to introduce errors because of thread switches where the thread impersonation token is not propagated across threads. </p>
    </li>
    <li>
      <p>Some programmatic techniques require you to store credentials which should be avoided. </p>
    </li>
    <li>
      <p>Some programmatic techniques require you to grant additional privileges to your process account, which you should avoid.&amp;nbsp; For example, you must grant your process account "Act as part of the operating system" if you call <strong>LogonUser</strong> on Windows Server 2000 or to obtain an impersonate-level token on Windows Server 2003 when you use the new <strong>WindowsIdentity</strong> constructor that generates a token from a user principal name. </p>
    </li>
    <li>
      <p>If exceptions occur while impersonating, it is possible for malicious code higher in the call stack to run using the impersonated identity.&amp;nbsp; This can present security issues, particularly if you impersonate a highly privileged account. </p>
    </li>
  </ul>
  <h1>When</h1>
  <p>The most common situations where you might require impersonation and delegation are: </p>
  <ul>
    <li>
      <p>
        <b>Impersonating the original caller.</b>&amp;nbsp; You want to access Windows resources that are protected with ACLs configured for your application's domain user accounts. </p>
    </li>
    <li>
      <p>
        <b>Impersonating the original caller programmatically.</b>&amp;nbsp; You want to access resources predominantly by using the application's process identity, but specific methods need to use the original caller's identity. </p>
    </li>
  </ul>
  <p>Do not use impersonation when you merely need to securely pass the identity of a user downstream, as opposed to their entire security context. </p>
  <p>Whenever possible, avoid impersonating a single user to gain access to resources. </p>
  <h1>How</h1>
  <p>Impersonation potentially very dangerous.&amp;nbsp; It is possible to use safely, but should be avoided when it is not absolutely required.&amp;nbsp; </p>
  <p>Do not use impersonation when you merely need to securely pass the identity of a user downstream, as opposed to their entire security context.&amp;nbsp; For instance, if a database backend needs to know the identity of the user connecting to it, the web front end can act as a trusted subsystem and authenticate and authorize users, passing the user id to the database over a secure connection instead of impersonating that user to the database.&amp;nbsp; Not only is not using impersonation in these cases more secure, it's also fasterâ€”impersonating a user in this situation prevents use of connection pools, adding a lot of overhead.</p>
  <p>Whenever possible, avoid impersonating a single user to gain access to resources.&amp;nbsp; A more appropriate solution is to either alter ACLs as needed so as to grant the application's normal process identity access, or to use a trusted subsystem solution where an intermediate point handles access control.&amp;nbsp; While care must be taken with both ACLs and trusted subsystems, they have the advantage of only providing the calling process the single specific ability they need, instead of allowing the process to do anything the impersonated identity can do. </p>
  <p>That said, here are some guidelines on using impersonation safely.&amp;nbsp; The first configuration is appropriate for scenarios in which the entire task must run as the connecting user.&amp;nbsp; The second configuration is appropriate for scenarios where a specific resource requires you to connect as the original user. </p>
  <h2>Impersonating the Original Caller</h2>
  <p>Configure IIS with Integrated Windows Authentication enabled and all other authentication methods disabled.&amp;nbsp; Configure your ASP.NET application by adding the following configuration to the <b>&lt;system.web&gt;</b> section of your application's Web.config file. </p>
  <pre>&lt;authentication mode="Windows" /&gt;<br />&lt;identity impersonate="true" /&gt;</pre>
  <p>With this configuration, ASP.NET impersonates the IIS authenticated user, and the ASP.NET request threads that execute your Web application's code have the impersonation token attached to them. </p>
  <p>While the above configuration ensures that all resource access is performed using the identity of the original caller, if you need to access specific resources such as local files by using the process identity, you can temporarily remove the impersonation token from the ASP.NET request thread by using the following code: </p>
  <pre>// Stop impersonationWindowsImpersonationContext <br />ctx = WindowsIdentity.Impersonate(IntPtr.Zero);<br />try <br />{  <br />	// Thread is now running under the process identity.  <br />	// Any resource access here uses the process identity.<br />}<br />finally <br />{  <br />	// Resume impersonation  <br />	ctx.Undo(); <br />}</pre>
  <h2>Impersonating the Original Caller Temporarily</h2>
  <p>To temporarily impersonate the original caller within a particular method, you need to obtain the <b>WindowsIdentity</b> object that represents the authenticated user, and then call its <b>Impersonate</b> method. </p>
  <p>
    <strong>1. Ensure that impersonation is disabled for your ASP.NET application</strong>. Use the following configuration in the Web.config file to disable impersonation: </p>
  <pre>&lt;identity impersonate="false" /&gt;</pre>
  <p>
    <strong>2. Obtain the authenticated token. </strong>Add the following code to the method that requires impersonation. </p>
  <pre>using System.Security.Principal;...</pre>
  <pre>
    <br />// Obtain the authenticated user's IdentityWindowsIdentity <br />winId = (WindowsIdentity)HttpContext.Current.User.Identity;<br />WindowsImpersonationContext ctx = null;try<br />{  <br />	// Start impersonating  <br />	tx = winId.Impersonate();  <br />	// Now impersonating  <br />	// Access resources using the identity of the authenticated user<br />}<br />// Prevent exceptions from propagating<br />catch{}<br />finally<br />{  <br />// Revert impersonation  <br />if (ctx != null)    <br />	ctx.Undo();<br />}<br />// Back to running under the default ASP.NET process identity</pre>
  <p>This code impersonates the original caller.&amp;nbsp; The original caller's identity is maintained in the HttpContext.Current.User.Identity object. </p>
  <p>Notice how the preceding code uses a finally block to ensure that impersonation is reverted even in the event of an exception.&amp;nbsp; The code also uses a catch block to ensure that an exception cannot propagate itself up the call stack while the thread is impersonating. </p>
  <br />
  <p />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>