<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-554873213" Content_Hash="-930094937">
  <Metadata>
    <Id>49c91688-5b0b-4b63-bc66-2d3dc5987c0d</Id>
    <Id_History>93ff55e9-c4bf-4aa8-abe1-2806deba73c2,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>How to Test for HTTP Replay Bugs</Title>
    <Category>Testing</Category>
    <Phase>Test</Phase>
    <Technology>Web Application</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for HTTP Replay Bugs</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<br />
  <h1>Applies to</h1>
  <ul>
    <li>Web services and applications written in any language (ASP, PHP, Java, and similar web-based languages)</li>
  </ul>
  <h1>Summary</h1>
  <p>During HTTP replay attacks, an adversary records and then <i>replays</i> an HTTP data transmission (sequence of HTTP packets.)&amp;nbsp; The most common purpose of this attack is to bypass authentication in order for the adversary to masquerade themselves as a legitimate user.</p>
  <p>The following steps are recommended in order to test for HTTP replay attacks:</p>
  <ul>
    <li>Step 1:&amp;nbsp; Understand Attack Scenarios. 
<li>Step 2:&amp;nbsp; Analyze Root Causes and Mitigations. 
<li>Step 3:&amp;nbsp; Start Testing and Exploring. 
<li>Step 4:&amp;nbsp; Tune Test Cases.</li></li></li></li>
  </ul>
  <h1>Step 1:&amp;nbsp; Understand Attack Scenarios</h1>
  <p>First, you need to understand the fundamental details of an HTTP replay attack.&amp;nbsp; The following scenario illustrates two common purposes for replay attacks:</p>
  <ul>
    <li>Replay Attack to Bypass Authentication. 
<li>Replay Attack to Repeat a Transaction.</li></li>
  </ul>
  <h2>Replay Attack to Bypass Authentication</h2>
  <p>During this scenario, a user (Bob) authenticates to a web application by submitting his email address and password.&amp;nbsp; The attacker (Eve) sniffs the network traffic between Bob and the web application and saves the HTTP packets exchanged during authentication (validating the user).&amp;nbsp; Eve then starts an HTTP connection with the web application and retransmits (replays) the sequence of saved packets (from Bob's authentication) to the server.&amp;nbsp; The server allows Eve to enter the application confusing her as Bob.</p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/DibujoA.jpg" />
  </p>
  <p>Figure 1 - Eve sniffs traffic between Bob and the web server and saves the authentication packets.</p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/DibujoB.jpg" />
  </p>
  <p>Figure 2 - Eve sends Bob's authentication packets to the application.&amp;nbsp;</p>
  <p>In detail:</p>
  <ol>
    <li>The attacker discovers a vulnerable web application. 
<li>The attacker decides on what client(s) to attack. 
<li>The attacker sniffs or monitors HTTP traffic between the victim and the server. 
<li>The attacker captures and saves HTTP packets for the victim and server authentication process. 
<li>The attacker starts an HTTP connection with the server. 
<li>The attacker sends the captured packets (victim's auth packets) to server.</li></li></li></li></li></li>
  </ol>
  <h2>Replay Attack to Repeat a Transaction</h2>
  <p>In the second scenario the attacker's goal is to execute an action in addition to bypassing authentication.&amp;nbsp; During this scenario, the attacker also intercepts network traffic between an HTTP client and server.&amp;nbsp; While monitoring the traffic, the attacker captures and saves packets that represent a specific transaction, or which store certain information about these packets.&amp;nbsp; The attacker then connects to a vulnerable server (this can be the same server he sniffed from or another server susceptible to this vulnerability.) Finally the attacker sends the saved packets (or new packets containing the specific data from the saved packets<a style="mso-endnote-id: edn1" name="_ednref1" href="about:blank#_edn1" title="">[i]</a>) in order to carry out a particular transaction such as purchasing items or modifying account information.</p>
  <p>In detail:</p>
  <ol>
    <li>The attacker discovers a vulnerable web application. 
<li>The attacker decides on what client victim(s) to attack. 
<li>The attacker decides what transaction to carry out 
<li>The attacker decides on what client or clients to attack depending on the transaction he has in mind. 
<li>The attacker sniffs or monitors HTTP traffic between the victim(s) and the server (note in this case, it can be a different server than the server used to obtain the packets used in first place). 
<li>The attacker captures and saves HTTP packets or particular parts of packets that he will later use to execute the fraudulent transaction. 
<li>The attacker starts an HTTP connection with the vulnerable server. 
<li>The attacker replays the saved packets or sends new packets with particular information crafted from the sniffed data to carry out the fraudulent transaction on the victim's behalf.</li></li></li></li></li></li></li></li>
  </ol>
  <h1>Step 2:&amp;nbsp; Analyze Root Cause and Mitigations</h1>
  <p>Once you understand replay attack scenarios, the next step is to analyze what causes them.&amp;nbsp; In doing so, you will also learn how applications protect against this attack.&amp;nbsp; Knowing the root cause of security vulnerabilities helps you to identify them in both design and implementation (source code.) &amp;nbsp;In addition, understanding mitigations in detail tells you if the bug exists when you have the source code available.&amp;nbsp; When lacking source code access, knowing the mitigation techniques helps to guide security testing for this bug; any poorly implemented mitigation will lead to an HTTP replay vulnerability.<b><i>&amp;nbsp;</i></b></p>
  <h2>Root Cause</h2>
  <p>The cause for this bug is that HTTP systems perform legitimate new actions based on reused data.&amp;nbsp; For instance, as seen in the first scenario above, a server performs a legitimate new action (authenticate the attacker as the victim) based on reused data (captured victim auth packets.)</p>
  <h2>Mitigations</h2>
  <p>A web service can choose to protect against replay bugs by using <b><i>session tokens</i></b><i>. </i>&amp;nbsp;Before the client sends his email and password to the service, the client and server exchange a session token.&amp;nbsp; The password is hashed with the new session token before sending it to the server.&amp;nbsp; Since the server knows the password and the session token, it computes the hash separately and compares it against the hash value sent by the client.&amp;nbsp; The attacker receives a new session token when they connect to the server to execute the attack.&amp;nbsp; The attacker sends the previously captured password hash to the server but the server denies authentication because the attacker's sessions token is not valid.&amp;nbsp; A server can also prevent replay attacks using a <b><i>nonce </i></b>(<u>n</u>umber used <u>once</u>) along with Message Authentication Code (MAC).&amp;nbsp; The MAC is a hash of the nonce and the password along with a secret key for the transaction.&amp;nbsp; The server computes its own MAC since it knows the nonce, password, and transaction key and validates the client using its internal value.</p>
  <p>Another common mitigation is by using <b><i>timestamps</i></b>.&amp;nbsp;&amp;nbsp; If the attacker attempts to replay a transaction, the server realizes that the timestamp is from the past and rejects the replay attack. </p>
  <p>Applications can also use SSL to protect against replay attacks.&amp;nbsp; During SSL authentication the client and server use random data to generate the key for a specific connection.&amp;nbsp; Each message contains a MAC with the message's sequence number and the connection key.&amp;nbsp; An attacker will not be able to compute a valid MAC without knowing the connection key. </p>
  <h1>Step 3:&amp;nbsp; Start Testing and Exploring</h1>
  <p>Now that you've learned how HTTP replay attacks work and the reasons they exist, you must test for both secure and insecure implementations.</p>
  <h2>Basic HTTP replay test</h2>
  <p>The following steps illustrate how to test for HTTP replay attack bugs:</p>
  <ol>
    <li>Start capturing network traffic using Wireshark or a similar network sniffer (since you will use WebScarab to replay the packets you can use it for this step too.)<a style="mso-endnote-id: edn2" name="_ednref2" href="about:blank#_edn2" title="">[ii]</a><li>Open a browser and log in to the application site. 
<li>Stop capturing packets and save the HTTP packets that deal with authentication. 
<li>Log out of the application site and close the browser. 
<li>Start intercepting packets using WebScarab. 
<li>Repeat step 2. 
<li>Before the log in packet leaves your client machine, modify the contents of it with the packet contents saved in step 5.</li></li></li></li></li></li></li>
  </ol>
  <p>Expected result: The server recognizes the second log in attempt as a replay attack and denies access to the client's account.</p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/clip_image003.png" />
  </p>
  <p>
    <b>Figure 1 - Intercept requests for first login (as valid user) and record the entire login packet</b>
  </p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/clip_image004.png" />
  </p>
  <p>
    <b>Figure 2 - Replace selected raw data with auth data from bob (previous Figure) then click Accept changes</b>
  </p>
  <p>It is important that you understand the different server responses that a replay attack might generate. </p>
  <h2>Check if your application uses timestamps, session tokens, or nonces</h2>
  <ol>
    <li>Start capturing network traffic using Wireshark or similar tool (you can use WebScarab here too). 
<li>Open browser and log in to application site. 
<li>Save the capture of the log in process. 
<li>Analyze network packets and look for some indicator of a timestamp, a session token, or a nonce.&amp;nbsp; </li></li></li></li>
  </ol>
  <p>Expected result:&amp;nbsp; The application server uses a timestamp, a session token, or nonce during authentication.&amp;nbsp; Figure 3 shows a WebScarab capture showing a timestamp and a unique identifier (that can be understood as a nonce.)</p>
  <p>Note: Although this is a clear indicator that your application should prevent replay attacks, you should still replay this packet as in the previous test to see if this prevention actually works.</p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/clip_image005.png" />
  </p>
  <p>
    <b>Figure 3 - WebScarab capture showing the use of a timestamp and a nonce</b>
  </p>
  <p>
    <b>
      <i>
      </i>
    </b>
  </p>
  <h2>Test to check if the site uses SSL</h2>
  <ol>
    <li>Start capturing network traffic using Wireshark or a similar tool. 
<li>Open a browser and log in to the application site. 
<li>Save the capture of the log in process in Wireshark. 
<li>Use Wireshark (or a similar tool) to set a capture filter to show only "ssl" packets (Figure 4).</li></li></li></li>
  </ol>
  <p>Expected result:&amp;nbsp;&amp;nbsp; The server uses SSL for authentication and you can see an SSL handshake.&amp;nbsp; </p>
  <p>
    <img src="about:../../../LibrariesImages/4871408b-998c-4505-9b94-ce8e63c88b22/clip_image006.png" />
  </p>
  <p>
    <b>Figure 4 - WebScarab capture showing the use of a timestamp and a nonce</b>
  </p>
  <h1>Step 4:&amp;nbsp; Tune Test Cases</h1>
  <p>During this step you must test for additional payloads of this attack.&amp;nbsp; For example, record a specific transaction such as a purchase of an item or of specific services.&amp;nbsp; Then try to replay the transaction from outside a valid user session (without legitimate authentication.)&amp;nbsp; There are multiple replay attacks that you can try depending on what you have in mind.&amp;nbsp; Make sure to cover the following attacks (These are examples; specific scenarios relevant to your application should be tested):</p>
  <ul>
    <li>Bypassing authentication. 
<li>Purchasing an item. 
<li>Purchasing a service. 
<li>Viewing protected or confidential documents.</li></li></li></li>
  </ul>
  <p>Remember that to properly test for these different attacks you will need to record a specific sequence of packets and then retransmit the content of these packets to the application under test.&amp;nbsp; You can continue using WebScarab or switch to a tool such as TCPReplay in order to replay HTTP sequences of more than one packet.</p>
  <h1>Conclusions</h1>
  <p>Testing for replay attacks is necessary when securing any web application or service.&amp;nbsp; Start by understanding the anatomy of replay attacks.&amp;nbsp; Continue by learning how HTTP replay attacks are prevented, and see if your application uses any of these prevention methods.&amp;nbsp; If it doesn't, then the application is most likely to fail the basic test described in step 3 and be vulnerable to HTTP replay vulnerabilities.&amp;nbsp; For proper coverage, make sure to test the different mitigations and prevention mechanisms.&amp;nbsp; Finally, tune your test case data based on different payloads and transactions you want to execute as replay attacks.</p>
  <div>
    <hr />
  </div>
  <p>
    <a style="mso-endnote-id: edn1" name="_edn1" href="about:blank#_ednref1" title="">[i]</a> Advisory: Replay Attack Vulnerability on Sony's Instant Video Everywhere Service.&amp;nbsp; 12-31-2005. <a href="http://www.iptel.org/ive_vulnerability">http://www.iptel.org/ive_vulnerability</a></p>
  <p>
    <a style="mso-endnote-id: edn2" name="_edn2" href="about:blank#_ednref2" title="">[ii]</a> Download WebScarab. <a href="http://www.net-security.org/software.php?id=504">http://www.net-security.org/software.php?id=504</a></p>]]></Data>
  </Content>
</TeamMentor_Article>