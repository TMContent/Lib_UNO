<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1559594155" Content_Hash="1358393804">
  <Metadata>
    <Id>6792a052-b3fb-4fe8-abc2-1aa601ab43f6</Id>
    <Id_History>fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>How to Test for Client-side Validation Bypass Bugs in Java</Title>
    <Category>Testing</Category>
    <Phase>Test</Phase>
    <Technology>Java</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for Client-side Validation Bypass Bugs in Java</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    <span>Applies to</span>
  </h1>
  <ul>
    <li>J2EE applications and services</li>
  </ul>
  <p>
    <b>
      <span>
      </span>
    </b>
  </p>
  <h1>
    <span>Summary</span>
  </h1>
  <p>Web applications must validate client input in order to check for injection bugs such as SQL injection and cross-site scripting.<span></span>Many Web applications rely on client-side scripts that are sent to the client along with Web pages. The application uses these scripts to check for proper format of input data entered into Web forms at the client before the page is submitted to the server, avoiding a round trip for simple format checks such as email addresses, phone numbers, and ZIP codes.<span></span>During a client-side script validation bypass attack, the attacker modifies or annuls a client-side script that checks against malicious input in order to successfully submit the input and execute an attack on the application.</p>
  <p>It is recommended to follow these steps to test for client-side validation bypass bugs in J2EE:</p>
  <ul>
    <li>Step 1: Understand attack scenarios <li>Step 2: Analyze causes and countermeasures <li>Step 3: Start testing and exploring <li>Step 4: Execute additional testing</li></li></li></li>
  </ul>
  <h1>
    <span>Step 1: Understand attack scenarios</span>
  </h1>
  <p>First, it is necessary to understand how attackers exploit client-side validation bypass bugs.<span>&amp;nbsp;</span>Two common ways of bypassing client-side scripts are:</p>
  <ul>
    <li>Disabling a client-side script prior to submitting a request <li>Modifying validated data after submitting a request, using an HTTP proxy</li></li>
  </ul>
  <p>
    <b>
      <i>
        <span>
        </span>
      </i>
    </b>
  </p>
  <h2>
    <span>
      <em>Scenario 1: Disabling a Client-side Script Prior to Submitting a Request</em>
    </span>
  </h2>
  <p>In this scenario, the attacker disables the client-side script by setting his browser options to disable JavaScript before making the actual request to the application server. By doing this, the attacker may submit any sequence of characters to the application.</p>
  <p>In detail:</p>
  <ol>
    <li>Attacker requests a Web page containing input fields, such as a Web form. The application sends a Web page with a client-side input validation script. <li>Attacker receives the Web page and annuls the client-side validation by disabling JavaScript in the browser. <li>Attacker enters malicious data in the input fields and submits the Web form.</li></li></li>
  </ol>
  <p>Note, however, that many applications, including AJAX-based applications, rely on JavaScript capabilities, so the attacker might be unable to submit the form with JavaScript disabled. If this is the case, the attacker needs to execute the following attack.</p>
  <h2>
    <em>Scenario 2: Modifying Validated Data after Submitting a Request by using an HTTP Proxy</em>
  </h2>
  <p>In this scenario, the attacker doesn&amp;#8217;t modify or disable the client-side script but instead proxies the browser through an HTTP packet-intercepting proxy such as Burp proxy or WebScarab. The attacker then enters well-formed input data into the target input fields and submits the request. The attacker then uses the proxy to intercept the request and change the well-formed input data into a malicious string.</p>
  <p>In detail:</p>
  <ol>
    <li>Attacker requests a Web page containing input fields, such as a Web form. The application sends a Web page with client-side input validation script. <li>Attacker proxies browser through HTTP proxy and enables HTTP packet interception. <li>Attacker enters well-formed (allowed) data in the input fields and then submits the Web form. Since the input is valid, the Web page makes a request to the application, which is intercepted by HTTP proxy. <li>In HTTP proxy, the attacker replaces the well-formed data with malicious data and forwards the packet to the application.</li></li></li></li>
  </ol>
  <h1>
    <span>Step 2: Analyze Causes and Countermeasures</span>
  </h1>
  <p>The second step in testing for client-side validation bypass bugs is to analyze what causes them and how to avoid them.</p>
  <p>This vulnerability exists because applications rely only on client-side checks for security-specific checks. Many applications send client-side scripts to reduce the number of round-trips between the client and the server.<span></span>For instance, the following code checks if an email address is valid before submitting a Web form. When a client clicks on the submit button, the JSP page invokes <strong>validateForm()</strong><em></em>to check for a valid email address before submitting the form:</p>
  <pre>
    <span>&lt;<a href="mailto:p&amp;#37;&amp;#64;page"><a href="mailto:&amp;#37;&amp;#64;page">&amp;#37;&amp;#64;page</a></a> contentType="text/html" pageEncoding="UTF-8"&amp;#37;&gt;<br />&lt;&amp;#33;DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"<br />&amp;nbsp;"<a href="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</a>"&gt;<br />&amp;nbsp;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;<br />&lt;title&gt;Java Search&lt;/title&gt;<br />&amp;nbsp; <br />&lt;script&gt;<br />function validateForm(emailStr)<br />&amp;#123;<br />&amp;#9;// checks if the e-mail address is valid<br />&amp;#9;var emailPat = "&amp;#94;&amp;#91;A-Za-z0-9._&amp;#37;&amp;#43;-&amp;#93;&amp;#43;&amp;#64;&amp;#91;A-Za-z0-9.-&amp;#93;&amp;#43;\\.&amp;#91;A-Za-z&amp;#93;&amp;#123;2,4&amp;#125;&amp;#36;";<br />&amp;#9;var matchArray = emailStr.match(emailPat);<br />&amp;#9;if (matchArray == null)<br />         &amp;#123;<br />&amp;#9;&amp;#9;alert("Incorrect email address format");<br />&amp;#9;&amp;#9;return false;<br />&amp;#9;&amp;#125;<br />&amp;#9;document.form1.action = "getProfile";<br />&amp;nbsp;&amp;nbsp; &amp;#9;document.form1.method = "POST";<br />&amp;nbsp;&amp;nbsp; &amp;#9;docuemnt.form1.submit();<br />&amp;nbsp;&amp;nbsp; &amp;#9;return true; <br />&amp;#125;<br />&lt;/script&gt;</span>
  </pre>
  <pre>
    <span>
      <br />&lt;body&gt;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&lt;form name="form1" action="getProfile" method="POST"<br /><strong>onsubmit="return validateForm(this.username.value);</strong>"&gt;<br />&amp;nbsp;<br />Email address: <br />&lt;input type="text" name="username" size="20"&gt;&lt;br/&gt;<br />&amp;nbsp;&amp;nbsp; Password: <br />&lt;input type="password" name="password" size="20"&gt;&lt;br/&gt;<br />&lt;input type="submit" value="Submit"&gt;<br />&amp;nbsp;<br />&lt;/form&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</span>
  </pre>
  <p>
    <span>
    </span>
  </p>
  <p>Note that the form invokes a server-side JSP method named <em>getProfile</em> through a validating JavaScript function that alerts the client if the input email address is in an incorrect format. By doing this, the developer avoids a round-trip to the server to check for valid email address formats.</p>
  <p>A problem arises when developers rely on this kind of check for protecting against application security attacks such as SQL injection, cross-site scripting, command injection, and similar attacks that require attackers to submit ill-intended input to the application.<span></span>Attackers can trivially bypass client-side checks, such as the one above, in order to attack the application.</p>
  <p>To protect against client-side bypass bugs, J2EE applications must perform proper validation at the server:</p>
  <pre>
    <span>private boolean validateEmail(String emailStr)<br />&amp;#123;<br />&amp;#9;String emailPat = "&amp;#91;A-Za-z0-9._&amp;#37;&amp;#43;-&amp;#93;&amp;#43;&amp;#64;&amp;#91;A-Za-z0-9.-&amp;#93;&amp;#43;\\.&amp;#91;A-Za-z&amp;#93;&amp;#123;2,4&amp;#125;"; <br />&amp;#9;if (&amp;#33;emailStr.matches(emailPat))<br />&amp;#9;&amp;#123;<br />&amp;#9;&amp;#9;return false;<br />&amp;#9;&amp;#125;<br />&amp;#9;return true;&amp;nbsp; <br />&amp;#125;<br />&amp;nbsp;<br />protected void processRequest(HttpServletRequest request,<br />&amp;#9;&amp;#9;&amp;#9;&amp;nbsp;HttpServletResponse response)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#9;&amp;#9;throws ServletException, IOException<br />&amp;#123;<br />&amp;nbsp;<br />&amp;#9;response.setContentType("text/html;charset=UTF-8");<br />&amp;#9;PrintWriter out = response.getWriter();<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp; &amp;#9;if (&amp;#33;validateEmail(request.getParameter("username")))<br />&amp;nbsp;&amp;nbsp; &amp;#9;&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#9;&amp;#9;out.println("Invalid email format");<br />&amp;#9;&amp;#125; <br />&amp;#9;else<br />&amp;nbsp;&amp;nbsp; &amp;#9;&amp;#123;&amp;nbsp; <br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#9;&amp;#9;// continue with authentication process...<br />&amp;#9;&amp;#125;</span>
  </pre>
  <pre>
    <span>&amp;#125;</span>
    <span>
      <span>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; </span>
    </span>
  </pre>
  <p>Note that the code above invokes the validating email function inside <em>processRequest</em>, which runs at the server. The request starts by checking if the email is in the correct format and stops the authentication process if it is not.</p>
  <h1>
    <span>Step 3: Start Testing and Exploring</span>
  </h1>
  <p>The next step in discovering client-side validation bypass bugs is to execute basic test cases from an attacker&amp;#8217;s perspective in order to discover&amp;nbsp;if they are successful in&amp;nbsp;your application.</p>
  <h2>
    <em>Test by Disabling JavaScript in Internet Browser</em>
  </h2>
  <p>Follow these steps to test for client-side validation bypass by disabling JavaScript:</p>
  <ol>
    <li>Open a browser and navigate to the Web page containing client-side validation script. <li>Open browser Options and navigate to security options. <li>Disable JavaScript and then click OK. <li>Submit ill-intended data in the Web form. </li></li></li></li>
  </ol>
  <p>Expected result: The application performs proper server-side validation and rejects the ill-intended data.&amp;nbsp;</p>
  <h2>
    <em>Test by Intercepting HTTP Request using a proxy</em>
  </h2>
  <p>Follow these steps to bypass client-side validation by modifying a Web page:</p>
  <ol>
    <li>Open a browser and navigate to a Web page containing a client-side validation script. <li>Download and execute Burp suite (<a href="http://portswigger.net/suite/">http://portswigger.net/suite/</a>). <li>In <em>Proxy-&gt;Intercept</em> tab, set proxy to &amp;#8220;<em>intercept is on</em>.&amp;#8221; <li>In browser, set connection options to use Burp proxy. <li>Fill in the Web page with allowed values, such as a valid email address. <li>Submit the Web page. <li>In Burp proxy, modify the intercepted request by changing the allowed values with malformed ones (see Figures 1 and 2 below). <li>Forward request.</li></li></li></li></li></li></li></li>
  </ol>
  <p>Expected result: The application must perform proper server-side validation and reject the ill-intended data.</p>
  <p>
    <span>
      <strong>
      </strong>
    </span>
    <span>
      <p />
      <h1>
        <span>Step 4: Execute Additional Testing</span>
      </h1>
      <p>The final step in testing for client-side validation bugs is to understand additional scenarios where testing is necessary.</p>
      <h2>
        <em>AJAX Applications are at High Risk</em>
      </h2>
      <p>AJAX (Asynchronous JavaScript and XML) applications rely heavily on client-side scripts. It is important to consider that it is impossible to disable JavaScript when testing for this bug in AJAX applications, as this will stop the browser from making requests; therefore, the use of a proxy is required with AJAX applications.</p>
      <h2>
        <em>Consider Additional Frameworks</em>
      </h2>
      <p>Web developers might integrate J2EE applications with other Internet frameworks such as Flash/Flex. This kind of framework might provide its own client-side forms with data validation options. Make sure to test Flash parameters for this vulnerability, as developers might rely on Web form validators such as Flex to validate their input at the client only, and fail to do so at the server.</p>
      <h1>
        <span>Conclusions</span>
      </h1>
      <p />Client-side validation bypass bugs allow attackers to submit malformed data that is not expected by the application in order to execute input-related attacks such as XSS and SQL injection. Applications are vulnerable when they rely on client-side scripts only to perform security checks instead of implementing these checks at the server. Testing can be done by disabling JavaScript or using an HTTP proxy, depending on the nature of the application under test (traditional, AJAX, Flash, etc).<span>&amp;nbsp;&amp;nbsp;</span></span>
  </p>
  <h1>Input and Data Validation Guidelines</h1>
  <ul>
    <li>
      <a href="/article/b531d29c-86f7-4812-90ce-5f3f0f780aba">Validate Input from All Sources</a>
    </li>
    <li>
      <a href="/article/c98695c5-cf02-44a1-96bf-1f8046b8ad9d">Validate Input for Length, Range, Format, and Type</a>
    </li>
    <li>
      <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">
        <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">Validate All Input Passed to the Database</a>
      </a>
    </li>
    <li>
      <a href="/article/a5491c44-164b-4046-94d3-b575b9745e8b">Filter All User-Supplied Filename and Path Input</a>
    </li>
    <li>
      <a href="/article/9f21442f-2aee-4573-8be6-a5b51d9c89b8">Do Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Checklists</h1>
  <ul>
    <li>
      <a href="/article/7f8deb21-cd52-41be-80b4-8897612021dc">Input from All Sources Is Validated</a>
    </li>
    <li>
      <a href="/article/61869793-2c10-40c0-b82a-babcc0312697">Input Is Validated for Length, Range, Format and Type</a>
    </li>
    <li>
      <a href="/article/42f4b565-14f7-42f4-8c5a-0f78f357e4c0">All Database Input Is Validated</a>
    </li>
    <li>
      <a href="/article/17884af0-fc83-412a-b613-4def4a6f84ad">User-Supplied Filenames and Paths Are Validated</a>
    </li>
    <li>
      <a href="/article/b1803c35-9579-4a38-9a63-30202160ef25">The Application Does Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Code Examples</h1>
  <ul>
    <li>
      <a href="/article/0f49430b-2abe-408f-b046-89fa739f5d53">Input Validation Using JSF</a>
    </li>
    <li>
      <a href="/article/18ac74df-602b-4a58-8998-52f638f3a045">Input Validation Using SpringMVC</a>
    </li>
    <li>
      <a href="/article/d124abb1-e230-43ef-8762-1caa0dbb89ca">Input Validation Using Struts 1</a>
    </li>
    <li>
      <a href="/article/2f917654-65a8-49c9-b000-c17f9765bf42">Input Validation Using Struts 2</a>
    </li>
    <li>
      <a href="/article/38342130-4e4b-47df-afd9-c7e8c86f77ee">Use ESAPI Executor</a>
    </li>
  </ul>
  <h1>Input and Data Validation Testing</h1>
  <ul>
    <li>
      <a href="/article/fd3ecaaa-cb7c-43a2-a91a-f19862f736d4">How to Test for Server-Side Code Injection in Java</a>
    </li>
    <li>
      <a href="/article/c00b9149-1290-4c9e-bcd0-392a9c5a6fb0">How to Test for Path Manipulation Bugs in Java</a>
    </li>
    <li>
      <a href="/article/5c99da7b-b4eb-4315-b48c-ac2598c13144">How to Test for Double Encoding Bugs in Java</a>
    </li>
    <li>
      <a href="/article/fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f">How to Test for Client-side Validation Bypass Bugs in Java</a>
    </li>
    <li>
      <a href="/article/6f4e927b-bd45-498b-95c4-78fd2c3287c1">How to Test for Integer Overflows in Java</a>
    </li>
    <li>
      <a href="/article/ed20009a-59ef-415d-8e72-0ff3221a1346">How to Test for Integer Underflow Bugs in Java</a>
    </li>
    <li>
      <a href="/article/d7682043-0095-4700-97dd-01ce797c4ada">How to Test for Deserialization of Untrusted Data Bugs in Java</a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>