<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-75023134" Content_Hash="1140063116">
  <Metadata>
    <Id>63af2003-44c3-41f1-b4a9-24b143cb5ed8</Id>
    <Id_History>63af2003-44c3-41f1-b4a9-24b143cb5ed8,7d0bdfe2-b936-40e3-8546-a6bc48baf7c8,</Id_History>
    <Library_Id>92718d53-36b2-47bc-b6f5-e60994385f46</Library_Id>
    <Title>How to Use APTCA</Title>
    <Category>Code Access Security</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 3.5</Technology>
    <Type>How To</Type>
    <DirectLink>How to Use APTCA</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Description</h1>
  <p>You can use APTCA to override the implicit link demand for full trust that is placed on every publicly accessible member of a strong-named assembly. APTCA is an assembly-level attribute, as shown in the following code example. </p>
  <pre> &#91;assembly: AllowPartiallyTrustedCallersAttribute()&#93;  </pre>
  <p>You should use APTCA only when necessary because APTCA increases the attack surface and exposes your code to partial trust callers. </p>
  <p>Use APTCA only if you specifically want partially trusted callers to use your strong-named assembly. For example, you might need an application running on a file share to access your assembly located in the global assembly cache. Also, only use APTCA if you have performed a thorough security code review, and your code has been rigorously audited for security vulnerabilities. Examine the resource access and other privileged operations performed by your assembly, and then consider authorizing access to these operations by using other code access security demands. </p>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>