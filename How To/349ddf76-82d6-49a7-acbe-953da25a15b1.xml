<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1829833043" Content_Hash="-1037380428">
  <Metadata>
    <Id>349ddf76-82d6-49a7-acbe-953da25a15b1</Id>
    <Id_History>5c99da7b-b4eb-4315-b48c-ac2598c13144,</Id_History>
    <Library_Id>c4b9cb6a-4561-4451-9b6c-4e59d73584f6</Library_Id>
    <Title>How to Test for Double Encoding Bugs in Java</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology>Java</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for Double Encoding Bugs in Java</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>J2EE Applications</li>
  </ul>
  <p />
  <h1>Summary</h1>
  <p>During a double encoding attack, the attacker encodes attack data twice using hex representation of a character (using methods known as percent encoding or URL encoding) so that the attack is not detected by security filters. This vulnerability is often used during SQL injection, cross-site scripting, and path traversal attacks in order to submit malicious data through request parameters. A vulnerable application decodes the attack data twice before it executes the malicious command. </p>
  <p>Follow these steps to test for double encoding bugs:</p>
  <ul>
    <li>Step 1: Understand attack scenarios <li>Step 2: Analyze causes and countermeasures <li>Step 3: Start testing and exploring <li>Step 4: Execute additional testing<br /></li></li></li></li>
  </ul>
  <p />
  <h1>Step 1: Understand attack scenarios</h1>
  <p>The first step in testing for double encoding vulnerabilities is to understand the common attack scenarios:</p>
  <ul>
    <li>Path traversal <li>Cross-site scripting (XSS) </li></li>
  </ul>
  <h2>
    <em>Scenario 1: Path Traversal</em>
  </h2>
  <p>During a path traversal attack, an attacker needs to traverse a directory in order to find a secret document:</p>
  <pre>http://victim/documents/getDocs.jsp?docname=../../secret.pdf </pre>
  <p />
  <p>However, the page <i>getDocs.jsp</i> filters out the filename provided in the URL and denies any sequence of two dots followed by a slash: <em>../</em> . To get around this, the attacker replaces the dots and slashes with their URL-encoded equivalent (<em>&amp;#37;2e</em> and <em>&amp;#37;2f</em>, respectively):</p>
  <pre>&amp;#37;2e&amp;#37;2e&amp;#37;2f&amp;#37;2e&amp;#37;2e&amp;#37;2fprivate/secret.pdf</pre>
  <p>However, the application also recognizes the sequence <i>&amp;#37;2e&amp;#37;2e&amp;#37;2f</i> as a path traversal construct, and denies the attack string. So the attacker executes a double encoding attack by re-encoding the percent (<em>&amp;#37;</em>) character with its URL-encoded equivalent (<em>&amp;#37;25</em>):</p>
  <pre>&amp;#37;252e&amp;#37;252e&amp;#37;252f&amp;#37;252e&amp;#37;252e&amp;#37;252fprivate/secret.pdf</pre>
  <p>A vulnerable application decodes the malicious string twice, translating it to a path traversal string to complete the attack.</p>
  <h2>
    <em>Scenario 2: Cross-site Scripting</em>
  </h2>
  <p>During a cross-site scripting attack, an attacker needs to submit special characters like pointed brackets, slashes, and backslashes. The attacker might first try to execute a string like this:</p>
  <pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
  <p>If the above string doesn&amp;#8217;t work, the attacker might try to URL encode special characters one time:</p>
  <pre>&amp;#37;3Cscript&amp;#37;3Ealert('XSS')&amp;#37;3C&amp;#37;2Fscript&amp;#37;3E</pre>
  <p>However, the application disallows this string because it contains dangerous URL-encoded characters such as <i>&amp;#37;3C and &amp;#37;3E.</i> Next, the attacker tries double encoding the attack string:</p>
  <pre>&amp;#37;253Cscript&amp;#37;253Ealert('XSS')&amp;#37;253C&amp;#37;252Fscript&amp;#37;253E</pre>
  <p>Note that the new construct doesn&amp;#8217;t contain singly encoded dangerous hex characters like <em>&amp;#37;3C</em>. The application recognizes the string as safe, and, because it is vulnerable to double encoding, it double decodes the string, translating it to the original XSS construct.</p>
  <p />
  <h1>Step 2: Analyze causes and countermeasures</h1>
  <p>The next step in testing for double encoding bugs is to understand what causes them and how to protect against them.</p>
  <p>Some applications protect against malicious input by filtering out dangerous characters. Any incoming string is checked against a list, known as a <i>blacklist</i>, of dangerous constructs<i>. </i>If the input contains a blacklisted construct like &amp;#8220;../&amp;#8221;, the application doesn&amp;#8217;t allow the operation. For instance, the following code implements a blacklist check in <i>exsistsInBlacklist:</i></p>
  <pre>if (existsInBlacklist(request.getParameter("filename") == false))&amp;nbsp;&amp;nbsp; &amp;nbsp;             (1)<br />&amp;#123;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp;String filename = new String();<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;URLDecoder decoder = new URLDecoder();<br />&amp;nbsp;<br />&amp;nbsp;filename = decoder.decode(request.getParameter("filename").toString(), "UTF-8"); (2)<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp;File file = new File(filename);<br />&amp;nbsp;/&amp;#42; continue opening file &amp;#42;/<br />&amp;nbsp;<br />&amp;#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;</pre>
  <p>To protect against path traversal, an application needs to include double-encoded character sequences such as <em>&amp;#37;252e&amp;#37;252e&amp;#37;252f</em> in its blacklist. Failing to do so would lead to a double encoding vulnerability. A better option would be implementing the check for a malicious construct on the canonical form. However, blacklists are not recommended because they must account for 100&amp;#37; of dangerous constructs; any dangerous construct not covered in the blacklist allows attacks on the application.</p>
  <p />
  <p>Therefore, to protect against this vulnerability, use a <i>whitelist</i> approach. Whitelists allow only valid constructs; any construct not in the whitelist is automatically disallowed. This way, developers need only define what is good, and don&amp;#8217;t have to worry about covering 100&amp;#37; of all dangerous constructs. For instance, the code below enforces a whitelist that uses a regular expression to check for safe input filenames. The regular expression allows only filenames of five to eight upper- or lower-case letters followed by the <em>.pdf</em> string. Any string that doesn&amp;#8217;t match this form, like the path traversal string <em>../</em> , causes the application to produce an error message:</p>
  <p />
  <pre>String filename = new String();<br />URLDecoder decoder = new URLDecoder();<br />filename = decoder.decode(request.getParameter("filename").toString(), "UTF-8");&amp;nbsp; <strong>(1)</strong><br /><br /><br />String safeConstruct = "&amp;#94;&amp;#91;a-zA-Z&amp;#93;&amp;#123;5,8&amp;#125;.pdf&amp;#36;";<br />Pattern regexPattern =&amp;nbsp; Pattern.compile(safeConstruct);<br />Matcher regexMatcher = regexPattern.matcher(filename);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                 <strong>(2)<br /></strong><br />if (&amp;#33;regexMatcher.find())<br />&amp;#123;<br />&amp;nbsp;out.println("invalid input");<br />&amp;#125;<br />else<br />&amp;#123;<br />&amp;nbsp;File file = new File(filename);<br />&amp;nbsp;/&amp;#42; continue opening file &amp;#42;/<br /> ...<br />&amp;#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;</pre>
  <p>Note that the code uses the whitelist approach on the canonical form of the input. It first decodes the input (1) and then calls the regular expression on the decoded input (2).</p>
  <h1>Step 3: Start Testing and Exploring</h1>
  <p>Now that you&amp;#8217;ve looked at double encoding attack scenarios and understand what causes them and how to protect against them, it is necessary to include double encoding issues when testing for different security issues.&amp;nbsp; </p>
  <h2>
    <em>Test for Double Encoding During Path Traversal</em>
  </h2>
  <p>Follow these steps to test for double encoding bugs during path traversal attacks:</p>
  <ol>
    <li>Identify all locations in the application where the input is used to find a file on the server. <li>Submit path traversal attack strings (for more information, see Testing for Path Traversal Bugs)<i></i>on all such locations<i>. </i>Modify any path traversal attack string with a double-encoded string.<i>&amp;nbsp;&amp;nbsp; </i><li>Check if the path is traversed.</li></li></li>
  </ol>
  <p />
  <p>Expected results: None of the paths should be traversed.</p>
  <p>
    <strong>Example Attack Strings:</strong>
  </p>
  <p>
    <table>
      <tbody>
        <tr>
          <td>
            <p>
              <b>Attack String&amp;#42;</b>
            </p>
          </td>
          <td>
            <p>
              <b>Single encoding</b>
            </p>
          </td>
          <td>
            <p>
              <b>Double encoding</b>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>../../..</p>
          </td>
          <td>
            <p>..&amp;#37;2F..&amp;#37;2F..</p>
          </td>
          <td>
            <p>..&amp;#37;252F..&amp;#37;252F..</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>../../..</p>
          </td>
          <td>
            <p>&amp;#37;2E&amp;#37;2E&amp;#37;2F&amp;#37;2E&amp;#37;2E&amp;#37;2F&amp;#37;2E&amp;#37;2E</p>
          </td>
          <td>
            <p>&amp;#37;252E&amp;#37;252E&amp;#37;252F&amp;#37;252E&amp;#37;252E&amp;#37;252F&amp;#37;252E&amp;#37;252E</p>
          </td>
        </tr>
      </tbody>
    </table>
  </p>
  <p>
    <b>
      <i>&amp;nbsp;&amp;#42;</i>
    </b>Note that the same attack string can be single encoded differently. This applies to all of the remaining attacks.</p>
  <h2>
    <em>Test for Double Encoding during Cross-site Scripting (XSS)</em>
  </h2>
  <p>Follow the next steps to test for double encoding bugs during cross-site scripting:</p>
  <ol>
    <li>Identify all locations in the application where the input is<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; a) reflected from web forms,<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; b) URL parameters, or<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; c) loaded from a persistent store such as a database. <li>Submit XSS attack strings (for more information, see <i>Testing for Cross-Site Scripting (XSS) Bugs</i>) on all such locations<i>.</i><li>Modify any URL-encoded XSS attack string with a double-encoded string.<i>&amp;nbsp;&amp;nbsp; </i><li>Reload the page containing the modified location and check if the injected script executes.</li></li></li></li>
  </ol>
  <p>&amp;nbsp;Expected results:&amp;nbsp;None of the injected scripts should execute.</p>
  <p>
    <strong>Example Attack Strings:</strong>
  </p>
  <p>
    <table>
      <tbody>
        <tr>
          <td>
            <p>
              <b>Attack String</b>
            </p>
          </td>
          <td>
            <p>
              <b>Single encoding</b>
            </p>
          </td>
          <td>
            <p>
              <b>Double encoding</b>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&lt;script&gt;alert('XSS')&lt;/script&gt;</p>
          </td>
          <td>
            <p>&amp;#37;3Cscript&amp;#37;3Ealert('XSS')&amp;#37;3C&amp;#37;2Fscript&amp;#37;3E</p>
            <p>&amp;nbsp;</p>
          </td>
          <td>
            <p>&amp;#37;253Cscript&amp;#37;253Ealert('XSS')&amp;#37;253C&amp;#37;252Fscript&amp;#37;253E</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>&gt;"'&gt;&lt;img src='javascript:alert('XSS');"&gt;</p>
          </td>
          <td>
            <p>&amp;#37;3E&amp;#37;22&amp;#37;27&amp;#37;3E&amp;#37;3Cimg&amp;#37;20src&amp;#37;3D&amp;#37;27javascript&amp;#37;3Aalert&amp;#37;28&amp;#37;27XSS&amp;#37;27&amp;#37;29&amp;#37;3B&amp;#37;22&amp;#37;3E</p>
          </td>
          <td>
            <p>&amp;#37;253E&amp;#37;2522&amp;#37;2527&amp;#37;253E&amp;#37;253Cimg&amp;#37;2520src&amp;#37;253D&amp;#37;2527javascript&amp;#37;253Aalert&amp;#37;2528&amp;#37;2527XSS&amp;#37;2527&amp;#37;2529&amp;#37;253B&amp;#37;2522&amp;#37;253E</p>
          </td>
        </tr>
      </tbody>
    </table>
    <b>
      <i>
      </i>
    </b>
  </p>
  <h2>
    <em>Test for Double Encoding during SQL Injection</em>
  </h2>
  <p>Follow the next steps to test for double encoding bugs during SQL injection scripting:</p>
  <ol>
    <li>Identify all locations in the application where input is<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; a) reflected from web forms,<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; b) URL parameters,<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; c) GUIs, or<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; d) loaded from a persistent store such as a database. <li>Submit SQ<i>L injection strings </i>(for more information, see <i>Testing for SQL Injection Bugs</i>) on all such locations<i>.</i><li>Modify any URL-encoded SQL injection attack string with a double-encoded string.<i>&amp;nbsp;&amp;nbsp; </i><li>Check if the application processed the injected SQL statement.</li></li></li></li>
  </ol>
  <p>&amp;nbsp;Expected results: None of the injected statements should be allowed.</p>
  <p>
    <i>Example Attack Strings:</i>
  </p>
  <p>
    <table>
      <tbody>
        <tr>
          <td>
            <p>
              <b>Attack String</b>
            </p>
          </td>
          <td>
            <p>
              <b>Single encoding</b>
            </p>
          </td>
          <td>
            <p>
              <b>Double encoding</b>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <p>a' or 1=1--</p>
          </td>
          <td>
            <p>a&amp;#37;27&amp;#37;20or&amp;#37;201&amp;#37;3D1--</p>
          </td>
          <td>
            <p>a&amp;#37;2527&amp;#37;2520or&amp;#37;25201&amp;#37;253D1--</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>') or ('a'='a</p>
          </td>
          <td>
            <p>&amp;#37;27&amp;#37;29&amp;#37;20or&amp;#37;20&amp;#37;28&amp;#37;27a&amp;#37;27&amp;#37;3D&amp;#37;27a</p>
          </td>
          <td>
            <p>&amp;#37;2527&amp;#37;2529&amp;#37;2520or&amp;#37;2520&amp;#37;2528&amp;#37;2527a&amp;#37;2527&amp;#37;253D&amp;#37;2527a</p>
          </td>
        </tr>
      </tbody>
    </table>
  </p>
  <h1>Step 4: Execute Additional Testing</h1>
  <p>The final step in testing for double encoding vulnerabilities is to make sure to look for them when executing any attacks that use hex character encoding. Additional attacks may include:</p>
  <ul>
    <li>XML injection <li>LDAP injection <li>Command injection <li>HTTP response splitting <li>URL parameter tampering <li>XPath injection</li></li></li></li></li></li>
  </ul>
  <h1>Conclusions</h1>
  <p>Attackers commonly use double encoding bugs to bypass security filters when attacking the application through HTTP request parameters. To test for double encoding bugs, you must understand the attack scenarios as well as what causes them and how to defend against them. Apply this knowledge when testing for request parameter bugs such as XSS, SQL injection, and path traversal. Finally, include double encoding test cases for any security vulnerability payloads tested via HTTP request parameters.</p>
  <h1>Input and Data Validation Guidelines</h1>
  <ul>
    <li>
      <a href="/article/b531d29c-86f7-4812-90ce-5f3f0f780aba">Validate Input from All Sources</a>
    </li>
    <li>
      <a href="/article/c98695c5-cf02-44a1-96bf-1f8046b8ad9d">Validate Input for Length, Range, Format, and Type</a>
    </li>
    <li>
      <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">
        <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">Validate All Input Passed to the Database</a>
      </a>
    </li>
    <li>
      <a href="/article/a5491c44-164b-4046-94d3-b575b9745e8b">Filter All User-Supplied Filename and Path Input</a>
    </li>
    <li>
      <a href="/article/9f21442f-2aee-4573-8be6-a5b51d9c89b8">Do Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Checklists</h1>
  <ul>
    <li>
      <a href="/article/7f8deb21-cd52-41be-80b4-8897612021dc">Input from All Sources Is Validated</a>
    </li>
    <li>
      <a href="/article/61869793-2c10-40c0-b82a-babcc0312697">Input Is Validated for Length, Range, Format and Type</a>
    </li>
    <li>
      <a href="/article/42f4b565-14f7-42f4-8c5a-0f78f357e4c0">All Database Input Is Validated</a>
    </li>
    <li>
      <a href="/article/17884af0-fc83-412a-b613-4def4a6f84ad">User-Supplied Filenames and Paths Are Validated</a>
    </li>
    <li>
      <a href="/article/b1803c35-9579-4a38-9a63-30202160ef25">The Application Does Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Code Examples</h1>
  <ul>
    <li>
      <a href="/article/0f49430b-2abe-408f-b046-89fa739f5d53">Input Validation Using JSF</a>
    </li>
    <li>
      <a href="/article/18ac74df-602b-4a58-8998-52f638f3a045">Input Validation Using SpringMVC</a>
    </li>
    <li>
      <a href="/article/d124abb1-e230-43ef-8762-1caa0dbb89ca">Input Validation Using Struts 1</a>
    </li>
    <li>
      <a href="/article/2f917654-65a8-49c9-b000-c17f9765bf42">Input Validation Using Struts 2</a>
    </li>
    <li>
      <a href="/article/38342130-4e4b-47df-afd9-c7e8c86f77ee">Use ESAPI Executor</a>
    </li>
  </ul>
  <h1>Input and Data Validation Testing</h1>
  <ul>
    <li>
      <a href="/article/fd3ecaaa-cb7c-43a2-a91a-f19862f736d4">How to Test for Server-Side Code Injection in Java</a>
    </li>
    <li>
      <a href="/article/c00b9149-1290-4c9e-bcd0-392a9c5a6fb0">How to Test for Path Manipulation Bugs in Java</a>
    </li>
    <li>
      <a href="/article/5c99da7b-b4eb-4315-b48c-ac2598c13144">How to Test for Double Encoding Bugs in Java</a>
    </li>
    <li>
      <a href="/article/fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f">How to Test for Client-side Validation Bypass Bugs in Java</a>
    </li>
    <li>
      <a href="/article/6f4e927b-bd45-498b-95c4-78fd2c3287c1">How to Test for Integer Overflows in Java</a>
    </li>
    <li>
      <a href="/article/ed20009a-59ef-415d-8e72-0ff3221a1346">How to Test for Integer Underflow Bugs in Java</a>
    </li>
    <li>
      <a href="/article/d7682043-0095-4700-97dd-01ce797c4ada">How to Test for Deserialization of Untrusted Data Bugs in Java</a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>