<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-767201634" Content_Hash="1774935976">
  <Metadata>
    <Id>a5395b6e-24cd-4eae-83f6-9e3ec5cba7f9</Id>
    <Id_History>a90c57d4-5b34-4869-9f67-62fbcb28e02c,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Test for LDAP Injection Bugs</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology>Web Application</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for LDAP Injection Bugs</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    Applies to:
  </h1>
  <ul>
    <li>
      Applications that use Lightweight Directory Access Protocol (LDAP).&amp;nbsp; Usually these applications are developed using C/C++, ASP .Net, Java, PHP, Python, and Ruby.
    </li>
  </ul>
  <p>
    &amp;nbsp;
  </p>
  <h1>
    Summary
  </h1>
  <p>
    The Lightweight Directory Access Protocol (LDAP) is a protocol used to query and manage directory services running over TCP/IP. Corporate environments commonly use LDAP directory trees to store organizational information such as user accounts, office locations, organizational units, printers, and fax machines. To search LDAP trees, applications build queries consisting of LDAP search filters written in Prefix, or Polish, notation. &amp;nbsp;&amp;nbsp;LDAP search filters consist of a set of meta-characters such as parenthesis and logical operators such as ANDs and ORs (represented by ‘&amp;’ and ‘|’ respectively).&amp;nbsp; For instance, the following query returns a list of objects of type user, no matter what their unique identifier (uid) is:
  </p>
  <pre>(&amp;(objectClass=user)(uid=*))</pre>
  <p>
    For additional information about LDAP queries, RFC 1960 specifies LDAP search filters’ syntactic and semantic details.[i]
    &amp;nbsp;
  </p>
  <p>
    If an application passes unsanitized user data to build LDAP queries, an attacker is capable of injecting additional statements to the original query. LDAP injection vulnerabilities are exploited to execute arbitrary LDAP statements against the vulnerable directory service.&amp;nbsp; This vulnerability can occur with any version of LDAP since it affects the application connecting to the LDAP server and not the actual LDAP server. To properly test for LDAP injection vulnerabilities, it is recommended that you follow these steps:
  </p>
  <ul>
    <li>
      Step 1: Understand attack scenarios
      </li>
    <li>
        Step 2: Analyze causes and countermeasures
        </li>
    <li>
          Step 3: Start testing and exploring
          </li>
    <li>
            Step 4: Fine-tune test cases
          </li>
  </ul>
  <p>
    &amp;nbsp;
  </p>
  <h1>
    Step 1:&amp;nbsp; Understand Attack Scenarios
  </h1>
  <p>
    First, you must understand the details of LDAP injection attack scenarios. In common with SQL and XPath injection, there are two types of LDAP injection attacks:
  </p>
  <ul>
    <li>
      Normal LDAP injection
      </li>
    <li>
        Blind LDAP injection
      </li>
  </ul>
  <p>
    &amp;nbsp;
  </p>
  <h2>
    <em>Scenario 1: Normal LDAP Injection </em>
  </h2>
  <p>
    To properly follow this scenario, you must understand the background of LDAP queries and search filters. LDAP queries consist of search filters written in Prefix, or Polish, notation. For example, the following pseudo query checks if there is a client named “Bob” with the password set to “abc”:
  </p>
  <pre>find("cn=Bob &amp; password=abc")</pre>
  <p>
    The equivalent LDAP query is written in Prefix notation (meta-characters first):
    
    
  </p>
  <pre>find("(&amp;(cn=Bob)(password=abc))")</pre>
  <p>
    LDAP uses the following meta-characters to indicate Boolean conditions and group aggregations [ii]:
  </p>
  <table>
    <tbody>
      <tr>
        <td>
          <pre>Meta-char</pre>
        </td>
        <td>
          <pre>Meaning</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>&amp;</pre>
        </td>
        <td>
          <pre>Boolean AND</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>|</pre>
        </td>
        <td>
          <pre>Boolean OR</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>!</pre>
        </td>
        <td>
          <pre>Boolean NOT</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>=</pre>
        </td>
        <td>
          <pre>Equals</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>~=</pre>
        </td>
        <td>
          <pre>Approximately</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>&gt;=</pre>
        </td>
        <td>
          <pre>Greater than</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>&lt;=</pre>
        </td>
        <td>
          <pre>Lower than</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>*</pre>
        </td>
        <td>
          <pre>Any character</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>( )</pre>
        </td>
        <td>
          <pre>Grouping</pre>
        </td>
      </tr>
    </tbody>
  </table>
  <pre>
  </pre>
  <p>
    Now suppose that an application builds an LDAP query to check for authentication. The query checks if there are any LDAP entries with a common name <i>(cn)</i> and password <i>(userPassword)</i> corresponding to two input values.
  </p>
  <pre>(&amp;(cn=<strong>input_value1</strong>)(userPassword=<strong>input_value2</strong>))</pre>
  <p>
    To implement the LDAP query, a PHP page uses a web form to collect the 
    user
     and 
    pass 
    variables and build the login query:
  </p>
  <pre>searchlogin = "(&amp;(cn=" . $_POST['user'] . ")(userPassword=" . $_POST['pass'] . "))";</pre>
  <p>
    An attacker then uses the web form to pass the following values:
  </p>
  <pre>user = "<strong>*)(cn=*))(|(cn=*</strong>"</pre>
  <pre>password = "any"</pre>
  <p>
    As a result, the web application builds the following statement:
  </p>
  <pre>searchlogin = "(&amp;(cn=<strong>*)(cn=*))(|(cn=*</strong>)(userPassword=any)))"</pre>
  <p>
    This LDAP query is always <i>true</i>, leading to the attacker being able to bypass authentication without valid credentials.
  </p>
  <p>
    A similar variation of normal LDAP injection leads to information disclosure. An application uses a simple LDAP query to display personal information about a single user:
  </p>
  <pre>searchfilter = "(uid=" . $_GET['username'] . ")";</pre>
  <p>
    In normal conditions, such as with the client named 
    <i>
      Bob
    </i>
    , the application builds a safe query:
  </p>
  <pre>searchfilter = "(uid=Bob)";</pre>
  <p>
    However, an attacker can tamper with the 
    <i>
      username
    </i>
     parameter so that the resulting search filter looks like this:
  </p>
  <pre>searchfilter = "(uid=<strong>*</strong>)";</pre>
  <p>
    This results in the application replying to the attacker with personal information from all users of in the LDAP directory tree.
  </p>
  <h2>
    <em>Scenario 2: Blind LDAP Injection </em>
  </h2>
  <p>
    Similar to blind SQL or XPath injection, blind LDAP injection consists of using simple true or false comparisons to infer data from the LDAP directory tree.&amp;nbsp; 
  </p>
  <p>
    During this scenario an application displays the printer information[iii] using the following filter:
  </p>
  <pre>(&amp;(printerID=<strong>printer_id</strong>)(objectclass=printer))</pre>
  <p>
    The application uses a PHP page to build the LDAP query by obtaining the value of the 
    <i>
      printer_id
    </i><b></b>
    variable from the URL:
  </p>
  <pre>printerfilter = "(&amp;(printerID=" . $_GET['<strong>printer_id</strong>'] . ")(objectclass=printer))";</pre>
  <p>
    When a client passes the&amp;nbsp; 
    <i>
      HPLaserJet3015
    </i>
    
    
    in the
    
      <i>printerID </i>
    
    parameter the resulting LDAP query looks like this:
  </p>
  <pre>(&amp;(printerID=HPLaserJet3015)(objectclass=printer))</pre>
  <p>
    An attacker passes an additional AND condition to find out if the LDAD directory has an attribute named 
    accounts
    :
    
    
  </p>
  <pre>HPLaserJet3015)(users=*)) </pre>
  <p>
    This results in the application building the following filter:
  </p>
  <pre>(&amp;(printerID=<strong>HPLaserJet3015)(users=*))</strong>(objectclass=printer))</pre>
  <p>
    Only the first AND condition is processed, so the LDAP query returns <i>true</i> if the<i></i><i>
      users
    </i>
    attribute exists in the LDAP directory tree. If the 
    <i>
      users
    </i>
     attribute does indeed exist, the string below extends the attack by checking if there are any users named <i>root</i>:
  </p>
  <pre>HPLaserJet3015)(users=root)) </pre>
  <p>
    The query will return <i>true</i> if a user named <i>root</i> exists in the LDAP directory.
  </p>
  <h1>
    Step 2: Analyze Causes and Countermeasures
  </h1>
  <p>
    The next step in testing for LDAP injection vulnerabilities is to understand what causes them and how to defend against them.
  </p>
  <h2>
    <em>LDAP Injection Causes</em>
  </h2>
  <p>
    LDAP injection is caused by failure to properly validate and sanitize the parameters used in an LDAP query. LDAP applications work by initializing an LDAP connection with an LDAP server and submitting queries built from user-supplied data to the server. LDAP queries are commonly built by creating search filters based on direct user input from text fields, web forms, URL parameters, GUI elements, and indirect user input such as data from a file or database. Failing to check and sanitize the user input when constructing LDAP queries is the cause of this vulnerability.
  </p>
  <h2>
    <em>LDAP Injection Countermeasures</em>
  </h2>
  <p>
    To properly defend against LDAP injection attacks it is necessary to validate and sanitize any input data used when building LDAP search strings. There are two ways of validating and sanitizing user data: blacklisting and whitelisting.&amp;nbsp; Blacklisting consists of restricting any dangerous characters.&amp;nbsp; In the case of LDAP injection these characters need to include all meta-characters, especially the grouping parenthesis ( () ), AND operator (&amp;), and OR operator (|). However, blacklisting is not completely secure unless 100 percent of all dangerous variations are accounted for. As an alternative, whitelisting consists of listing safe constructs only and rejecting any construct that does not match the safe form. Whitelisting is not concerned with accounting for all dangerous variations; whitelists just indicate what is safe, and any input that does not match a safe form is automatically denied. &amp;nbsp;&amp;nbsp;However, care is needed when using this defense as whitelists may be difficult to properly implement.&amp;nbsp; &amp;nbsp;&amp;nbsp;The following examples present three expressions that act as whitelists for types (checks if input type is integer), emails, and domain values [iv]:
  </p>
  <pre>int userinput = Convert.ToInt32(Request.Querystring("userinput"))
string email = Regex.IsMatch(Request.Querystring("email")," ^.+@[^\.].*\.[a-z]{2,}$" )
string country = Request.Querystring("country") in {"USA", "UK"}</pre>
  <p>
    An additional LDAP injection countermeasure to be used on top of input validation and sanitization consists of strengthening permissions in the LDAP directory tree.&amp;nbsp; LDAP directory trees have different types of attributes and it is important to understand how these attributes work in order to decide what permissions to assign to them.&amp;nbsp; In addition, the access level used by the application to connect to the LDAP server should be the minimum required in order to reduce the potential impact of LDAP injection attacks.
  </p>
  <h1>
    Step 3: Start Testing and Exploring
  </h1>
  <p>
    Now that you are familiar with the LDAP injection attack scenarios and can recognize both its causes and countermeasures, you must continue by executing basic test cases while observing how the application reacts.
  </p>
  <h2>
    <em>Start with a simple test string</em>
  </h2>
  <p>
    Similarly to when testing for other injection bugs, the first test case must check if the application performs any validation for injection characters (in this case LDAP meta-characters). Therefore, it is recommended that you start with a simple test string such as this one:
  </p>
  <pre>|&amp;)(*! </pre>
  <p>
    Then look for any errors generated by the application. Specifically, you should look for error messages that indicate the execution of an invalid LDAP query, as this will be a sign that the test case data is being used as part of the query (and therefore LDAP injection is possible).&amp;nbsp; Once you have successfully injected LDAP meta-characters, you should move on to the following test cases.
  </p>
  <h2>
    <em>Testing for Normal LDAP Injection Authentication Bypass </em>
  </h2>
  <p>
    To test for authentication bypass using normal LDAP injection you should follow these steps:
  </p>
  <ol>
    <li>
      Open a client that uses LDAP for authentication (this can be a web browser if the LDAP application is implemented as a web application or a client LDAP application in traditional non-web LDAP client/server applications).
      </li>
    <li>
        Enter a string containing an additional command that changes the result of the LDAP authentication query to <i>true</i>.&amp;nbsp; For example:
        <ul><li><p>
                
                  admin*)((|userPassword=*) 
                
              </p></li><li><p />
                  *)(uid=*))(|(uid=*
                  &amp;nbsp;
                
                <p /></li></ul></li>
    <li>
          
            
              Submit the authentication form to the server.
        </li>
  </ol>
  <p>
    Expected result:&amp;nbsp; the application should not authenticate the client.
  </p>
  <p>
    &amp;nbsp;
  </p>
  <h2>
    <em>Testing for Normal LDAP Injection Information Disclosure</em>
  </h2>
  <p>
    To test for information disclosure using normal LDAP injection you must follow these steps:
  </p>
  <ol>
    <li>
      Open a client that uses LDAP to display user information (this can be a web browser if the LDAP application is implemented as a web application or a client LDAP application in traditional non-web LDAP client/server applications).
      </li>
    <li>
        Modify the filter in use to expand the search over other clients.&amp;nbsp; For example: *, *|, *(|(objectclass=*)), *(|(mail=*)), 
    </li>
    <li>
          Submit form to the server.
        </li>
  </ol>
  <p>
    Expected result:&amp;nbsp; the application should not display additional information, such as information about other clients or LDAP attributes.
  </p>
  <h2>
    <em>Testing for Blind LDAP Injection Information Disclosure</em>
  </h2>
  <p>
    To test for information disclosure using blind LDAP injection you should follow these steps:
  </p>
  <ol>
    <li>
      Open a client that uses LDAP to display user information (this can be a web browser if the LDAP application is implemented as a web application or a client LDAP application in traditional non-web LDAP client/server applications).
      </li>
    <li>
        Modify the filter in use with true or false conditions that attempt to deduce sensitive data such as LDAP attributes.&amp;nbsp; For example, if your username is 
        Bob
         then use the following string to check if the attribute 
        account
         exists [v]:
        &amp;nbsp;
        <ul><li><pre>Bob)(account=*))</pre></li></ul></li>
    <li>
          Submit form to the server.
          </li>
    <li>
            Repeat steps 2 and 3 until disclosure of sensitive information.
          </li>
  </ol>
  <p>
    Expected result:&amp;nbsp; the application should not allow the additional true and false conditions to be injected.
  </p>
  <h1>
    Step 4: Fine-tune Test Case Data
  </h1>
  <p>
    During the final step, you must fine-tune your test case data according to the entry point you are testing through.&amp;nbsp; For instance, when testing through URL parameters, it may be necessary to URL-encode the AND meta-character so that it is not confused with the URL parameter name/value separator (&amp;).
  </p>
  <pre>*)(&amp;(name=*)) (before encoding)
*)(%26(name=*)) (after URL encoding)</pre>
  <p>
    Here are some other LDAP injection hex-encoded test strings you should try [vi]:
  </p>
  <pre>%28
%29
%26
%21
%7C
%2A%7C
%2A%28%7C%28mail%3D%2A%29%29
%2A%28%7C%28objectclass%3D%2A%29%29
*()|%26'</pre>
  <p>
    Finally, make sure you test the application through all its entry points such as web forms, URL parameters, GUI text boxes, and indirect input sources. Remember to test through LDAP URLs of the form:
  </p>
  <pre>ldap://host:port/DN?attributes?scope?<strong>filter</strong>?extensions</pre>
  <p>
    You must modify the filter part of LDAP URLs in an attempt to inject additional LDAP statements:
    
    
  </p>
  <pre>&lt;CODE&gt;ldap://ldap.example.com/cn=John%20Doe,dc=example,dc=com&lt;/CODE&gt;</pre>
  <pre>&lt;CODE&gt;ldap://ldap.example.com/cn=John%20Doe)(users=*,dc=example,dc=com&lt;/CODE&gt;</pre>
  <p>
    &amp;nbsp;
  </p>
  <h1>
    Conclusions
  </h1>
  <p>
    LDAP injection vulnerabilities allow for different attack scenarios such as bypassing authentication and disclosing information about an LDAP directory tree.&amp;nbsp; The cause of this vulnerability lies in failure to properly validate and sanitize user input, and utilizing it to build LDAP queries. It is recommended that you begin testing for LDAP injection bugs by submitting basic test strings aimed at forcing an LDAP-specific error. Then continue by testing for different types of LDAP injection such as normal and blind injection. Finish by fine-tuning your test case data according to the entry point you are testing through.
    
    
  </p>
  <p>
    &amp;nbsp;
  </p>
  <div>
    <br />
  </div>
  <div>
    <hr />
  </div>
  <p>
    [i] <strong>A String Presentation of LDAP Search Filters</strong>. <a href="http://www.ietf.org/rfc/rfc1960.txt">http://www.ietf.org/rfc/rfc1960.txt</a></p>
  <p>
    [ii] 
    
      <strong>Testing for LDAP Injection</strong>. 
    OWASP. 
    <a href="http://www.owasp.org/index.php/Testing_for_LDAP_Injection">
      http://www.owasp.org/index.php/Testing_for_LDAP_Injection
    </a></p>
  <p>
    [iii]&amp;nbsp;
    
      <strong>LDAP Injection and Blind LDAP Injection in Web Applications</strong>. 
    Chema Alonso, Rodolfo Bordón, Antonio Guzmán, y Marta Beltrán.
  </p>
  <p>
  </p>
  <p>
    [iv]&amp;nbsp;
    
      <strong>LDAP Injection Overview</strong>.&amp;nbsp; Ravikanth’s Blog. 
    
      <a href="http://weblogs.asp.net/dvravikanth/archive/2005/12/27/434036.aspx">
        http://weblogs.asp.net/dvravikanth/archive/2005/12/27/434036.aspx
      </a></p>
  <p>
  </p>
  <p>
    [v]&amp;nbsp;
    
      <strong>LDAP Injection - Are Your Web Applications Vulnerable?</strong>
      &amp;nbsp;
    
    Sacha Faust, SPI Dynamics. 
    
      <a href="http://www.networkdls.com/Articles/LDAPinjection.pdf">
        http://www.networkdls.com/Articles/LDAPinjection.pdf
      </a>
      &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
    
    
    
  </p>
  <p>
    [vi]&amp;nbsp;
    
      <strong>OWASP Testing Guide Appendix C: Fuzz Vectors</strong>. 
    OWASP
    .&amp;nbsp; 
    <a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">
      http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors
    </a></p>
  <p>&amp;nbsp;</p>
  <p>
    &amp;nbsp;
  </p>]]></Data>
  </Content>
</TeamMentor_Article>