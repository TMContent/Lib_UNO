<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="870580244" Content_Hash="-1350542704">
  <Metadata>
    <Id>77b28aa2-db51-4f60-8f28-1b48f51946ad</Id>
    <Id_History>8a337461-608b-433e-9433-28dd18dc7826,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Protect Secrets In Memory</Title>
    <Category>Sensitive Data</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>How To</Type>
    <DirectLink>How to Protect Secrets In Memory</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Chaitanya Bijwe</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>Description</h1>
  <p>You should consider encrypting sensitive data, such as user names and passwords, in memory as well as in persistent stores. This helps protect the data even if someone manages to probe your computer's memory or obtain a process-crash dump file. </p>
  <p>You can protect sensitive data in memory by using the <b>ProtectedMemory</b> class. The <b>ProtectedMemory</b> class is a managed wrapper for DPAPI. You can also use the <b>SecureString</b> type for storing sensitive strings in memory. <b>SecureString</b> data is automatically encrypted (by using <b>ProtectedMemory</b>). You can also programmatically clear <b>SecureStrings</b> in memory. </p>
  <p>The following code example shows how to use the <b>ProtectedMemory</b> class to encrypt and decrypt data in memory. </p>
  <pre>using System.Security.Cryptography;...<br />byte[] optionalEntropy = {7,5,4,9,0};<br />byte[] dataToBeEncrypted = Encoding.Unicode.GetBytes("Test String 1211");<br />// Encrypt the data in memoryProtectedMemory.Protect(dataToBeEncrypted,<br />                          MemoryProtectionScope.SameLogon);<br />// Decrypt the data in memoryProtectedMemory.Unprotect(dataToBeEncrypted,<br />                           MemoryProtectionScope.SameLogon);<br />string originalData = Encoding.Unicode.GetString(dataToBeEncrypted);</pre>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>