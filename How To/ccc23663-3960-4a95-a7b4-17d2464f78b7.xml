<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1738215510" Content_Hash="-1391158152">
  <Metadata>
    <Id>ccc23663-3960-4a95-a7b4-17d2464f78b7</Id>
    <Id_History>d5a27666-87d9-45ae-9d12-f1e83c384b53,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Create An Input And Data Validation Architecture</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>How To</Type>
    <DirectLink>How to Create An Input And Data Validation Architecture</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Chaitanya Bijwe</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>Description</h1>
  <p>When you develop an input- and data-validation architecture for your application, consider developing a library of validation routines in all but the smallest applications. This will help ensure that data is validated in a consistent way throughout the application and provide a single point of maintenance. You need to trace data from entry point to exit point to know how it should be validated. A good library includes routines for all of the different types of validation you need to apply, and these can be used in combination if necessary. For example, you should have routines to apply validation for SQL injection and other routines to apply validation for cross-site scripting. </p>
  <p>Constrain what you allow from the beginning. It is much easier to validate data for known valid types, patterns, and ranges (using a white list) than it is to validate data by looking for known bad characters (using a black list). When you design your application, you know what your application expects. The range of valid data is generally a more finite set than the range of potentially malicious input. However, for added defense you might want to reject known bad input and then sanitize the input. Constrain input for type, length, format, and range. Use regular expressions to help constrain text input. Use strong data typing where possible. </p>
  <p>Also identify your trust boundaries, and ensure that entry points between trust boundaries validate all input data explicitly. Make no assumptions about the data. The only exception is inside a routine that you know can only be called by other routines within the same trust boundary. </p>
  <br />
  <hr />
  <p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>