<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-355706399" Content_Hash="793845105">
  <Metadata>
    <Id>4fee0127-1779-4e96-a8d2-8d6c210d24cb</Id>
    <Id_History>ead8c969-0df0-44fc-8e89-37b1fb7aa7b0,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Test for Double Encoding Bugs in ASP.NET</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology>ASP.NET 2.0</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>ASP.NET applications </li>
  </ul>
  <p>&nbsp;</p>
  <h1>Summary</h1>
  <p>During a double encoding attack, the attacker encodes attack data twice using <i>hex representation of a character (using methods known as percent encoding or URL encoding) </i>&nbsp;so that the attack data is not detected by security filters. This vulnerability is often used during SQL injection, cross-site scripting, and path traversal attacks in order to submit malicious data through request parameters.&nbsp; A vulnerable application decodes the attack data twice before executing the malicious command.&nbsp; </p>
  <p>Follow these steps to test for double encoding bugs:</p>
  <ul>
    <li>Step 1: Understand attack scenarios
<li>Step 2: Analyze causes and countermeasures
<li>Step 3: Start testing and exploring
<li>Step 4: Execute additional testing</li></li></li></li>
  </ul>
  <p>
    <b>&nbsp;</b>
  </p>
  <h1>Step 1:&nbsp; Understand Attack Scenarios</h1>
  <p>The first step in testing for double encoding vulnerabilities is to understand the common attack scenarios:</p>
  <ul>
    <li>Path traversal
<li>Cross-site scripting (XSS)</li></li>
  </ul>
  <p>&nbsp;</p>
  <h2>
    <em>Scenario 1: Path Traversal</em>
  </h2>
  <p>During a path traversal attack, an attacker traverses a directory in order to find a secret document:</p>
  <pre>http://victim/documents/getDocs.aspx?docname=../../secret.doc</pre>
  <p>However, the page <i>getDocs.aspx </i>filters out the filename provided in the URL and denies any sequence of two dots followed by a slash: "../" (without the quotes). To get around this, the attacker replaces the dots and &nbsp;slashes with their URL-encoded equivalent (%2e and %2f, respectively):</p>
  <pre>%2e%2e%2f%2e%2e%2fprivate/secret.pdf</pre>
  <p>However, the application also recognizes the sequence <i>%2e%2e%2f</i> as a path traversal construct, and so denies the attack string. So the attacker executes a double encoding attack by re-encoding the percent (%) character with its URL-encoded equivalent (%25):</p>
  <pre>%252e%252e%252f%252e%252e%252fprivate/secret.pdf</pre>
  <p>A vulnerable application decodes the malicious string twice and translates it to a path traversal string, completing the attack.</p>
  <p>&nbsp;</p>
  <h2>
    <em>Scenario 2: Cross-site Scripting</em>
  </h2>
  <p>During a cross-site scripting attack, an attacker needs to submit special characters like pointed brackets, slashes, and backslashes. The attacker might first try to execute a string like this:</p>
  <pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
  <p>If the above string doesn’t work, the attacker might try to URL-encode special characters one time:</p>
  <pre>%3Cscript%3Ealert('XSS')%3C%2Fscript%3E</pre>
  <p>However, the application disallows this string because it contains dangerous URL-encoded characters such as <i>%3C and %3E.</i></p>
  <p>Next, the attacker tries double encoding the attack string:&nbsp;</p>
  <pre>%253Cscript%253Ealert('XSS')%253C%252Fscript%253E</pre>
  <p>Note that the new construct no longer contains singly encoded dangerous hex characters like %3C. The application recognizes the string as safe, and, because it is vulnerable to double encoding, it double decodes the string, translating it to the original XSS construct.</p>
  <p>&nbsp;</p>
  <h1>Step 2: Analyze causes and countermeasures</h1>
  <p>The next step in testing for double encoding bugs is to understand what causes them and how to protect against them.</p>
  <p />
  <p>Some applications protect against malicious input by filtering out dangerous characters. Incoming strings are checked against a list, known as a <i>blacklist</i>, of dangerous constructs<i>. </i>If the input contains a blacklisted construct like “../”, the application doesn’t allow the operation. For instance, the following code implements a blacklist check in <i>exsistsInBlacklist:</i></p>
  <p />
  <pre>if (!existsInBlackList(Request.QueryString["filename"]))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<strong>(1)<br /></strong>{&nbsp;</pre>
  <blockquote>
    <pre>string filename = <br />Server.UrlDecode(Request.QueryString["filename"]);</pre>
    <pre>StreamReader streamReader = new StreamReader(filename);&nbsp;&nbsp; &nbsp;<strong>&nbsp;(2)</strong></pre>
    <pre>while (streamReader.Peek() &gt;= 0)<br />{<br />	Response.Write(streamReader.ReadLine());<br />}</pre>
    <pre>streamReader.Close();</pre>
  </blockquote>
  <pre>}</pre>
  <p>If the application wants to protect against path traversal, it would need to include double-encoded characters sequences such as <i>%252e%252e%252f </i>in its blacklist. Failing to do so would lead to a double encoding vulnerability. A better option would be implementing the check for a malicious construct on the canonical form. However, blacklists are not recommended because they must account for 100% of dangerous constructs; any dangerous construct not covered in the blacklist allows attacks on the application.</p>
  <p>&nbsp;</p>
  <p>To protect against this vulnerability, use a <i>whitelist</i> approach. Whitelists allow only valid constructs; any construct not in the whitelist is automatically disallowed. This way, developers need only define what is good, and don’t have to worry about covering 100% of all dangerous constructs. For instance, the code below enforces a whitelist that uses a regular expression to check for safe input filenames. The regular expression allows only filenames of five to eight upper- or lower-case letters followed by the “.doc” string (with no quotes). Any string that doesn’t match this form, like the path traversal string “../”, causes the application to produce an error message:</p>
  <p />
  <pre>string filename = Server.UrlDecode(Request.QueryString["filename"]);&nbsp;<strong> (1)</strong></pre>
  <pre>Regex validFilename = new Regex("^[a-zA-Z]{5,8}\.doc$");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>(2)</strong></pre>
  <pre>if (!validFilename.IsMatch(filename))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />{<br />	Response.Write("invalid input");<br />}<br />else<br />{<br />	StreamReader streamReader = new StreamReader(filename);</pre>
  <pre>	&nbsp;while (streamReader.Peek() &gt;= 0)</pre>
  <pre>&nbsp;	/* continue opening file */ </pre>
  <pre>}&nbsp;<br /></pre>
  <p>Note that the code uses the whitelist approach on the canonical form of the input. It first decodes the input (1) and then calls the regular expression on the decoded input (2).</p>
  <p>
    <b>&nbsp;</b>
  </p>
  <h1>Step 3: Start Testing and Exploring</h1>
  <p>Now that you’ve looked at double encoding attack scenarios and understand what causes them and how to protect against them, it is necessary to include double encoding issues when testing for different security issues.&nbsp; </p>
  <h2>
    <em>Test for Double Encoding during Path Traversal</em>
  </h2>
  <p>Follow the next steps to test for double encoding bugs during path traversal attacks:</p>
  <ol>
    <li>Identify all locations in the application where the input is used to find a file on the server.
<li>Submit path traversal attack strings (for more information, see <i>Testing for Path Traversal Bugs</i>) on all such locations. Modify any path traversal attack string with a double encoding string.<i>&nbsp;&nbsp; </i><li>Check if the path is traversed.</li></li></li>
  </ol>
  <p>Expected results:&nbsp; No paths should be allowed to be traversed.</p>
  <p>
    <i>Example Attack Strings:</i>
  </p>
  <table>
    <tbody>
      <tr>
        <td>
          <p>
            <b>Attack String</b>
          </p>
        </td>
        <td>
          <p>
            <b>Single encoding</b>
          </p>
        </td>
        <td>
          <p>
            <b>Double encoding</b>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <pre>../../..</pre>
        </td>
        <td>
          <p>..%2F..%2F..</p>
        </td>
        <td>
          <pre>..%252F..%252F..</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>../../..</pre>
        </td>
        <td>
          <p>%2E%2E%2F%2E%2E%2F%2E%2E</p>
        </td>
        <td>
          <p>%252E%252E%252F%252E%252E%252F%252E%252E</p>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    <b>&nbsp;</b>
  </p>
  <p>Note that some attack strings can be single-encoded differently. This applies to all of the remaining attacks.</p>
  <p>
    <b>&nbsp;</b>
  </p>
  <h2>
    <em>Test for Double Encoding during Cross-site Scripting (XSS)</em>
  </h2>
  <p>Follow the next steps to test for double encoding bugs during cross-site scripting:</p>
  <ol>
    <li>Identify all locations in the application where the input is a) reflected from web forms, b) URL parameters, or c) loaded from a persistent store such as a database.
<li>Submit XSS attack strings on all such locations (for more information, see <i>Testing for Cross-Site Scripting (XSS) Bugs</i>). Modify any URL-encoded XSS attack string with a double-encoded string.
<li>Reload the page containing the modified location and check if the injected script executes.</li></li></li>
  </ol>
  <p />
  <p>Expected results:&nbsp; None of the injected scripts should execute.</p>
  <p>
    <i>Example Attack Strings:</i>
  </p>
  <table>
    <tbody>
      <tr>
        <td>
          <p>
            <b>Attack String</b>
          </p>
        </td>
        <td>
          <p>
            <b>Single encoding</b>
          </p>
        </td>
        <td>
          <p>
            <b>Double encoding</b>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
        </td>
        <td>
          <pre>%3Cscript%3Ealert('XSS')%3C%2Fscript%3E</pre>
          <p>&nbsp;</p>
        </td>
        <td>
          <pre>%253Cscript%253Ealert('XSS')%253C%252Fscript%253E</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>&gt;"'&gt;&lt;img src='javascript:alert('XSS');"&gt;</pre>
        </td>
        <td>
          <p>%3E%22%27%3E%3Cimg%20src%3D%27javascript%3Aalert%28%27XSS%27%29%3B%22%3E</p>
        </td>
        <td>
          <p>%253E%2522%2527%253E%253Cimg%2520src%253D%2527javascript%253Aalert%2528%2527XSS%2527%2529%253B%2522%253E</p>
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    <b>
      <i>&nbsp;</i>
    </b>
  </p>
  <h2>
    <em>Test for Double Encoding during SQL Injection</em>
  </h2>
  <p>Follow the next steps to test for double encoding bugs in SQL injection scripting:</p>
  <ol>
    <li>Identify all locations in the application where input is a) reflected from web forms, b) URL parameters, c) GUIs, or d) loaded from a persistent store such as a database.
<li>Submit SQ<i>L injection strings </i>on all such locations <i>(for more </i>i<i>n</i>formation, see <i>Testing for SQL Injection Bugs</i>)<i>.</i><b></b>Modify any URL-encoded SQL injection attack string with a double-encoded string.<i>&nbsp;&nbsp; </i><li>Check if the application processed the injected SQL statement.</li></li></li>
  </ol>
  <p />
  <p>Expected results:&nbsp; None of the injected statements should be allowed.</p>
  <p>
    <i>Example Attack Strings:</i>
  </p>
  <table>
    <tbody>
      <tr>
        <td>
          <p>
            <b>Attack String</b>
          </p>
        </td>
        <td>
          <p>
            <b>Single encoding</b>
          </p>
        </td>
        <td>
          <p>
            <b>Double encoding</b>
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <pre>a' or 1=1--</pre>
        </td>
        <td>
          <p>a%27%20or%201%3D1--</p>
        </td>
        <td>
          <pre>a%2527%2520or%25201%253D1--</pre>
        </td>
      </tr>
      <tr>
        <td>
          <pre>') or ('a'='a</pre>
        </td>
        <td>
          <p>%27%29%20or%20%28%27a%27%3D%27a</p>
        </td>
        <td>
          <p>%2527%2529%2520or%2520%2528%2527a%2527%253D%2527a</p>
        </td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <h1>Step 4: Execute Additional Testing</h1>
  <p>The final step in testing for double encoding vulnerabilities is to look for them when executing any attacks that use hex character encoding. Additional attacks may include:</p>
  <ul>
    <li>XML injection
<li>LDAP injection
<li>Command injection
<li>HTTP response splitting
<li>URL parameter tampering
<li>XPath injection</li></li></li></li></li></li>
  </ul>
  <p>&nbsp;</p>
  <h1>Conclusions</h1>
  <p>Attackers commonly use double encoding to bypass security filters when attacking the application through HTTP request parameters. To test for double encoding bugs, you must understand the attack scenarios, what causes them, and how to defend against them. Apply this knowledge when testing for request parameter bugs such as XSS, SQL injection, and path traversal. Finally, include double encoding test cases for any security vulnerability payloads tested via HTTP request parameters.</p>]]></Data>
  </Content>
</TeamMentor_Article>