<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="323491882" Content_Hash="-44842668">
  <Metadata>
    <Id>d7e22dcf-901e-45b5-a5bd-8e4e3b3555b6</Id>
    <Id_History>98e4756d-c4d7-4e1f-bae1-2144af9409c0,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Use Hashing</Title>
    <Category>Cryptography</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Chaitanya Bijwe</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>Description</h1>
  <p>Use a hashing algorithm, such as SHA256, SHA1 or MD5, when you need a principal to prove it knows a secret that it shares with you. You can use SHA256 on the .NET Framework version 2.0 because it provides a managed implementation of SHA256. For .NET Framework version 1.1, you should use SHA1 and not MD5 because it generates a 160-bit hash output, while MD5 generates a 128-bit output. The following code example shows how to use a hashing algorithm, such as SHA1, to hash data. </p>
  <pre>using System.Security.Cryptography;...<br />// Create a new instance of the hash crypto service provider.<br />HashAlgorithm hashAlg = new SHA1CryptoServiceProvider(); <br />// Convert the data to hash to an array of Bytes.<br />byte&#91;&#93; bytValue = System.Text.Encoding.UTF8.GetBytes(stringDataToHash);<br />// Compute the Hash. This returns an array of Bytes.<br />byte&#91;&#93; bytHash = hashAlg.ComputeHash(bytValue);<br />// Optionally, represent the hash value as a base64-encoded string, <br />// For example, if you need to display the value or transmit it over a network.<br />string base64 = Convert.ToBase64String(bytHash);  </pre>
  <p>When you have computed and stored a hash value for a password (for example), you can check that a caller knows the password by prompting for the password, using the supplied data to recalculate the hash value, and then comparing the result to the stored hash. </p>
  <blockquote>
    <b>Note</b>&nbsp;&nbsp;&nbsp;Password hashing enables you to verify&#8212;but not retrieve&#8212;a password value.</blockquote>
  <p>If you use hashes to store passwords in a database, you should combine the password with a random salt value before computing the hash. You can compute the salt value by using the <b>RNGCryptoServiceProvider</b> class, as shown in the following code example. </p>
  <pre>using System.Security.Cryptography;...<br />private static string CreateSalt(int size)&#123;<br />    // Generate a cryptographic random number using the cryptographic <br />    // service provider<br />    RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();<br />    byte&#91;&#93; buff = new byte&#91;size&#93;;<br />    rng.GetBytes(buff);<br />    // Return a Base64 string representation of the random number<br />    return Convert.ToBase64String(buff);<br />&#125;  </pre>
  <blockquote>
    <b>Note</b>&nbsp;&nbsp;&nbsp;If you use the ASP.NET SQL Server membership provider, you can configure it to store password hashes with added salt by setting <b>passwordFormat="Hashed"</b> on the provider configuration.</blockquote>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information see, "Security Practices: .NET Framework 2.0 Security Practices at a Glance" at <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/PAGPractices0002.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/PAGPractices0002.asp</a></li>
  </ul>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>