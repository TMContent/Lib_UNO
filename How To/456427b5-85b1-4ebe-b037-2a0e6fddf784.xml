<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-2009221484" Content_Hash="13791186">
  <Metadata>
    <Id>456427b5-85b1-4ebe-b037-2a0e6fddf784</Id>
    <Id_History>1d19ec52-e37f-47f5-a91f-d88691655dd8,</Id_History>
    <Library_Id>ea854894-8e16-46c8-9c61-737ef46d7e82</Library_Id>
    <Title>How to Use SecureString To Protect Data In Memory</Title>
    <Category>Sensitive Data</Category>
    <Phase>Implementation</Phase>
    <Technology>.NET 2.0</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>J.D. Meier, Alex Mackman, Blaine Wastell, Prashant Bansode, Chaitanya Bijwe</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to</h1>
  <ul>
    <li>.NET 2.0</li>
  </ul>
  <h1>Description</h1>
  <p>Use of the <b>SecureString</b> class is less appropriate in ASP.NET applications. It is unlikely that you can extract data from a Web page that contains sensitive data (such as a credit card number) and place it inside a <b>SecureString</b> without it having already passed through intermediate <b>System</b>.<b> String</b> objects. In some scenarios, for example in console applications, you can take sensitive data directly from the user and construct a <b>SecureString</b> object one character at a time by using the <b>AppendChar</b> method. The following code example shows how to do this. </p>
  <pre>
    <pre>using System.Securtiy;<br />SecureString securePassword = new SecureString();<br /> Console.WriteLine("Enter Password....");<br /> while (true)<br /> &#123;<br />    ConsoleKeyInfo conKeyInfo = Console.ReadKey(true);<br />    if (conKeyInfo.Key == ConsoleKey.Enter)<br />        break;<br />    else if (conKeyInfo.Key == ConsoleKey.Escape)<br />        return;<br />    else if (conKeyInfo.Key == ConsoleKey.Backspace)<br />    &#123;<br />        if (securePassword.Length &#33;= 0)<br />            securePassword.RemoveAt(securePassword.Length - 1);<br />    &#125;<br />    else<br />        securePassword.AppendChar(conKeyInfo.KeyChar);<br />&#125;<br />Console.WriteLine(securePassword.Length.ToString());  </pre>
  </pre>
  <blockquote>
    <p>
      <b>Note</b>&nbsp;&nbsp;&nbsp;<b>SecureString</b> does not support inspection, comparison, or conversion functionality. It cannot be manipulated to reveal the data.</p>
  </blockquote>
  <p>To subsequently use the data from <b>SecureString</b>, use the <b>Marshal.SecureStringToBSTR</b> method, as follows.</p>
  <pre>
    <p>
    </p>
    <pre>using System.Runtime.InteropServices;<br />void UseSecretData(SecureString secret)<br />&#123;<br />    IntPtr bstr = Marshal.SecureStringToBSTR(secret);<br />    try<br />    &#123;<br />        // Use the bstr here<br />    &#125;<br />    finally<br />    &#123;<br />        // Make sure that the clear text data is zeroed out.<br />        Marshal.ZeroFreeBSTR(bstr);<br />    &#125;<br />&#125;  </pre>
  </pre>
  <p>As soon as you are finished with the data, make sure that you use the <b>Marshal.ZeroFreeBSTR</b> method to clear the text data. </p>
  <blockquote>
    <b>Note</b>&nbsp;&nbsp;&nbsp;Avoid converting back and forth between regular strings and secure strings because regular strings are immutable and you cannot clear them. As a result, you could have multiple copies of unencrypted strings in memory.</blockquote>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information see, "Security Practices: .NET Framework 2.0 Security Practices at a Glance" at <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/PAGPractices0002.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnpag2/html/PAGPractices0002.asp</a></li>
  </ul>
  <h1>&nbsp;</h1>
  <hr />
  <p>Adapted from Microsoft patterns & practices guidance.</p>]]></Data>
  </Content>
</TeamMentor_Article>