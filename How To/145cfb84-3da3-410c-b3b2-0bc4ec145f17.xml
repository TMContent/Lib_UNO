<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-115863020" Content_Hash="-951618371">
  <Metadata>
    <Id>145cfb84-3da3-410c-b3b2-0bc4ec145f17</Id>
    <Id_History>d7682043-0095-4700-97dd-01ce797c4ada,</Id_History>
    <Library_Id>c4b9cb6a-4561-4451-9b6c-4e59d73584f6</Library_Id>
    <Title>How to Test for Deserialization of Untrusted Data Bugs in Java</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology>Java</Technology>
    <Type>How To</Type>
    <DirectLink>How to Test for Deserialization of Untrusted Data Bugs in Java</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>
    <span>Applies to</span>
  </h1>
  <ul>
    <li>J2EE applications</li>
  </ul>
  <h1>
    <span>Summary</span>
  </h1>
  <p>J2EE applications that use serialization/deserialization of data might be vulnerable to deserialization of untrusted data bugs.<span>&amp;nbsp;</span>To exploit this bug, an attacker tampers with the data that will be deserialized by the application so that the application deserializes a malicious data stream.<span>&amp;nbsp; </span>An attacker can use malicious serialization data in order to inject client-side scripts, perform denial-of-service (DoS) attacks, or execute logical attacks on the target application.</p>
  <p>Follow these steps to test for deserialization of untrusted data bugs in J2EE:</p>
  <ul>
    <li>Step 1: Understand attack scenarios <li>Step 2: Analyze causes and countermeasures <li>Step 3: Execute test cases</li></li></li>
  </ul>
  <h1>
    <span>Step 1: Understand Attack Scenarios</span>
  </h1>
  <p>The first step in learning how to test for deserialization bugs in J2EE is to understand the anatomy of&amp;nbsp;the attack scenarios.<span>&amp;nbsp;</span>Attack scenarios include but are not limited to:</p>
  <ul>
    <li>Client-side script injection <li>Denial-of-service attacks <li>Logical attacks<br /></li></li></li>
  </ul>
  <p>During a deserialization of untrusted data attack, an attacker tampers with serialized data or submits malicious serialized data so that the application behaves unexpectedly when it starts to deserialize it.<span>&amp;nbsp; </span></p>
  <p>In detail:</p>
  <ol>
    <li>The attacker&amp;nbsp;determines where&amp;nbsp;an application&amp;#8217;s functionality inputs serialized data dynamically or from a permanent store. <li>If the application dynamically inputs serialized data, the attacker inputs malicious serialized data.<br />If the application inputs serialized data from a permanent store such as a file or database, the attacker tampers with this store and writes the malicious serialized data. <li>The attacker waits for the application to react upon deserializing the malicious data. </li></li></li>
  </ol>
  <h2>
    <span>
      <em>Scenario 1: Client-side script injection</em>
    </span>
  </h2>
  <p>Data deserialization, the opposite of data serialization, is used by J2EE applications that extract a sequence of bytes into an object.<span>&amp;nbsp;</span>For instance, a J2EE application uses the <i>Person</i> class defined as follows:</p>
  <pre>
    <span>package com.example.servlet;<br />import java.io.Serializable;<br />&amp;nbsp;<br />import java.io.ObjectInputStream;<br />&amp;nbsp;<br />public class Person implements <strong>Serializable<br /></strong>&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; private String firstName;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; private String lastName;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; private int age;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public Person()<br />    &amp;#123;<br />&amp;nbsp; &amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public String getFirstName()<br />    &amp;#123;<br /> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return firstName;<br />&amp;nbsp; &amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public void setFirstName(String firstName)<br />    &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; this.firstName = firstName;<br /> &amp;nbsp;&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public String getLastName()<br />    &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return lastName;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public void setLastName(String lastName)<br />    &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; this.lastName = lastName;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public int getAge()<br />    &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return age;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; public void setAge(int age)<br />    &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; this.age = age;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;#125;&amp;nbsp;&amp;nbsp; <br /> &amp;#125;</span>
  </pre>
  <p>In a separate class, the application has code that creates a sample output file named <i>out.obj</i> using two elements of the <i>Person</i> class<i>:</i></p>
  <pre>String filename = "c:\\tests\\out.obj";<br />outputStream = new ObjectOutputStream(new FileOutputStream(filename));<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />Person person = new Person();<br />person.setFirstName("John");<br />person.setLastName("Smith");<br />person.setAge(19);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />outputStream.writeObject(person);<br />&amp;nbsp;<br />person = new Person();<br />person.setFirstName("Paul");<br />person.setLastName("Rocks");<br />person.setAge(39);<br />&amp;nbsp;<br />outputStream.writeObject(person);<br />outputStream.close();</pre>
  <p>A separate application&amp;#8217;s functionality reads the serialized data from the file and prints the last name value of the first element in the file:</p>
  <pre>String filename&amp;nbsp; = "c:\\tests\\out.obj";<br />ObjectInputStream in = new ObjectInputStream(new FileInputStream(filename));<br />Person person2 = (Person)in.readObject();<br />out.write(person2.getLastName());&amp;nbsp;</pre>
  <p>If the file remains unchanged, as when originally written by the application, the output is the following:<span>&amp;nbsp; </span><i>Smith.</i><span>&amp;nbsp;</span>The object file <i>out.obj </i>looks like Figure 1 under a hex editor.<span></span>Note that the highlighted data of the object file is the last name <i>Smith</i> preceded by the length of the last name (5).<span>&amp;nbsp; </span></p>
  <p />
  <span>However, an attacker might tamper with the serialized data in order to inject a malicious client-side script. </span>
  <span>
    <span>
      <span>This results in the browser displaying an alert box that confirms that the client-side script has been injected.<span></span>An attacker who is able to modify the untrusted data source used might be able to inject a client-side script that is displayed to all clients.<span>&amp;nbsp;</span>This attack scenario is similar to stored Cross-Site Scripting (XSS) where the attacker injects a client-side script in a data source.<p /><p><span></span></p><h2><span><em>Scenario 2: Denial-of-service attack</em></span></h2><p>An attacker might also attempt a denial-of-service attack on the application by trying to crash the J2EE application or put it into a state that prevents the application from properly servicing its users.<span>&amp;nbsp;</span>For example, a J2EE application might use JSON (JavaScript Object Notation) to transmit serialized data.</p><p>Here the attacker can tamper with opening and closing characters of the JSON notation:</p><pre><span>&amp;#123;"Addresses": <br />&amp;#91;&amp;#123;"City":"Seatle","State":"WA","Street":"123 Wall St.","Zip":"98101"&amp;#125;, <br />&amp;#123;"City":"Boston","State":"MA","Street":"33 St. Paul St","Zip":"02109"&amp;#125;&amp;#93;, <br />"Entered":"\/Date(1191992400000-0500)\/",<br />"Name<strong>":"&amp;#125;&amp;#93;&amp;#125;&amp;#125;)&amp;#125; </strong></span></pre><p>The attacker is trying to cause a parsing error in the application&amp;nbsp;that will cause&amp;nbsp;an unhandled exception that might eventually cause the application thread to terminate.</p><p>Additionally, an attacker can attempt to exploit recursive elements by adding an excessive number of recursion levels or try to&amp;nbsp;exploit array elements by adding an excessive number of array elements.<span>&amp;nbsp;</span>For example, if the application uses an <i>Addresses</i> array, an attacker might add numerous array elements to the <i>Addresses</i> array:<span></span></p><pre><span><span>&amp;#123;"Addresses": <br /><strong>&amp;#91;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;</strong><br />&amp;#123;"City":"a","State":"b","Street":"c","Zip":"d"&amp;#125;<br />&amp;#123;"City":"Seatle","State":"WA","Street":"123 Wall St.","Zip":"98101"&amp;#125;, <br />&amp;#123;"City":"Boston","State":"MA","Street":"33 St. Paul St","Zip":"02109"&amp;#125;&amp;#93;,<br />"Entered":"\/Date(1191992400000-0500)\/",<br />"Name":"John Smith"&amp;#125;</span></span></pre><p><span></span></p><p><span></span></p><h2><span><em>Scenario 3: Logical attacks</em></span></h2><p>The last scenario&amp;nbsp;is logical attacks on the application where the data modified by the attacker causes the application to behave differently by&amp;nbsp;following an unexpected execution path or executing additional attacker-provided code.<span>&amp;nbsp;&amp;nbsp; </span></p><p>For example, an application deserializes the <i>Lottery</i> class below.<span>&amp;nbsp;</span>The class makes sure that when a new lottery is created in the constructor, the <i>ticket</i> is always below 20,000.<span>&amp;nbsp;</span>However, the application fails to perform input validation after deserialization, so<span>&amp;nbsp;a</span>n attacker can tamper with the deserialized data and force a larger number for the ticket variable in order to create a different logical flow or a potential integer overflow &amp;#91;i&amp;#93;: </p><pre>import java.io.Serializable;<br />import java.io.ObjectInputStream;<br />import java.io.IOException;<br />import java.util.Random;<br />&amp;nbsp;<br />public class Lottery implements <strong>Serializable</strong><br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp; private int ticket = 1;<br />&amp;nbsp; Random draw = new Random();<br />&amp;nbsp;<br />&amp;nbsp; public Lottery(int ticket)<br />  &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; this.ticket = (int) (Math.abs(ticket &amp;#37; 20000) &amp;#43; 1);<br />&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp; public int getTicket()<br />  &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; return this.ticket;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; <br />&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp; public int roll()<br />  &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; this.ticket = (int) ((Math.abs(draw.nextInt()) &amp;#37; 20000) &amp;#43; 1);<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; return this.ticket;<br />&amp;nbsp; &amp;#125;<br />&amp;nbsp;<br />&amp;nbsp; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException<br />  &amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp; in.defaultReadObject();<br />&amp;nbsp; &amp;#125;<br />&amp;#125;</pre><p>The application is vulnerable because any calls to <i>readObject()</i><span>&amp;nbsp;</span>to read from the <em>Lottery</em> object after deserialization will not go through the constructor and the ticket value&amp;nbsp;will not be&amp;nbsp;validated against a maximum allowed integer value of 20,000 after deserialization.</p><h1><span>Step 2: Analyze Causes and Countermeasures</span></h1><p>Next it is necessary to analyze what causes and how to protect against deserialization of untrusted data attacks.</p><h2><span><em>Accepting untrusted serialized data</em></span></h2><p>This attack is possible when an application accepts untrusted data as input to a deserialization routine without validating the integrity of the untrusted data.<span></span>As a result, the attacker is able to submit malicious data for the application to deserialize.<span></span>A possible mitigation consists adding a cryptographic checksum to serialized messages to detect tampering of serialized data.</p><h2><span><em>Using a secure channel</em></span></h2><p>A similar option to implementing a cryptographic framework for serialized data is to send all serialized data using a secure channel.<span>&amp;nbsp;</span>Developers can choose different secure channel implementations such as SSL/TLS and IPSec.</p><h2><span><em>Perform input validation in the readObject() method</em></span></h2><p>Applications written in Java can protect against deserialization of untrusted data attacks by overriding the <i>readObject()</i> method in the target class and doing the necessary input validation in the <i>readObject()</i> override.<span></span>For example, in order to deactivate deserialization of the <i>Person</i> object, the J2EE application can add the following code to <em>Person.java</em>:</p><pre>private final void readObject(ObjectInputStream in)<br />                         throws java.io.IOException <br />&amp;#123;<br />&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; throw new java.io.IOException("Cannot be deserialized");<br />&amp;#125;</pre><p>However, deserialization might be needed so it would be better to validate the object here.<span></span>For example, in the&amp;nbsp;final scenario of the previous section, the application might have added the check for an incorrect ticket value in the <i>readObject()</i> overload:<span>&amp;nbsp; </span></p><pre>private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException<br />&amp;#123;<br />&amp;nbsp; &amp;nbsp;&amp;nbsp; in.defaultReadObject();<br /> &amp;nbsp;&amp;nbsp;&amp;nbsp; this.ticket = (int) (Math.abs(this.ticket &amp;#37; 20000) &amp;#43; 1);&amp;nbsp; //perform input validation<br />&amp;#125;</pre><h1><span>Step 3: Execute Test Cases</span></h1><p><span>Now that you&amp;#8217;ve reviewed the theoretical aspects of deserialization of untrusted data bugs, it is necessary to execute the following test cases to check if your application is vulnerable.</span></p><h2><span><em>Test for deserialization of unstrusted data dynamically</em></span></h2><p><span>Follow these steps:</span></p><ol><li><span>Discover an application&amp;#8217;s functionality that dynamically takes untrusted serialized data (from the URL, Web form, or other client-accessible input point) and deserializes the data.</span><li><span>Modify the input data to add malicious data (such as an injected script) and feed the data to the application.</span><li><span>Wait till the application deserializes the data.</span></li></li></li></ol><p><span>Expected results:<span>&amp;nbsp;</span>The application is vulnerable if it allows for malicious modification of the serialized data.<span>&amp;nbsp;</span>That is, if modification results in an insecure condition such as script injection, denial-of-service, or a logical attack on the application.</span></p><p><b><i><span></span></i></b></p><h2><span><em>Test for deserialization of unstrusted data through a data store</em></span></h2><p><span>Follow these steps:</span></p><ol><li><span>Discover an application&amp;#8217;s functionality that takes untrusted serialized data from a physical store (from a file, database, or other client-accessible data store) and deserializes the data.</span><li><span>Modify the data store to add malicious data (such as an injected script) and feed the data to the application.</span><li><span>Wait till the application deserializes the data.</span></li></li></li></ol><p><span>Expected results:<span>&amp;nbsp;</span>The application is vulnerable if it allows for malicious modification of the serialized data.<span></span>That is, if modification results in an insecure condition such as script injection, denial-of-service, or a logical attack on the application.</span></p><p><span></span></p><h1><span>Conclusions</span></h1><p>Deserialization of untrusted data is a security concern as it allows attackers to execute different attacks on the application such as injecting a client-side script, denying the service of the application, and logically exploiting the application&amp;#8217;s behavior for the attacker&amp;#8217;s benefit.<span></span>To test for this vulnerability in J2EE applications, it is suggested to start by understanding the different attack scenarios.<span>&amp;nbsp;</span>Continue by reviewing what causes this vulnerability and how to protect against it.<span>&amp;nbsp;</span>Finally, execute different test cases based on the input point that the application uses to gather the serialized data.</p><p><span>&amp;nbsp;</span></p><div><div><p><span><span><span><span>&amp;#91;i&amp;#93;</span></span></span></span><b>SER04-J. Validate deserialized objects</b>. Added by Dhruv Mohindra, last edited by&amp;nbsp;Dean Sutherland&amp;nbsp;on Oct 22, 2010.<span>&amp;nbsp; </span>CERT. <a href="http://www.securecoding.cert.org/confluence/display/java/SER04-J.&amp;#43;Validate&amp;#43;deserialized&amp;#43;objects">http://www.securecoding.cert.org/confluence/display/java/SER04-J.&amp;#43;Validate&amp;#43;deserialized&amp;#43;objects</a></p></div></div></span>
    </span>
  </span>
  <h1>Input and Data Validation Guidelines</h1>
  <ul>
    <li>
      <a href="/article/b531d29c-86f7-4812-90ce-5f3f0f780aba">Validate Input from All Sources</a>
    </li>
    <li>
      <a href="/article/c98695c5-cf02-44a1-96bf-1f8046b8ad9d">Validate Input for Length, Range, Format, and Type</a>
    </li>
    <li>
      <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">
        <a href="/article/67060e7b-7145-4e84-b574-c07548f81d9f">Validate All Input Passed to the Database</a>
      </a>
    </li>
    <li>
      <a href="/article/a5491c44-164b-4046-94d3-b575b9745e8b">Filter All User-Supplied Filename and Path Input</a>
    </li>
    <li>
      <a href="/article/9f21442f-2aee-4573-8be6-a5b51d9c89b8">Do Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Checklists</h1>
  <ul>
    <li>
      <a href="/article/7f8deb21-cd52-41be-80b4-8897612021dc">Input from All Sources Is Validated</a>
    </li>
    <li>
      <a href="/article/61869793-2c10-40c0-b82a-babcc0312697">Input Is Validated for Length, Range, Format and Type</a>
    </li>
    <li>
      <a href="/article/42f4b565-14f7-42f4-8c5a-0f78f357e4c0">All Database Input Is Validated</a>
    </li>
    <li>
      <a href="/article/17884af0-fc83-412a-b613-4def4a6f84ad">User-Supplied Filenames and Paths Are Validated</a>
    </li>
    <li>
      <a href="/article/b1803c35-9579-4a38-9a63-30202160ef25">The Application Does Not Rely on Client-Side Validation</a>
    </li>
  </ul>
  <h1>Input and Data Validation Code Examples</h1>
  <ul>
    <li>
      <a href="/article/0f49430b-2abe-408f-b046-89fa739f5d53">Input Validation Using JSF</a>
    </li>
    <li>
      <a href="/article/18ac74df-602b-4a58-8998-52f638f3a045">Input Validation Using SpringMVC</a>
    </li>
    <li>
      <a href="/article/d124abb1-e230-43ef-8762-1caa0dbb89ca">Input Validation Using Struts 1</a>
    </li>
    <li>
      <a href="/article/2f917654-65a8-49c9-b000-c17f9765bf42">Input Validation Using Struts 2</a>
    </li>
    <li>
      <a href="/article/38342130-4e4b-47df-afd9-c7e8c86f77ee">Use ESAPI Executor</a>
    </li>
  </ul>
  <h1>Input and Data Validation Testing</h1>
  <ul>
    <li>
      <a href="/article/fd3ecaaa-cb7c-43a2-a91a-f19862f736d4">How to Test for Server-Side Code Injection in Java</a>
    </li>
    <li>
      <a href="/article/c00b9149-1290-4c9e-bcd0-392a9c5a6fb0">How to Test for Path Manipulation Bugs in Java</a>
    </li>
    <li>
      <a href="/article/5c99da7b-b4eb-4315-b48c-ac2598c13144">How to Test for Double Encoding Bugs in Java</a>
    </li>
    <li>
      <a href="/article/fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f">How to Test for Client-side Validation Bypass Bugs in Java</a>
    </li>
    <li>
      <a href="/article/6f4e927b-bd45-498b-95c4-78fd2c3287c1">How to Test for Integer Overflows in Java</a>
    </li>
    <li>
      <a href="/article/ed20009a-59ef-415d-8e72-0ff3221a1346">How to Test for Integer Underflow Bugs in Java</a>
    </li>
    <li>
      <a href="/article/d7682043-0095-4700-97dd-01ce797c4ada">How to Test for Deserialization of Untrusted Data Bugs in Java</a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>